/*
 * Copyright (C) 2010-2011, Parrot Foundation.
 */

/*
** lorito.ops
*/

BEGIN_OPS_PREAMBLE

#include "m0proto_const.h"
#define M0_ASSERT_REG(r)      PARROT_ASSERT(0 <= r && M0_REG_COUNT-1 >= r)
#define M0_ASSERT_REGS(a,b,c) {M0_ASSERT_REG(a);M0_ASSERT_REG(b);M0_ASSERT_REG(c);}

END_OPS_PREAMBLE

=head1 NAME

m0_proto.ops - Prototype M0 opcodes

=cut

=head1 DESCRIPTION

M0 opcodes

=head2

Cheats

=item B<m0_new_ctx>

Create and initialize a new M0 context, put it into $1.  The context will have
256 registers, numbered as follows.  These names are available in
m0proto_const.h and m0proto_const.pir.

    0       CX  - current context 
    1       PC  - current instruction within the current bytecode segment
    2       EH  - current exception handler
    3       EX  - exception being thrown, if any
    4       PCX - calling (parent) context
    5       VAR - pointer to variables table
    6       MDS - pointer to metadata segment
    7       BCS - pointer to bytecode segment
    8-69    I0 - I61
    70-131  N0 - N61
    132-193 S0 - S61
    194-255 P0 - P61

M0 context is a subclass of FixedFloatArray which is limited to 256 elements
and stores pointers, FLOATVALs and INTVALs in the same array without additional
type information.  The use of a FixedFloatArray assumes that neither INTVAL nor
pointers are larger than FLOATVAL.
Variables are stored in a ResizableFloatArray pointed to by C<ctx[VAR]>.

=cut

op m0_new_ctx(out PMC) {
    INTVAL i;
    $1 = Parrot_pmc_new(interp, Parrot_pmc_get_type_str(interp,
                Parrot_str_new_constant(interp, "m0ctx")));
    /* TODO: initialize the bytecode segment (also, figure out how this is
     *       supposed to work for a dynop-based m0, if at all) */
}

=item B<m0_cstr_var>

Convert the Parrot string $3 into a C string.  Store a pointer to that C
cstring in $1's variables table at slot $2.

=cut

op m0_cstr_var(invar PMC, in INT, in STR) {

    /* Mmmmm.  Leaks. */
    char *cstr     = Parrot_str_to_cstring(interp, $3);
    PMC *var_table = (PMC*)VTABLE_get_pointer_keyed_int(interp, $1, M0_VAR);
    VTABLE_set_number_keyed_int(interp, var_table, $2, *(FLOATVAL*)&cstr);
}

=item B<m0_int_var>

Store INTVAL $3 in $1's variables table at slot $2.

=cut

op m0_int_var(invar PMC, in INT, in INT) {
    PMC *var_table = (PMC*)VTABLE_get_pointer_keyed_int(interp, $1, M0_VAR);
    VTABLE_set_number_keyed_int(interp, var_table, $2, *(FLOATVAL*)&$3);
}

=item B<m0_num_var>

Store FLOATVAL $3 in $1's variables table at slot $2.

=cut

op m0_num_var(invar PMC, in INT, in NUM) {
    PMC *var_table = (PMC*)VTABLE_get_pointer_keyed_int(interp, $1, M0_VAR);
    VTABLE_set_number_keyed_int(interp, var_table, $2, $3);
}

=item B<m0_reg_i>

Assume that register $3 of context $2 is an INTVAL.  Copy that INTVAL into $1.

=cut

op m0_reg_i(out INT, invar PMC, in INT) {
    $1 = VTABLE_get_integer_keyed_int(interp, $2, $3);
}

=item B<m0_reg_n>

Assume that register $3 of context $2 is an FLOATVAL.  Copy that FLOATVAL into
$1.

=cut

op m0_reg_n(out NUM, invar PMC, in INT) {
    $1 = VTABLE_get_number_keyed_int(interp, $2, $3);
}

=head2 M0 Math/Numeric ops

=item V<m0_add_i>

Assume that $1 is an m0 context and that $2, $3 and $4 are ints between 0 and
255.  Treat the registers at $3 and $4 as INTVAL, add them and store the result
in the register at $2.

=cut

op m0_add_i(invar PMC, in INT, in INT, in INT) {
    INTVAL i1, i2;

    M0_ASSERT_REGS($2, $3, $4);
    i1 = VTABLE_get_integer_keyed_int(interp, $1, $3);
    i2 = VTABLE_get_integer_keyed_int(interp, $1, $4);
    VTABLE_set_integer_keyed_int(interp, $1, $2, i1 + i2);
}

=item V<m0_add_n>

Assume that $1 is an m0 context and that $2, $3 and $4 are ints between 0 and
255.  Treat the registers at $3 and $4 as FLOATVAL, add them and store the
result in the register at $2.

=cut

op m0_add_n(invar PMC, in INT, in INT, in INT) {
    FLOATVAL f1, f2;

    M0_ASSERT_REGS($2, $3, $4);
    f1 = VTABLE_get_number_keyed_int(interp, $1, $3);
    f2 = VTABLE_get_number_keyed_int(interp, $1, $4);
    VTABLE_set_number_keyed_int(interp, $1, $2, f1 + f2);
}

=head2 Memory/Variable ops

=item B<m0_load_var>

Load a value from the context's variables table into one of the context's
registers.  The address of the variable is $3 + 256*$4.  The value will be
stored in register $2.

=cut

op m0_load_var(invar PMC, in INT, in INT, in INT) {
    PMC *var_table = (PMC*)VTABLE_get_pointer_keyed_int(interp, $1, M0_VAR);
    INTVAL var_idx = $3 + (256 * $4);
    FLOATVAL val = VTABLE_get_number_keyed_int(interp, var_table, var_idx);
    VTABLE_set_number_keyed_int(interp, $1, $2, val);
}

=item B<m0_copy_mem>

Use the value in register $2 as a destination pointer, $3 as a source pointer
and $4 as a byte count.  Copy that many bytes from the source to the
destination.

=cut

op m0_copy_mem(invar PMC, in INT, in INT, in INT) {
    INTVAL mem_size = VTABLE_get_integer_keyed_int(interp, $1, $4);
    void *mem_src   = VTABLE_get_pointer_keyed_int(interp, $1, $3);
    void *mem_dst   = VTABLE_get_pointer_keyed_int(interp, $1, $2);
    memmove(mem_dst, mem_src, mem_size);
}

=item B<m0_copy_byte>

Use the value in register $2 as a destination pointer and $3 as a byte count.
Write that byte to whatever $2 points at.

=cut

op m0_copy_byte(invar PMC, in INT, in INT, in INT) {
    char  byte    = (char)$3;
    char *mem_dst = (char*)VTABLE_get_pointer_keyed_int(interp, $1, $2);
    *mem_dst      = byte;
}

=item B<m0_set>

Copy the value in $3 to the value in $2.

=cut

op m0_set(invar PMC, in INT, in INT, in INT) {
    FLOATVAL f = VTABLE_get_number_keyed_int(interp, $1, $3);
    VTABLE_set_number_keyed_int(interp, $1, $2, f);
}
=head2 Temporary ops

=item C<m0_alloc>

Assume that register $3 contains a positive int value.  Allocate that many
bytes and store the pointer in register $2.  $4 is ignored.

=cut

op m0_alloc(invar PMC, in INT, in INT, in INT) {
    INTVAL  data_size;
    void   *data;
    M0_ASSERT_REGS($2, $3, $4);
    data_size = VTABLE_get_integer_keyed_int(interp, $1, $3);
    data      = mem_sys_allocate(data_size);
    VTABLE_set_pointer_keyed_int(interp, $1, $2, data);
}

=item C<m0_free>

Assume that $2 contains a pointer to an allocated region of memory.  Free it.

=cut

op m0_free(invar PMC, in INT, in INT, in INT) {
    void *data;

    M0_ASSERT_REGS($2, $3, $4);
    data = VTABLE_get_pointer_keyed_int(interp, $1, $2);
    mem_sys_free(data);
}

=item B<m0_print_i>

Print the value in register $2 as if it were an INTVAL.

=cut

op m0_print_i(invar PMC, in INT, in INT, in INT) {
    M0_ASSERT_REGS($2, $3, $4);
    Parrot_printf(interp, "%d", VTABLE_get_integer_keyed_int(interp, $1, $2));
}

=item B<m0_print_n>

Print the value in register $2 as if it were a FLOATVAL.

=cut

op m0_print_n(invar PMC, in INT, in INT, in INT) {
    M0_ASSERT_REGS($2, $3, $4);
    Parrot_printf(interp, "%g", VTABLE_get_number_keyed_int(interp, $1, $2));
}

=item B<m0_print_s>

Print the value in register $2 as if it were a char*.

=cut

op m0_print_s(invar PMC, in INT, in INT, in INT) {
    M0_ASSERT_REGS($2, $3, $4);
    Parrot_printf(interp, "%s", (char*)VTABLE_get_pointer_keyed_int(interp, $1, $2));
}



/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4 cinoptions='\:2=2' :
 */
