/*
Copyright (C) 2007-2010, Parrot Foundation.

=head1 NAME

src/pmc/codestring.pmc - CodeString PMC Class

=head1 DESCRIPTION

C<CodeString> is a class intended to simplify the process of emitting code
strings.  Ideally this will eventually become a form of "CodeBuffer" that is
more efficient than string concatenation, but for now it works well enough for
me.

The primary method for C<CodeString> objects is C<emit>, which appends a line
(or lines) of code to the string according to a format parameter.  The line can
contain substitution markers (ala printf) that indicate where other parameters
to the call should be placed.

Note that C<CodeString> is just a subclass of Parrot's native C<String> class,
so it's easy to combine CodeString objects with other strings outside of the
C<emit> method.

=head2 Methods

=over 4

=cut

*/

#if PARROT_HAS_ICU
#  include <unicode/uchar.h>
#endif

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* HEADERIZER END: static */

pmclass CodeString extends String provides string auto_attrs {
    ATTR PMC *linepos;            /* start of line positions */

/*

=item C<init()>

Initialize the CodeString.

=cut

*/

    VTABLE void init() {
        SUPER();
        SET_ATTR_linepos(INTERP, SELF, PMCNULL);
        PObj_custom_mark_SET(SELF);
    }

/*

=item C<mark()>

Mark the CodeString as live.

=cut

*/

    VTABLE void mark() {
        SUPER();
        if (PMC_data(SELF)) {
            PMC *linepos;

            GET_ATTR_linepos(INTERP, SELF, linepos);

            Parrot_gc_mark_PMC_alive(INTERP, linepos);
        }
    }

/*

=item C<emit(string fmt [, pmc args ] [, pmc hash ])>

Add a line to a C<CodeString> object according to C<fmt>.
The C<fmt> string can contain any number of "%-replacements"
which are replaced by the corresponding values from C<args>
or C<hash> prior to being appended to the string.  (Here
C<args> is a slurpy array, and C<hash> is a slurpy hash.)

The currently defined replacements include:

    %0 %1 ... %9     the value from the args array at index 0..9
    %,               the values of the args array separated by commas
    %%               a percent sign

A percent-sign followed by any other character that is a hash
key receives the value of the hash element.

A newline is automatically added to the end of the fmt.

=cut

*/

  METHOD emit(STRING *fmt, PMC *args :slurpy, PMC *hash :slurpy :named) {
    STRING * const percent     = CONST_STRING(INTERP, "%");
    STRING * const comma       = CONST_STRING(INTERP, ",");
    STRING * const comma_space = CONST_STRING(INTERP, ", ");
    STRING * const newline     = CONST_STRING(INTERP, "\n");
    PMC           *parts       = PMCNULL;
    STRING *key, *repl, *S1;
    INTVAL pos          = 0;
    INTVAL replen       = 0;

    while (pos >= 0) {
        pos += replen;
        pos = STRING_index(INTERP, fmt, percent, pos);
        if (pos < 0)
            break;

        key = STRING_substr(INTERP, fmt, pos+1, 1);

        if (VTABLE_exists_keyed_str(INTERP, hash, key)) {
            repl = VTABLE_get_string_keyed_str(INTERP, hash, key);
        }
        else if (Parrot_str_is_cclass(INTERP, enum_cclass_numeric, fmt, (UINTVAL)pos + 1)) {
            const INTVAL I0 = Parrot_str_to_int(INTERP, key);
            repl = VTABLE_get_string_keyed_int(INTERP, args, I0);
        }
        else if (STRING_equal(INTERP, key, comma)) {
            repl = Parrot_str_join(INTERP, comma_space, args);
        }
        else if (STRING_equal(INTERP, key, percent)) {
            repl = percent;
        }
        else {
            /* No substitution is necessary */
            replen = 2;
            continue;
        }

        fmt    = Parrot_str_replace(INTERP, fmt, pos, 2, repl);
        replen = Parrot_str_length(INTERP, repl);
    }

    GET_ATTR_str_val(INTERP, SELF, S1);

    parts = Parrot_pmc_new_init_int(INTERP, enum_class_FixedStringArray, 3);
    VTABLE_set_string_keyed_int(INTERP, parts, 0, S1);
    VTABLE_set_string_keyed_int(INTERP, parts, 1, fmt);

    /* Add a newline if necessary */
    if (STRING_length(fmt) > 0
    &&  '\n' != STRING_ord(INTERP, fmt, -1))
        VTABLE_set_string_keyed_int(INTERP, parts, 2, newline);

    S1 = Parrot_str_join(INTERP, STRINGNULL, parts);
    VTABLE_set_string_native(INTERP, SELF, S1);

    RETURN(PMC *SELF);
  }


/*

=back

=cut

*/

}


/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
