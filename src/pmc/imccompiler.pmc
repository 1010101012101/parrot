
#include "../compilers/imcc/imc.h"

pmclass IMCCompiler auto_attrs provides HLLCompiler {
    ATTR void *imcc_info;
    ATTR INTVAL is_pasm; /* 0 = PIR, 1 = PASM */

    VTABLE void init() {
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
            "IMCCompiler: Must initialize with an integer argument 0 (PIR) or 1 (PASM)");
    }

    VTABLE void init_pmc(PMC *init) {
        const INTVAL type = VTABLE_get_integer(INTERP, init);
        VTABLE_init_int(INTERP, SELF, type);
    }

    VTABLE void init_int(INTVAL is_pasm) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        if (is_pasm != 0 && is_pasm != 1)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "IMCCompiler: Must have type 0 (PIR) or 1 (PASM)");
        attrs->is_pasm = is_pasm;
        attrs->imcc_info = imcc_new(INTERP);
    }

    /* provided to emulate the current NCI compreg */
    VTABLE void* invoke(void* next) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        PMC * const ctx = CURRENT_CONTEXT(INTERP);
        PMC * const call_object = Parrot_pcc_get_signature(interp, ctx);
        PackFile_ByteCode * const cur_code = interp->code;
        STRING * code = STRINGNULL;
        PMC * result = PMCNULL;
        Parrot_pcc_fill_params_from_c_args(interp, call_object, "S", &code);
        imcc_reset(attrs->imcc_info);
        result = imcc_compile_string(attrs->imcc_info, code, attrs->is_pasm);
        Parrot_pcc_build_call_from_c_args(interp, call_object, "P", result);
        interp->code = cur_code;
        return next;
    }

    VTABLE void *get_pointer() {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        return attrs->imcc_info;
    }

    VTABLE INTVAL get_integer() {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        return attrs->is_pasm;
    }

    VTABLE void destroy() {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        imcc_destroy(attrs->imcc_info);
        attrs->imcc_info = NULL;
    }

    METHOD compile(STRING *source,
            STRING *target :named("target") :optional, INTVAL has_target :opt_flag,
            PMC *outer_ctx :named("outer_ctx") :optional, INTVAL has_ctx :opt_flag
    ) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        PMC * pf = PMCNULL;
        if (has_target)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "IMCCompiler: compiler does not support the target option");
        /* TODO: Handle outer_ctx */
        pf = imcc_compile_string(attrs->imcc_info, source, attrs->is_pasm);
        imcc_reset(attrs->imcc_info);
        RETURN(PMC *pf);
    }

    METHOD compile_file(STRING *filename,
            STRING *target :named("target") :optional, INTVAL has_target :opt_flag,
            PMC *outer_ctx :named("outer_ctx") :optional, INTVAL has_ctx :opt_flag
    ) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        PMC * pf = PMCNULL;
        if (has_target)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "IMCCompiler: compiler does not support the target option");
        /* TODO: Handle outer_ctx */
        pf = imcc_compile_file(attrs->imcc_info, filename, attrs->is_pasm);
        RETURN(PMC *pf);
    }

    METHOD eval(STRING *source,
            STRING *target :named("target") :optional, INTVAL has_target :opt_flag,
            PMC *outer_ctx :named("outer_ctx") :optional, INTVAL has_ctx :opt_flag
    ) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        PMC * pf = PMCNULL;
        if (has_target)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "IMCCompiler: compiler does not support the target option");
        /* TODO: Handle outer_ctx */
        pf = imcc_compile_string(attrs->imcc_info, source, attrs->is_pasm);
        /* TODO: Execute it */
    }

    METHOD preprocess(STRING *code) {
        Parrot_IMCCompiler_attributes * const attrs = PARROT_IMCCOMPILER(SELF);
        imcc_preprocess(attrs->imcc_info, code);
    }

    METHOD parse_name(STRING *name) {
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_UNIMPLEMENTED,
                "IMCCompiler: parse_name is not supported");
    }

    METHOD load_module(STRING *name) {
        /* TODO: This */
    }

    METHOD get_module(STRING *name) {
        /* TODO: This */
    }

    METHOD get_exports(PMC *module) {
        /* TODO: This */
    }
}
