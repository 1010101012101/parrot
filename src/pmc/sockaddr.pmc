/*
Copyright (C) 2008-2011, Parrot Foundation.

=head1 NAME

src/pmc/sockaddr.pmc - sockaddr_in/sockaddr_in6 holder

=head1 DESCRIPTION

The Sockaddr PMC holds a C<sockaddr_in> (IPv4) or C<sockaddr_in6> (IPv6) and
saves its length (to distinguish C<sockaddr_in> and C<sockaddr_in6>).


=head2 Vtable Functions

These are the vtable functions for the Sockaddr class.

=over 4

=cut

*/

#ifdef __cplusplus
extern "C" {
#endif
    struct sockaddr_storage;
#ifdef __cplusplus
}
#endif

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* HEADERIZER END: static */

pmclass Sockaddr auto_attrs {
    ATTR void   *pointer; /* The stored pointer. */
    ATTR INTVAL len; /* Length of the contents of the sockaddr_storage */

/*

=item C<void init()>

Initializes the PMC by allocating a C<sockaddr_storage>.

=cut

*/

    VTABLE void init() {
        Parrot_Sockaddr_attributes * const pdata_struct =
            (Parrot_Sockaddr_attributes *) PMC_data(SELF);

        pdata_struct->pointer = mem_gc_allocate_zeroed_typed(INTERP,
                struct sockaddr_storage);
        PObj_custom_destroy_SET(SELF);
    }

/*

=item C<void destroy()>

Destroys the PMC and frees all allocated memory.

=cut

*/

    VTABLE void destroy() {
        Parrot_Sockaddr_attributes * const data = PARROT_SOCKADDR(SELF);

        if (data) {
            mem_gc_free(INTERP, data->pointer);
            data->pointer = NULL;
        }
    }

/*

=item C<PMC *clone()>

Creates a new Sockaddr PMC with the same contents and length as the current
one.

=cut

*/

    VTABLE PMC *clone() {
        PMC * const dest = Parrot_pmc_new(INTERP, SELF->vtable->base_type);

        memcpy(PARROT_SOCKADDR(dest)->pointer, PARROT_SOCKADDR(SELF)->pointer,
                sizeof (struct sockaddr_storage));
        PARROT_SOCKADDR(dest)->len = PARROT_SOCKADDR(SELF)->len;
        return dest;
    }

/*

=item C<INTVAL get_bool()>

Returns true if the Sockaddr is defined.

=cut

*/

    VTABLE INTVAL get_bool() {
        Parrot_Sockaddr_attributes * const data = PARROT_SOCKADDR(SELF);

        return data->pointer ? 1 : 0 ;
    }

/*

=item C<void *get_pointer()>

Returns a pointer to the C<sockaddr_in> or C<sockaddr_in6>.

=cut

*/

    VTABLE void *get_pointer() {
        Parrot_Sockaddr_attributes * const data = PARROT_SOCKADDR(SELF);
        return data->pointer;
    }

/*

=item C<STRING *get_string()>

Returns the string representation of this sockaddr by calling C<getnameinfo(3)>.

=cut

*/
    VTABLE STRING *get_string() {
        Parrot_Sockaddr_attributes * const data = PARROT_SOCKADDR(SELF);
        /* TODO: get hostname, not only numeric */
        char buf[INET6_ADDRSTRLEN+1];
        /* numeric port maximum is 65535, so 5 chars */
        char portbuf[6];

        if (!data->pointer)
            return Parrot_sprintf_c(interp, "(?)");

        getnameinfo((struct sockaddr *)data->pointer, data->len, buf,
                sizeof (buf), portbuf, sizeof (portbuf), NI_NUMERICHOST | NI_NUMERICSERV);
        return Parrot_str_format_data(interp, "%s:%s", buf, portbuf);
    }


/*

=item C<void set_pointer(void *)>

Copies a C<sockaddr_in> or C<sockaddr_in6> from the given C<addrinfo> pointer
(by accessing its C<ai_addr> and C<ai_addrlen> members).

=cut

*/

    VTABLE void set_pointer(void *value) {
        Parrot_Sockaddr_attributes * const data = PARROT_SOCKADDR(SELF);

        struct addrinfo *walk = (struct addrinfo *)value;
        memcpy(data->pointer, walk->ai_addr, walk->ai_addrlen);
        data->len = walk->ai_addrlen;
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4 cinoptions='\:2=2' :
 */

