/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* HEADERIZER END: static */

pmclass IOBuffer auto_attrs {
    ATTR IO_BUFFER * buffer;

    VTABLE void init() {
        Parrot_IOBuffer_attributes * const attrs = PARROT_IOBUFFER(SELF);
        attrs->buffer = NULL;
        PObj_custom_mark_SET(SELF);
        PObj_custom_destroy_SET(SELF);
    }

    VTABLE void init_int(INTVAL buffer_size) {
        VTABLE_init(INTERP, SELF);
        VTABLE_set_integer_native(INTERP, SELF, buffer_size);
    }

    VTABLE void set_integer_native(INTVAL buffer_size) {
        Parrot_IOBuffer_attributes * const attrs = PARROT_IOBUFFER(SELF);

        PARROT_ASSERT(buffer_size > 0);
        if (attrs->buffer)
            Parrot_io_buffer_resize(INTERP, attrs->buffer, buffer_size);
        else
            attrs->buffer = Parrot_io_buffer_allocate(INTERP, 0,
                              Parrot_platform_encoding_ptr, (size_t)buffer_size);
    }

    VTABLE void mark() {
        Parrot_io_buffer_mark(INTERP, PARROT_IOBUFFER(SELF)->buffer);
    }

    VTABLE void destroy() {
        /* TODO: Decrease reference count, only free it if the refcount is
           zero */
        Parrot_io_buffer_free(INTERP, PARROT_IOBUFFER(SELF)->buffer);
        PARROT_IOBUFFER(SELF)->buffer = NULL;
    }

    VTABLE void* get_pointer() {
        return PARROT_IOBUFFER(SELF)->buffer;
    }

    VTABLE void set_pointer(void * ptr) {
        PARROT_IOBUFFER(SELF)->buffer = (IO_BUFFER*)ptr;
    }
}
