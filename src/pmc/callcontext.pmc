/*
Copyright (C) 2008-2011, Parrot Foundation.

=head1 NAME

src/pmc/callcontext.pmc - CallContext PMC

=head1 DESCRIPTION

The CallContext PMC is used to store the argument list and argument meta
information for a call from C.

=head2 Functions

=over 4

=cut

*/

BEGIN_PMC_HEADER_PREAMBLE

/* FSM for parameters processing */
typedef enum param_processing_state {
    param_positional,
    param_dissect_array,
    param_named,
    param_dissect_hash,
    param_finished
} param_processing_state;

/* Structure used to return next param */
typedef struct call_context_param {
    union v {
        PMC     *p;
        STRING  *s;
        INTVAL   i;
        FLOATVAL n;
    } v;
    INTVAL  type;       /* -1 mean empty ret */
    STRING *name;       /* Optional name of parameter */
} call_context_param;

END_PMC_HEADER_PREAMBLE

#include "pmc/pmc_fixedintegerarray.h"

typedef struct Pcc_cell
{
    union u {
        PMC     *p;
        STRING  *s;
        INTVAL   i;
        FLOATVAL n;
    } u;
    INTVAL type;
} Pcc_cell;

#define NOCELL     0
#define INTCELL    1
#define FLOATCELL  2
#define STRINGCELL 3
#define PMCCELL    4

#define ALLOC_CELL(i) \
    (Pcc_cell *)Parrot_gc_allocate_fixed_size_storage((i), sizeof (Pcc_cell))

#define FREE_CELL(i, c) \
    Parrot_gc_free_fixed_size_storage((i), sizeof (Pcc_cell), (c))

#define CLONE_CELL(i, c, c_new) do { \
    (c_new)  = ALLOC_CELL(i); \
    *(c_new) = *(c); \
} while (0)

#define CELL_TYPE_MASK(c) (c)->type

#define CELL_INT(c)     (c)->u.i
#define CELL_FLOAT(c)   (c)->u.n
#define CELL_STRING(c)  (c)->u.s
#define CELL_PMC(c)     (c)->u.p

#define HLL_TYPE(i) Parrot_hll_get_ctx_HLL_type(interp, (i))

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */

static FLOATVAL ccp2num(PARROT_INTERP, ARGIN(call_context_param *p))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

static PMC* ccp2pmc(PARROT_INTERP, ARGIN(call_context_param *p))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

static STRING* ccp2str(PARROT_INTERP, ARGIN(call_context_param *p))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

static void extract_named_arg_from_op(PARROT_INTERP,
    ARGMOD(call_context_param *param),
    ARGIN(PMC *ctx),
    ARGIN(INTVAL *raw_sig),
    INTVAL arg_index,
    ARGIN(opcode_t *raw_args))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2)
        __attribute__nonnull__(3)
        __attribute__nonnull__(4)
        __attribute__nonnull__(6)
        FUNC_MODIFIES(*param);

static int fetch_and_advance(PARROT_INTERP,
    ARGIN(PMC *self),
    ARGIN(call_context_param *ret))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2)
        __attribute__nonnull__(3);

#define ASSERT_ARGS_ccp2num __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(p))
#define ASSERT_ARGS_ccp2pmc __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(p))
#define ASSERT_ARGS_ccp2str __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(p))
#define ASSERT_ARGS_extract_named_arg_from_op __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(param) \
    , PARROT_ASSERT_ARG(ctx) \
    , PARROT_ASSERT_ARG(raw_sig) \
    , PARROT_ASSERT_ARG(raw_args))
#define ASSERT_ARGS_fetch_and_advance __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(self) \
    , PARROT_ASSERT_ARG(ret))
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */
/* HEADERIZER END: static */

/*

=item fetch_and_advance

All logic of handling parameters unpacking sitting in here.

Fill passed call_context_param with data.

Caller has to to autoboxing.

=cut

*/

static int
fetch_and_advance(PARROT_INTERP, ARGIN(PMC *self), ARGIN(call_context_param *ret))
{
    Parrot_CallContext_attributes *attrs = (Parrot_CallContext_attributes*)PMC_data(self);
    INTVAL    current_arg;
    param_processing_state state;
    INTVAL    arg_flags;
    opcode_t *raw_args;
    INTVAL    raw_index;
    PMC      *ctx;
    INTVAL   *args_flags;
    INTVAL    args_flags_size;

    int       is_constant;
    int       do_restart = 0;

    ret->type = -1; /* Empty for now */
    ret->name = NULL;

    state = attrs->state; //GETATTR_CallContext_state(interp, self, state);

    if (state == param_finished)
        return 0;

    current_arg = attrs->current_arg; //GETATTR_CallContext_current_arg(interp, self, current_arg);
    ctx         = attrs->from_context; //GETATTR_CallContext_from_context(interp, self, ctx);
    raw_args    = attrs->raw_args; //GETATTR_CallContext_raw_args(interp, self, raw_args);
    args_flags  = attrs->args_flags; //GETATTR_CallContext_args_flags(interp, self, args_flags);
    args_flags_size = attrs->args_flags_size; //GETATTR_CallContext_args_flags_size(interp, self, args_flags_size);

restart:
    /* Get flags for current param */
    raw_index = (INTVAL)*raw_args;
    arg_flags = args_flags[current_arg];
    is_constant = 0 != PARROT_ARG_CONSTANT_ISSET(arg_flags);
    do_restart = 0;

    /* Huge hand-crafted FSM to unpack arguments */
    switch (state) {
      case param_positional:
        switch (PARROT_ARG_TYPE_MASK_MASK(arg_flags)) {
          case PARROT_ARG_INTVAL:
            ret->type   = PARROT_ARG_INTVAL;
            ret->v.i    = is_constant
                ? raw_index
                : CTX_REG_INT(interp, ctx, raw_index);
            /* Keep state */
            raw_args++;
            current_arg++;
            break;

          case PARROT_ARG_FLOATVAL:
            ret->type   = PARROT_ARG_FLOATVAL;
            ret->v.n    = is_constant
                ? Parrot_pcc_get_num_constant(interp, ctx, raw_index)
                : CTX_REG_NUM(interp, ctx, raw_index);
            /* Keep state */
            raw_args++;
            current_arg++;
            break;

          case PARROT_ARG_STRING:
            {
                STRING * const string_value = is_constant
                    ? Parrot_pcc_get_string_constant(interp, ctx, raw_index)
                    : CTX_REG_STR(interp, ctx, raw_index);

                if (arg_flags & PARROT_ARG_NAME) {
                    /* Switch to handle named parameters. */
                    state = param_named;
                    attrs->state = state; //SETATTR_CallContext_state(interp, self, state);
                    do_restart = 1;
                }
                else {
                    /* Just plain old string */
                    ret->type   = PARROT_ARG_STRING;
                    ret->v.s    = string_value;
                    raw_args++;
                    current_arg++;
                }

                break;
            }
            break;

          case PARROT_ARG_PMC:
            {
                PMC * const pmc_value = is_constant
                    ? Parrot_pcc_get_pmc_constant(interp, ctx, raw_index)
                    : CTX_REG_PMC(interp, ctx, raw_index);

                if (arg_flags & PARROT_ARG_FLATTEN) {
                    /* Switch to dissecting array */
                    // FIXME We are creating too much GC pressure here...
                    PMC *iter = VTABLE_get_iter(interp, pmc_value);

                    if (VTABLE_get_bool(interp, iter)) {
                        attrs->current_aggregate = pmc_value; //SETATTR_CallContext_current_aggregate(interp, self, pmc_value);
                        attrs->current_iter = iter; //SETATTR_CallContext_current_iter(interp, self, iter);
                        state = arg_flags & PARROT_ARG_NAME
                            ? param_dissect_hash
                            : param_dissect_array;
                        do_restart = 1;
                    }
                    else {
                        /* We have empty aggregate. Skip it */
                        current_arg++;
                        raw_index++;
                        state = current_arg >= args_flags_size
                            ? param_finished
                            : param_positional;
                        do_restart = state != param_finished;
                    }
                    attrs->state = state; //SETATTR_CallContext_state(interp, self, state);
                }
                else {
                    ret->type = PARROT_ARG_PMC;
                    ret->v.p  = pmc_value;
                    raw_args++;
                    current_arg++;
                }

                break;
            }

          default:
            //PARROT_FAILURE("NYI");
            break;
        }
        break;

      case param_dissect_array:
        {
            PMC *iter;
            GETATTR_CallContext_current_iter(interp, self, iter);
            /* FIXME We can optimize useless boxing here */
            ret->type   = PARROT_ARG_PMC;
            ret->v.p    = VTABLE_shift_pmc(interp, iter);

            if (!VTABLE_get_bool(interp, iter)) {
                /* Aggregate is exausted. Switch to next _positional_ arg or stop */
                raw_args++;
                current_arg++;
                state = current_arg >= args_flags_size
                    ? param_finished
                    : param_positional;
                attrs->state = state; //SETATTR_CallContext_state(interp, self, state);
            }
        }

        break;


      case param_named:
        if (!(arg_flags & PARROT_ARG_NAME))
            Parrot_ex_throw_from_c_args(interp, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "named arguments must follow all positional arguments");

        /* We have pair (name, value) in 2 sequential params */
        ret->name = is_constant
            ? Parrot_pcc_get_string_constant(interp, ctx, raw_index)
            : CTX_REG_STR(interp, ctx, raw_index);
        current_arg++;
        raw_args++;

        extract_named_arg_from_op(interp, ret, ctx, args_flags, current_arg, raw_args);
        current_arg++;
        raw_args++;

        break;

      case param_dissect_hash:
        {
            PMC *iter, *hash;
            GETATTR_CallContext_current_aggregate(interp, self, hash);
            GETATTR_CallContext_current_iter(interp, self, iter);
            /* FIXME We can optimize useless boxing here */
            ret->type = PARROT_ARG_PMC;
            ret->name = VTABLE_shift_string(interp, iter);
            ret->v.p  = VTABLE_get_pmc_keyed_str(interp, hash, ret->name);

            if (!VTABLE_get_bool(interp, iter)) {
                /* Aggregate is exausted. Switch to next _positional_ arg or stop */
                raw_args++;
                current_arg++;
                state = current_arg >= args_flags_size
                    ? param_finished
                    : param_positional;
                attrs->state = state; //SETATTR_CallContext_state(interp, self, state);
            }
        }

        break;

      case param_finished:
      default:
        ret = NULL;
        break;
    }
    if (do_restart) goto restart;


    /* Move to next one */
    attrs->current_arg = current_arg; //SETATTR_CallContext_current_arg(interp, self, current_arg);
    attrs->raw_args = raw_args; //SETATTR_CallContext_raw_args(interp, self, raw_args);

    /* Check that we didn't overrun */
    if (current_arg >= args_flags_size) {
        state = param_finished;
        attrs->state = state; //SETATTR_CallContext_state(interp, self, state);
    }

    return ret->type != -1;
}

/*

=item ccp2int

=item ccp2num

=item ccp2str

=item ccp2pmc

Convert call_context_param to expected value.

=cut

*/

static INTVAL
ccp2int(PARROT_INTERP, ARGIN(call_context_param *p)) {
    switch (p->type) {
      case PARROT_ARG_INTVAL:
        return p->v.i;
      case PARROT_ARG_FLOATVAL:
        return (INTVAL)p->v.n;
      case PARROT_ARG_STRING:
        return p->v.s ? Parrot_str_to_int(interp, p->v.s) : 0;
      case PARROT_ARG_PMC:
        return VTABLE_get_integer(interp, p->v.p);
      default:
        return 0;
    }
}

static FLOATVAL
ccp2num(PARROT_INTERP, ARGIN(call_context_param *p)) {
    switch (p->type) {
      case PARROT_ARG_INTVAL:
        return p->v.i;
      case PARROT_ARG_FLOATVAL:
        return p->v.n;
      case PARROT_ARG_STRING:
        return p->v.s ? Parrot_str_to_num(interp, p->v.s) : 0;
      case PARROT_ARG_PMC:
        return VTABLE_get_number(interp, p->v.p);
      default:
        return 0;
    }
}

static STRING*
ccp2str(PARROT_INTERP, ARGIN(call_context_param *p)) {
    switch (p->type) {
      case PARROT_ARG_INTVAL:
        return Parrot_str_from_int(interp, p->v.i);
      case PARROT_ARG_FLOATVAL:
        return Parrot_str_from_num(interp, p->v.n);
      case PARROT_ARG_STRING:
        return p->v.s;
      case PARROT_ARG_PMC:
        return VTABLE_get_string(interp, p->v.p);
      default:
        return STRINGNULL;
    }
}

static PMC*
ccp2pmc(PARROT_INTERP, ARGIN(call_context_param *p)) {
    switch (p->type) {
      case PARROT_ARG_INTVAL:
        return Parrot_pmc_box_integer(interp, p->v.i);
      case PARROT_ARG_FLOATVAL:
        return Parrot_pmc_box_number(interp, p->v.n);
      case PARROT_ARG_STRING:
        return Parrot_pmc_box_string(interp, p->v.s);
      case PARROT_ARG_PMC:
        return p->v.p;
      default:
        return PMCNULL;
    }
}


/*

=item C<static void extract_named_arg_from_op(PARROT_INTERP, call_context_param
*param, PMC *ctx, INTVAL *raw_sig, INTVAL arg_index, opcode_t *raw_args)>

Pulls in the next argument from a set_args opcode, and sets it as the
value of a named argument in the CallContext PMC.

=cut

*/

static void
extract_named_arg_from_op(PARROT_INTERP, ARGMOD(call_context_param *param),
        ARGIN(PMC *ctx), ARGIN(INTVAL *raw_sig), INTVAL arg_index, ARGIN(opcode_t *raw_args))
{
    ASSERT_ARGS(extract_named_arg_from_op)
    const INTVAL arg_flags = raw_sig[arg_index];
    const int is_constant  = 0 != PARROT_ARG_CONSTANT_ISSET(arg_flags);
    const INTVAL raw_index = *raw_args;

    switch (PARROT_ARG_TYPE_MASK_MASK(arg_flags)) {
      case PARROT_ARG_INTVAL:
        param->type = PARROT_ARG_INTVAL;
        param->v.i  = is_constant
                    ? raw_index
                    : CTX_REG_INT(interp, ctx, raw_index);
        break;

      case PARROT_ARG_FLOATVAL:
        param->type = PARROT_ARG_FLOATVAL;
        param->v.n  = is_constant
                ? Parrot_pcc_get_num_constant(interp, ctx, raw_index)
                : CTX_REG_NUM(interp, ctx, raw_index);
        break;

      case PARROT_ARG_STRING:
        param->type = PARROT_ARG_STRING;
        param->v.s  = is_constant
                    ? Parrot_pcc_get_string_constant(interp, ctx, raw_index)
                    : CTX_REG_STR(interp, ctx, raw_index);
        break;

      case PARROT_ARG_PMC:
        param->type = PARROT_ARG_PMC;
        param->v.p  = is_constant
                ? Parrot_pcc_get_pmc_constant(interp, ctx, raw_index)
                : CTX_REG_PMC(interp, ctx, raw_index);
        break;

      default:
        PARROT_FAILURE("Impossible");
        break;
    }
}

#include "parrot/packfile.h"
#include "pmc/pmc_sub.h"
#include "pmc/pmc_fixedintegerarray.h"

pmclass CallContext extends CallContextBase auto_attrs {
    /* "Inlined" FIA to avoid VTABLE calls */
    ATTR INTVAL                 args_flags_size;
    ATTR INTVAL                *args_flags;

    ATTR INTVAL                 current_arg; /* Currently processed arg */
    ATTR param_processing_state state; /* FSM state */
    ATTR opcode_t              *raw_args;

    ATTR PMC                   *from_context;

    ATTR PMC                   *current_iter;
    ATTR PMC                   *current_aggregate;

/*

=item C<void init()>

Initializes a newly created CallContext object.

=cut

*/

    VTABLE void init() {
        SUPER();

        SET_ATTR_state(INTERP, SELF, param_positional);
        SET_ATTR_current_arg(INTERP, SELF, 0);
    }

/*

=item

Set raw signature and start FSM

Args is FIA. We do poke inside it for speed.

=cut
*/
    VTABLE void set_pmc(PMC *pmc) {
        PMC                    *iter, *aggr;
        param_processing_state  state;
        INTVAL                  args_flags_size;
        INTVAL                 *args_flags;

        SET_ATTR_arg_flags(INTERP, SELF, pmc);

        GETATTR_FixedIntegerArray_size(INTERP, pmc, args_flags_size);
        GETATTR_FixedIntegerArray_int_array(INTERP, pmc, args_flags);
        SET_ATTR_args_flags_size(INTERP, SELF, args_flags_size);
        SET_ATTR_args_flags(INTERP, SELF, args_flags);

        if (args_flags_size) {
            /* Look ahead to setup current state properly */
            /* Basically it's transition from (start) state. */
            INTVAL arg_flags = args_flags[0];
            if (arg_flags & PARROT_ARG_NAME)
                if (arg_flags & PARROT_ARG_SLURPY_ARRAY) {
                    state = param_dissect_hash;
                }
                else {
                    state = param_named;
                }
            else {
                if (arg_flags & PARROT_ARG_SLURPY_ARRAY) {
                    /* Dissecting array */
                    state = param_dissect_array;
                }
                else {
                    state = param_positional;
                }
            }

            SET_ATTR_state(INTERP, SELF, state);
            if (state == param_dissect_array || state == param_dissect_hash) {
                opcode_t *raw_args;
                GET_ATTR_raw_args(INTERP, SELF, raw_args);
                /* We can't have constant here */
                aggr = REG_PMC(INTERP, *raw_args);
                SET_ATTR_current_aggregate(INTERP, SELF, aggr);

                iter = VTABLE_get_iter(INTERP, aggr);
                SET_ATTR_current_iter(INTERP, SELF, iter);
                /* It can be empty. Skip it */
                if (!VTABLE_get_bool(INTERP, iter)) {
                    SET_ATTR_state(INTERP, SELF, param_positional);
                    SET_ATTR_raw_args(INTERP, SELF, ++raw_args);
                    SET_ATTR_current_arg(INTERP, SELF, 1);

                    if (args_flags_size == 1) {
                        SET_ATTR_state(INTERP, SELF, param_finished);
                    }
                }
            }
        }
        else {
            /* We have empty signature */
            SET_ATTR_state(INTERP, SELF, param_finished);
        }
    }

/*

=item C<void morph(PMC *type)>

Morph the call signature into a return signature. (Currently ignores
the type passed in, and resets the named and positional arguments
stored.)

=cut

*/
    VTABLE void morph(PMC *type) {
        Parrot_CallContext_attributes *attrs = (Parrot_CallContext_attributes*)PMC_data(SELF);

        attrs->short_sig = NULL; //SET_ATTR_short_sig(INTERP, SELF, NULL);
        attrs->arg_flags = PMCNULL; //SET_ATTR_arg_flags(INTERP, SELF, PMCNULL);
        attrs->return_flags = PMCNULL; //SET_ATTR_return_flags(INTERP, SELF, PMCNULL);
        attrs->type_tuple = PMCNULL; //SET_ATTR_type_tuple(INTERP, SELF, PMCNULL);

        attrs->current_arg = 0; //SET_ATTR_current_arg(INTERP, SELF, 0);
    }


/*

=item C<STRING *get_string()>

Returns the short signature for the CallContext.

=cut

*/

    VTABLE STRING *get_string() {
        STRING   *res;
        Pcc_cell *c;
        INTVAL    num_positionals, i;

        GET_ATTR_short_sig(INTERP, SELF, res);

        if (res)
            return res;

#if 0
        FIXME
        GET_ATTR_positionals(INTERP, SELF, c);
        GET_ATTR_num_positionals(INTERP, SELF, num_positionals);

        res = Parrot_str_new(INTERP, NULL, num_positionals);

        for (i = 0; i < num_positionals; ++i) {
            switch (c[i].type) {
              case INTCELL:
                res = Parrot_str_concat(INTERP, res, CONST_STRING(INTERP, "I"));
                break;
              case FLOATCELL:
                res = Parrot_str_concat(INTERP, res, CONST_STRING(INTERP, "N"));
                break;
              case STRINGCELL:
                res = Parrot_str_concat(INTERP, res, CONST_STRING(INTERP, "S"));
                break;
              case PMCCELL:
                res = Parrot_str_concat(INTERP, res, CONST_STRING(INTERP, "P"));
                break;
              default:
                PARROT_FAILURE("Impossible flag");
                break;
            }
        }
        /* TODO Add named args to signature */
        /* After fixind build_MMD_type_tuple to use raw arguments instead of signature */

        SET_ATTR_short_sig(INTERP, SELF, res);
#endif

        return res;
    }


/*

=item C<PMC *get_pmc()>

Returns a fixed-size array of integer types (a type tuple) for the
CallContext.

=cut

*/

    VTABLE PMC *get_pmc() {
        PMC *type_tuple;

        GET_ATTR_type_tuple(INTERP, SELF, type_tuple);

        if (PMC_IS_NULL(type_tuple)) {
            /* FIXME
            Pcc_cell *c;
            INTVAL    num_positionals;
            INTVAL    i = 0;

            GET_ATTR_positionals(INTERP, SELF, c);
            GET_ATTR_num_positionals(INTERP, SELF, num_positionals);

            type_tuple = Parrot_pmc_new_init_int(INTERP,
                enum_class_FixedIntegerArray, num_positionals);

            for (i = 0; i < num_positionals; ++i) {
                INTVAL type;

                switch (c[i].type) {
                    case INTCELL:    type = -enum_type_INTVAL;   break;
                    case FLOATCELL:  type = -enum_type_FLOATVAL; break;
                    case STRINGCELL: type = -enum_type_STRING;   break;
                    case PMCCELL:
                        type = PMC_IS_NULL(c[i].u.p)
                             ? (INTVAL)-enum_type_PMC
                             : VTABLE_type(INTERP, c[i].u.p);
                        break;
                    default:
                        Parrot_ex_throw_from_c_args(INTERP, NULL,
                            EXCEPTION_INVALID_OPERATION,
                            "Multiple Dispatch: invalid argument type!");
                }

                VTABLE_set_integer_keyed_int(INTERP, type_tuple, i, type);
            }

            SET_ATTR_type_tuple(INTERP, SELF, type_tuple);
            */
        }

        return type_tuple;
    }


/*

=item C<PMC *get_attr_str(STRING *key)>

Get a PMC value for an attribute by string name.

=over

=item results

Retrieves the return signature, an array of PMCs.

=item arg_flags

Retrieves the flags for the call signature arguments, an array of
integers.

=item return_flags

Retrieves the flags for the call signature return arguments, an array of
integers.

=item named

Retrieves the hash of named arguments.

=item caller_ctx

return Caller Context

=item lex_pad

return LexPad

=item outer_ctx

return Outer Context

=item current_sub

return current Sub

=item handlers

return list of ExceptioHandlers

=item current_cont

return current Continuation

=item current_object

return current Object (if in method call)

=item current_namespace

return current Namespace

=back

=cut

*/

    VTABLE PMC *get_attr_str(STRING *key) {
        if (STRING_equal(INTERP, key, CONST_STRING(INTERP, "named")))
            return PMCNULL; /* FIXME */

        return SUPER(key);
    }

    VTABLE INTVAL elements() {
        param_processing_state state = ((Parrot_CallContext_attributes*)PMC_data(SELF))->state;
        //GET_ATTR_state(INTERP, SELF, state);

        return (state == param_positional) || (state == param_dissect_array);
    }

    VTABLE INTVAL get_bool() {
        param_processing_state state;
        GET_ATTR_state(INTERP, SELF, state);
        return (state != param_finished);
    }

    VTABLE void push_integer(INTVAL value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void push_float(FLOATVAL value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void push_string(STRING *value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void push_pmc(PMC *value) {
        PARROT_FAILURE("Wrong!");
    }

    /*
        TODO It's very naive implementation. But we do unshift _once_ only.
        So, for speed sake, allocate _one_ Cell upfront. Or store it independent.
    */

    VTABLE void unshift_pmc(PMC *value) {
        PARROT_FAILURE("EPIC FAIL");
    }

    VTABLE INTVAL shift_integer() :manual_wb {
        call_context_param p;
        if (fetch_and_advance(INTERP, SELF, &p))
            return ccp2int(INTERP, &p);
        return 0;
    }

    VTABLE FLOATVAL shift_float() :manual_wb {
        call_context_param p;
        if (fetch_and_advance(INTERP, SELF, &p))
            return ccp2num(INTERP, &p);
        return 0.0;
    }

    VTABLE STRING * shift_string() :manual_wb {
        call_context_param p;
        if (fetch_and_advance(INTERP, SELF, &p))
            return ccp2str(INTERP, &p);
        return STRINGNULL;
    }

    VTABLE PMC * shift_pmc() :manual_wb {
        call_context_param p;
        if (fetch_and_advance(INTERP, SELF, &p))
            return ccp2pmc(INTERP, &p);
        return PMCNULL;
    }

    VTABLE void set_integer_keyed_int(INTVAL key, INTVAL value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_number_keyed_int(INTVAL key, FLOATVAL value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_string_keyed_int(INTVAL key, STRING *value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_pmc_keyed_int(INTVAL key, PMC *value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_integer_keyed_str(STRING *key, INTVAL value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_number_keyed_str(STRING *key, FLOATVAL value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_string_keyed_str(STRING *key, STRING *value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_pmc_keyed_str(STRING *key, PMC *value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_integer_keyed(PMC *key, INTVAL value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_number_keyed(PMC *key, FLOATVAL value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_string_keyed(PMC *key, STRING *value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE void set_pmc_keyed(PMC *key, PMC *value) {
        PARROT_FAILURE("Wrong!");
    }

    VTABLE INTVAL get_integer_keyed_str(STRING *key) {
        return 0;
    }

    VTABLE FLOATVAL get_number_keyed_str(STRING *key) {
        return 0.0;
    }


    VTABLE STRING * get_string_keyed_str(STRING *key) {
        return STRINGNULL;
    }

    VTABLE PMC * get_pmc_keyed_str(STRING *key) {
        return PMCNULL;
    }

    VTABLE INTVAL get_integer_keyed(PMC *key) {
        return 0;
    }

    VTABLE FLOATVAL get_number_keyed(PMC *key) {
        return 0.0;
    }

    VTABLE STRING * get_string_keyed(PMC *key) {
        return STRINGNULL;
    }

    VTABLE PMC * get_pmc_keyed(PMC *key) {
        return PMCNULL;
    }

    VTABLE INTVAL exists_keyed(PMC *key) {
        return 0;
    }

    VTABLE INTVAL exists_keyed_str(STRING *key) {
        return 0;
    }

    VTABLE INTVAL exists_keyed_int(INTVAL key) {
        return 0;
    }

/*

=item C<PMC *clone()>

Creates and returns a clone of the signature.

=cut

*/
    VTABLE PMC *clone() {
        PMC * const  dest = SUPER();

        /* FIXME */

        return dest;
    }

/*

=back

=cut

*/

} /* end pmclass */

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4 cinoptions='\:2=2' :
 */
