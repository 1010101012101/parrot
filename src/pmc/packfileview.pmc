/*
Copyright (C) 2001-2011, Parrot Foundation.

=head1 NAME

src/pmc/packfileview.pmc - PackfileView PMC

=head1 DESCRIPTION

This class implements a user-accessible wrapper for the PackFile* structure
used internally by Parrot. It is essentially an interface for the user to call
Packfile subsystem API calls, and work with the PackFile* structures output
from utilities which generate them.

=head2 Methods

=over 4

=cut

*/

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */

PARROT_CAN_RETURN_NULL
static PackFile_ConstTable * get_const_table(PARROT_INTERP,
    ARGIN(PMC * self))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

#define ASSERT_ARGS_get_const_table __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(self))
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */
/* HEADERIZER END: static */

PARROT_CAN_RETURN_NULL
static PackFile_ConstTable *
get_const_table(PARROT_INTERP, ARGIN(PMC * self))
{
    Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(self);
    PackFile * const pf = attrs->pf;
    PackFile_ByteCode * bt;
    if (!pf)
        return NULL;
    bt = pf->cur_cs;
    if (!bt)
        return NULL;
    return bt->const_table;
}

pmclass PackfileView auto_attrs {
    ATTR PackFile * pf;

    VTABLE void init() {
        Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(SELF);
        attrs->pf = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
    }

    VTABLE void destroy() {
        Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(SELF);
        if (attrs->pf != NULL)
            Parrot_pf_destroy(INTERP, attrs->pf);
    }

    VTABLE void set_pointer(void * ptr) {
        Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(SELF);
        if (attrs->pf != NULL)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "Cannot overwrite existing pointer in PackfileView");
        attrs->pf = (PackFile*)ptr;
    }

    VTABLE void *get_pointer() {
        Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(SELF);
        return attrs->pf;
    }

    VTABLE INTVAL get_bool() {
        Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(SELF);
        return (attrs->pf != NULL);
    }

    VTABLE void mark() {
        Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(SELF);
        if (attrs->pf != NULL)
            Parrot_pf_mark_packfile(INTERP, attrs->pf);
    }

    VTABLE PMC * get_pmc_keyed_int(INTVAL idx) {
        PackFile_ConstTable * const ct = get_const_table(INTERP, SELF);
        if (!ct)
            return PMCNULL;
        if (idx < 0 || idx >= ct->pmc.const_count) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                "PMC constant index out of bounds");
        }
        return ct->pmc.constants[idx];
    }

    VTABLE STRING * get_string_keyed_int(INTVAL idx) {
        PackFile_ConstTable * const ct = get_const_table(INTERP, SELF);
        if (!ct)
            return STRINGNULL;
        if (idx < 0 || idx >= ct->str.const_count) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                "STRING constant index out of bounds");
        }
        return ct->str.constants[idx];
    }

    VTABLE FLOATVAL get_number_keyed_int(INTVAL idx) {
        PackFile_ConstTable * const ct = get_const_table(INTERP, SELF);
        if (!ct)
            return 0.0;
        if (idx < 0 || idx >= ct->num.const_count) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_OUT_OF_BOUNDS,
                "PMC constant index out of bounds");
        }
        return ct->num.constants[idx];
    }

    METHOD main_sub() {
        Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(SELF);
        if (attrs->pf == NULL)
            RETURN (PMC *PMCNULL);
        else {
            PMC * const main_sub = Parrot_pf_get_packfile_main_sub(INTERP, SELF);
            RETURN (PMC *main_sub);
        }
    }

    METHOD trigger(STRING * flag) {
        if (STRING_equal(interp, flag, CONST_STRING(interp, "load")))
            Parrot_pf_prepare_packfile_load(INTERP, SELF);
        else if (STRING_equal(interp, flag, CONST_STRING(interp, "init")))
            Parrot_pf_prepare_packfile_init(INTERP, SELF);
        else
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                    "%S is not a valid packfile trigger", flag);
    }

    METHOD serialized_size() {
        Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(SELF);
        if (attrs->pf == NULL)
            RETURN (INTVAL 0);
        const INTVAL size = Parrot_pf_serialized_size(INTERP, attrs->pf);
        RETURN (INTVAL size);
    }

    METHOD serialize() {
        Parrot_PackfileView_attributes * const attrs =
                PARROT_PACKFILEVIEW(SELF);
        if (attrs->pf == NULL)
            RETURN (STRING *STRINGNULL);
        STRING * const str = Parrot_pf_serialize(INTERP, attrs->pf);
        RETURN (STRING *str);
    }

    METHOD all_subs() {
        PMC * const array = Parrot_pmc_new(INTERP, enum_class_ResizablePMCArray);
        PackFile_ConstTable * const ct = get_const_table(INTERP, SELF);
        if (ct) {
            INTVAL i;
            STRING * const SUB = CONST_STRING(interp, "Sub");
            for (i = 0; i < ct->pmc.const_count; ++i) {
                PMC * const x = ct->pmc.constants[i];
                if (VTABLE_isa(interp, x, SUB))
                    VTABLE_push_pmc(INTERP, array, x);
            }
        }
        RETURN (PMC *array);
    }

    METHOD read_from_file(STRING * filename) {
        PackFile * const pf = Parrot_pf_read_pbc_file(INTERP, filename);
        VTABLE_set_pointer(INTERP, SELF, pf);
    }

    METHOD write_to_file(STRING *filename) {
        Parrot_pf_write_pbc_file(INTERP, SELF, filename);
    }

    METHOD deserialize(STRING *pbc) {
        PackFile * const pf = Parrot_pf_deserialize(INTERP, pbc);
        VTABLE_set_pointer(INTERP, SELF, pf);
    }
}
