/*
Copyright (C) 2001-2014, Parrot Foundation.

=head1 NAME

src/pmc/resizablepmcarray.pmc - ResizablePMCArray PMC

=head1 DESCRIPTION

This class, ResizablePMCArray, implements an resizable array which stores
PMCs.  It changes values into Integer, Float, or String PMCs as appropriate.

Resize thresholds steps are 8 and 4096.
Between a 8b - 4K resize it overallocates by 2, over 4K it aligns up to
the next 4K block.

Without USE_OFFSET it uses naive O(n) shift/unshift ops, moving the whole
array around.

With USE_OFFSET we use the faster nqp/qrpa model with O(1) shift/unshift
ops, by moving an extra offset attr, with 8 slots reserve. See #1152

=head2 Internal Functions

=over 4

=cut

*/

#define PMC_size(x)      ((Parrot_ResizablePMCArray_attributes *)PMC_data(x))->size
#define PMC_array(x)     ((Parrot_ResizablePMCArray_attributes *)PMC_data(x))->pmc_array
#define PMC_offset(x)    ((Parrot_ResizablePMCArray_attributes *)PMC_data(x))->offset
#define PMC_threshold(x) ((Parrot_ResizablePMCArray_attributes *)PMC_data(x))->threshold

#define USE_OFFSET 1

#ifdef NDEBUG
#  define TRACE_RPA(s)
#  define TRACE_RPAn(s)
#  define TRACE_RPAs(s)
#  define TRACE_RPAd(s)
#  define TRACE_PMC(i, pmc)
#else
#  define TRACE_RPA(s)                                  \
    if (Interp_trace_TEST(interp, 0x20))                \
        fprintf(stderr, "# rpa %-12s: (%ld,%ld,%ld) ",  \
                (s), offset, size, threshold);
#  define TRACE_RPAn(s)                                 \
    if (Interp_trace_TEST(interp, 0x20))                \
        fprintf(stderr, "# rpa %-12s: (%ld,%ld,%ld)\n", \
                (s), offset, size, threshold);
#  define TRACE_RPAs(s)                                 \
    if (Interp_trace_TEST(interp, 0x20))                \
        fprintf(stderr, "# rpa %-12s: (%ld,%ld,%ld) -> size=%ld\n", \
                    (s), offset, size, threshold, n);
#  define TRACE_RPAd(s, self)                           \
    if (Interp_trace_TEST(interp, 0x20))                \
        fprintf(stderr, "# rpa %-12s: (%ld,%ld,%ld) ",  \
        (s), PMC_offset(self), PMC_size(self), PMC_threshold(self));
#  define TRACE_PMC(i, pmc)                 \
    if (Interp_trace_TEST(interp, 0x20)) {  \
        fprintf(stderr, " rpa[%ld]=", (i)); \
        trace_pmc_dump(interp, (pmc));      \
        fprintf(stderr, "\n");              \
    }

#endif


/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */

PARROT_INLINE
static void do_shift(PARROT_INTERP, ARGIN(PMC *arr))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

PARROT_INLINE
static void do_unshift(PARROT_INTERP, ARGIN(PMC *arr), ARGIN(PMC *val))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2)
        __attribute__nonnull__(3);

PARROT_DOES_NOT_RETURN
PARROT_INLINE
static void throw_pop_empty(PARROT_INTERP)
        __attribute__nonnull__(1);

PARROT_DOES_NOT_RETURN
PARROT_INLINE
static void throw_shift_empty(PARROT_INTERP)
        __attribute__nonnull__(1);

#define ASSERT_ARGS_do_shift __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(arr))
#define ASSERT_ARGS_do_unshift __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(arr) \
    , PARROT_ASSERT_ARG(val))
#define ASSERT_ARGS_throw_pop_empty __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp))
#define ASSERT_ARGS_throw_shift_empty __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp))
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */
/* HEADERIZER END: static */

/*

=item C<static void do_shift(PARROT_INTERP, PMC *arr)>

Removes and returns an item from the start of the array.

=cut

*/
PARROT_INLINE
static void
do_shift(PARROT_INTERP, ARGIN(PMC *arr))
{
    ASSERT_ARGS(do_shift)
    PMC ** const array = PMC_array(arr);
    INTVAL offset = PMC_offset(arr);
#ifndef NDEBUG /* only for TRACE */
    const INTVAL threshold = PMC_threshold(arr);
    INTVAL  size  = PMC_size(arr) - 1;
#else
    INTVAL  size;
    UNUSED(INTERP)
#endif

    PMC_size(arr)--;
#if USE_OFFSET
    PMC_offset(arr)++;
    TRACE_RPAn("shift fast");
    array[offset] = PMCNULL;
#else
    size = PMC_size(arr);
    array += offset;
    TRACE_RPAn("shift slow");
    memmove(array, array + 1, size * sizeof (PMC *));
    array[size] = PMCNULL;
    PARROT_GC_WRITE_BARRIER(interp, arr);
#endif
}

/*

=item C<static void do_unshift(PARROT_INTERP, PMC *arr, PMC *val)>

Adds an item at the start of the array.
If offset == 0 moves the whole rest of the array around.

=cut

*/
PARROT_INLINE
static void
do_unshift(PARROT_INTERP, ARGIN(PMC *arr), ARGIN(PMC *val))
{
    ASSERT_ARGS(do_unshift)
#ifndef NDEBUG
    const INTVAL threshold = PMC_threshold(arr);
#endif
    const INTVAL size = PMC_size(arr);
    INTVAL     offset = PMC_offset(arr);

    if (offset > 0) {
        TRACE_RPA("unshift fast");
        offset--;
        PMC_size(arr)++;
        PMC_offset(arr) = offset;
        PMC_array(arr)[offset] = val;
        TRACE_PMC(offset, val);
    }
    else {
        PMC  **array;
        TRACE_RPA("unshift slow");
        TRACE_PMC(offset, val);
        /* TODO: check which size and offset is convenient here. depends on alignment.
           we want to add at least offset = 3, anticipating more unshift ops */
        VTABLE_set_integer_native(interp, arr, size + 1);
        array = PMC_array(arr);
        memmove(array + 1, array, size * sizeof (PMC *));
        array[0] = val;
        PARROT_GC_WRITE_BARRIER(interp, arr);
    }
}
/*

=back

=head1 Vtable Functions

=over

=cut

*/

pmclass ResizablePMCArray extends FixedPMCArray auto_attrs provides array {
    /* inheriting: size, array */
    ATTR INTVAL offset;    /* of first index, to leave max 8 slots in front for unshift */
    ATTR INTVAL threshold; /* allocated number of elements, max size before array needs resizing */

/*

=item C<void init_int(INTVAL size)>

Initializes the array.

=cut

*/

    VTABLE void init_int(INTVAL n) :manual_wb {
        if (n < 0)
            Parrot_ex_throw_from_c_noargs(INTERP, EXCEPTION_OUT_OF_BOUNDS,
                    "illegal argument");
        SUPER(n);
        PMC_offset(SELF) = 0;
        if (n > 0) {
            PMC_threshold(SELF) = n;
            PARROT_GC_WRITE_BARRIER(INTERP, SELF);
        }
    }

/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    VTABLE void set_integer_native(INTVAL n) :manual_wb {
        INTVAL   size      = PMC_size(SELF);
        INTVAL   offset    = PMC_offset(SELF);
        INTVAL   threshold = PMC_threshold(SELF); /* i.e. allocated size */
        PMC    **array     = PMC_array(SELF);

        if (n < 0)
            Parrot_ex_throw_from_c_noargs(INTERP, EXCEPTION_OUT_OF_BOUNDS,
                    "illegal argument");
        if (!array) {
            /* empty - used fixed routine */
            PMC_offset(SELF) = 0;
            if (n < 8) {
                SUPER(8);
                PMC_size(SELF)      = n;
                PMC_threshold(SELF) = 8;
            }
            else {
                SUPER(n);
                PMC_threshold(SELF) = n;
            }
            TRACE_RPAs("resize init");
        }
        else if (n == size) {
            return;
        }
        else if (n <= threshold - offset) {
            TRACE_RPAs("resize skip");
            PMC_size(SELF) = n;
            /* we could shrink here, but this would need a GC mark */
            return;
        }
        else if (offset > 0 && n + offset > size && n <= threshold) {
            /* if there aren't enough slots at the end, shift off empty
             * slots from the beginning first */
            if (size > 0) {
                size_t i;
                TRACE_RPAs("resize off move");
                memmove(array, array + offset, size * sizeof (PMC *));
                for (i=0; i < offset; ++i) { /* fill the slack */
                    array[i+size] = PMCNULL; /* TODO: memset NULL */
                }
            }
#ifndef NDEBUG
            else {
                TRACE_RPAs("resize off empty");
            }
#endif
            PMC_offset(SELF) = 0;
            PObj_custom_mark_destroy_SETALL(SELF);
        }
        else {
            INTVAL old;
            old = threshold;
            if (threshold < 8192) {
                threshold = (n < 2 * threshold) ? (2 * threshold) : n;
                if (threshold < 8) threshold = 8;
            }
            else {
                const INTVAL needed = n - threshold;
                threshold   += needed + 4096;
                threshold   &= ~0xfff;
            }
            array = mem_gc_realloc_n_typed(INTERP,
                        array, threshold, PMC *);
            for (; old < threshold; ++old) { /* fill the slack (or not) */
                array[old] = PMCNULL; /* TODO: memset NULL is more efficient (calloc) */
            }
            PMC_threshold(SELF) = threshold;
            PMC_size(SELF)      = n;
            if (PMC_array(SELF) != array) { /* data moved? */
                PObj_custom_mark_destroy_SETALL(SELF);
                PMC_array(SELF) = array;
                TRACE_RPAs("resize move");
            }
#ifndef NDEBUG
            else {
                TRACE_RPAs("resize fast realloc");
            }
#endif
        }
    }

/*

=item C<FLOATVAL shift_float()>

=item C<INTVAL shift_integer()>

=item C<PMC *shift_pmc()>

=item C<STRING *shift_string()>

Removes and returns an item from the start of the array.

=cut

*/

    VTABLE FLOATVAL shift_float() :manual_wb {
        const INTVAL size   = PMC_size(SELF);
        const INTVAL offset = PMC_offset(SELF);
        FLOATVAL value;

        if (0 == size)
            throw_shift_empty(INTERP);
        value = VTABLE_get_number(INTERP, PMC_array(SELF)[offset]);
        do_shift(INTERP, SELF);
        return value;
    }

    VTABLE INTVAL shift_integer() :manual_wb {
        const INTVAL size   = PMC_size(SELF);
        const INTVAL offset = PMC_offset(SELF);
        INTVAL value;

        if (0 == size)
            throw_shift_empty(INTERP);
        value = VTABLE_get_integer(INTERP, PMC_array(SELF)[offset]);
        do_shift(INTERP, SELF);
        return value;
    }

    VTABLE PMC *shift_pmc() :manual_wb {
        const INTVAL size   = PMC_size(SELF);
        const INTVAL offset = PMC_offset(SELF);
        PMC   *data;

        if (0 == size)
            throw_shift_empty(INTERP);
        data = PMC_array(SELF)[offset];
        do_shift(INTERP, SELF);
        return data;
    }

    VTABLE STRING *shift_string() :manual_wb {
        const INTVAL size   = PMC_size(SELF);
        const INTVAL offset = PMC_offset(SELF);
        STRING  *value;

        if (0 == size)
            throw_shift_empty(INTERP);
        value = VTABLE_get_string(INTERP, PMC_array(SELF)[offset]);
        do_shift(INTERP, SELF);
        return value;
    }


/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC value of the element at index C<key>.

=cut

*/

    VTABLE PMC *get_pmc_keyed_int(INTVAL key) :no_wb {
        PMC **data;
        const INTVAL   size = PMC_size(SELF);
        const INTVAL offset = PMC_offset(SELF);
        PMC  *val;

        if (key < 0)
            key += size;
        if (key < 0)
            Parrot_ex_throw_from_c_noargs(INTERP, EXCEPTION_OUT_OF_BOUNDS,
                "index out of bounds");
        if (key >= size)
            return PMCNULL;

        data = PMC_array(SELF);
        val = data[key + offset];
        if (PMC_IS_NULL(val))
            return PMCNULL; /* handles NULL also */
        return val;
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *src)>

Sets the PMC value of the element at index C<key> to C<*src>.

=item C<void set_pmc_keyed(PMC *key, PMC *src)>

Sets the PMC value of the element keyed by C<key> to C<*src>.

=cut

*/

    VTABLE void set_pmc_keyed_int(INTVAL key, PMC *src) {
        const INTVAL size = PMC_size(SELF);
        INTVAL offset = PMC_offset(SELF);

        if (key < 0)
            key += size;
        if (key < 0)
            Parrot_ex_throw_from_c_noargs(INTERP, EXCEPTION_OUT_OF_BOUNDS,
                "index out of bounds");
        if (key >= size) {
            SELF.set_integer_native(key + 1);
            offset = PMC_offset(SELF);
        }
        TRACE_RPAd("set keyed", SELF);
        PMC_array(SELF)[key + offset] = src;
    }

    VTABLE void set_pmc_keyed(PMC *key, PMC *src) :manual_wb {
        SUPER(key, src);
    }

    VTABLE void set_pmc(PMC *value) :manual_wb {
        INTVAL size;
        INTVAL i;
        PMC ** data = PMC_array(SELF);

        if (SELF == value)
            return;
        if (!VTABLE_does(INTERP, value, CONST_STRING(INTERP, "array")))
            Parrot_ex_throw_from_c_noargs(INTERP, EXCEPTION_OUT_OF_BOUNDS,
                    "Can't set self from this type");

        PMC_offset(SELF) = 0;
        size = PMC_size(SELF) = VTABLE_elements(INTERP, value);
        /* TODO realloc */
        if (data) mem_gc_free(INTERP, data);
        data = PMC_array(SELF) = mem_gc_allocate_n_typed(INTERP, size, PMC *);
        for (i = 0; i < size; ++i)
            data[i] = VTABLE_get_pmc_keyed_int(INTERP, value, i);

        PObj_custom_mark_destroy_SETALL(SELF);
        PARROT_GC_WRITE_BARRIER(INTERP, SELF);
    }

/*

=item C<void delete_keyed_int(INTVAL key)>

=item C<void delete_keyed(PMC *key)>

Delete the element at index C<key>.

=cut

*/

    VTABLE void delete_keyed(PMC *key) :manual_wb {
        const INTVAL idx  = VTABLE_get_integer(INTERP, key);
        SELF.delete_keyed_int(idx);
    }

    VTABLE void delete_keyed_int(INTVAL key) {
        const INTVAL offset = PMC_offset(SELF);
        const INTVAL size = PMC_size(SELF);
        PMC ** const data = PMC_array(SELF);
        INTVAL i;

        /* TODO: use memmove. if 0 just bump offset */
        TRACE_RPAd("delete keyed", SELF);
        TRACE_PMC(key+offset, data[key+offset]);
        for (i = key + offset; i < size - 1; ++i)
            data[i] = data[i + 1];
        --PMC_size(SELF);
    }

/*

=item C<INTVAL exists_keyed_int(INTVAL key)>

=item C<INTVAL exists_keyed(PMC *key)>

Returns TRUE is the element at C<key> exists; otherwise returns false.

=cut

*/
    VTABLE INTVAL exists_keyed_int(INTVAL key) :no_wb {
        PMC ** const   data = PMC_array(SELF);
        const INTVAL   size = PMC_size(SELF);
        const INTVAL offset = PMC_offset(SELF);
        UNUSED(INTERP)

        if (key < 0)
            key += size;
        if (key < 0 || key >= size)
            return 0;

        return !PMC_IS_NULL(data[key + offset]);
    }

    VTABLE INTVAL exists_keyed(PMC *key) :no_wb {
        const INTVAL ix = VTABLE_get_integer(INTERP, key);
        return SELF.exists_keyed_int(ix);
    }

/*

=item C<INTVAL defined_keyed_int(INTVAL key)>

Returns TRUE is the element at C<key> is defined; otherwise returns false.

=cut

*/

    VTABLE INTVAL defined_keyed_int(INTVAL key) :no_wb {
        PMC *val = SELF.get_pmc_keyed_int(key);
        if (PMC_IS_NULL(val)) {
            return 0;
        }
        return VTABLE_defined(INTERP, val);
    }

/*

=item C<void push_float(FLOATVAL value)>

=item C<void push_integer(INTVAL value)>

=item C<void push_pmc(PMC *value)>

=item C<void push_string(STRING *value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    VTABLE void push_float(FLOATVAL value) :manual_wb {
        const INTVAL size = PMC_size(SELF);
        PMC   * const val = Parrot_pmc_new(INTERP, enum_class_Float);

        VTABLE_set_number_native(INTERP, val, value);
        SELF.set_pmc_keyed_int(size, val);
    }

    VTABLE void push_integer(INTVAL value) :manual_wb {
        const INTVAL size = PMC_size(SELF);
        PMC   * const val = Parrot_pmc_new_init_int(INTERP, enum_class_Integer, value);

        SELF.set_pmc_keyed_int(size, val);
    }

    VTABLE void push_pmc(PMC *value) {
        const INTVAL threshold = PMC_threshold(SELF);
        const INTVAL size      = PMC_size(SELF);
        INTVAL       offset    = PMC_offset(SELF);

        if (PMC_array(SELF) && (size < threshold)) {
            PMC_size(SELF)++;
            TRACE_RPAd("push fast", SELF);
        }
        else {
            SELF.set_integer_native(size + 1);
            offset = PMC_offset(SELF);
            TRACE_RPAd("push slow", SELF);
        }
        ((PMC **)PMC_array(SELF))[offset + size] = value;
        TRACE_PMC(offset+size, value);
    }

    VTABLE void push_string(STRING *value) :manual_wb {
        const INTVAL size = PMC_size(SELF);
        PMC   * const val = Parrot_pmc_new(INTERP, enum_class_String);

        VTABLE_assign_string_native(INTERP, val, value);
        SELF.set_pmc_keyed_int(size, val);
    }

/*

Removes and returns the last element in the array.

=item C<INTVAL pop_float()>

=item C<INTVAL pop_integer()>

=item C<PMC *pop_pmc()>

=item C<STRING *pop_string()>

=cut

*/

    VTABLE FLOATVAL pop_float() :manual_wb {
        PMC * const val = SELF.pop_pmc();
        return VTABLE_get_number(INTERP, val);
    }

    VTABLE INTVAL pop_integer() :manual_wb {
        PMC * const val = SELF.pop_pmc();
        return VTABLE_get_integer(INTERP, val);
    }

    VTABLE PMC *pop_pmc() :manual_wb {
        INTVAL size = PMC_size(SELF);
        const INTVAL offset = PMC_offset(SELF);
        PMC   *val;

        if (0 == size)
            throw_pop_empty(INTERP);
        --size;
        PMC_size(SELF) = size;
        val = PMC_array(SELF)[offset + size];

        PARROT_GC_WRITE_BARRIER(INTERP, SELF);
        return val;
    }

    VTABLE STRING *pop_string() :manual_wb {
        PMC * const val = SELF.pop_pmc();
        return VTABLE_get_string(INTERP, val);
    }

/*

=item C<void unshift_float(FLOATVAL value)>

=item C<void unshift_integer(INTVAL value)>

=item C<void unshift_pmc(PMC *value)>

=item C<void unshift_string(STRING *value)>

Extends the array by adding an element of value C<*value> to the begin of
the array.

=cut

*/

    VTABLE void unshift_float(FLOATVAL value) :manual_wb {
        PMC * const val = Parrot_pmc_new(INTERP, enum_class_Float);
        VTABLE_set_number_native(INTERP, val, value);
        do_unshift(INTERP, SELF, val);
    }

    VTABLE void unshift_integer(INTVAL value) :manual_wb {
        PMC * const val = Parrot_pmc_new_init_int(INTERP, enum_class_Integer, value);
        do_unshift(INTERP, SELF, val);
    }

    VTABLE void unshift_pmc(PMC *value) :manual_wb {
        do_unshift(INTERP, SELF, value);
    }

    VTABLE void unshift_string(STRING *value) :manual_wb {
        PMC * const val = Parrot_pmc_new(INTERP, enum_class_String);
        VTABLE_set_string_native(INTERP, val, value);
        do_unshift(INTERP, SELF, val);
    }

/*

=item C<void mark(void)>

Mark the array.

=cut

*/

    VTABLE void mark() :no_wb {
        PMC ** data = PMC_array(SELF);
        if (data) {
            INTVAL i = PMC_size(SELF);
            data += PMC_offset(SELF);
            for (i--; i >= 0; --i)
                Parrot_gc_mark_PMC_alive(INTERP, data[i]);
        }
    }

/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    VTABLE PMC *clone() :no_wb {
#if 0   /* keep the slack and offset */
        PMC * const copy   = Parrot_pmc_new(INTERP, SELF->vtable->base_type);
        const INTVAL size  = PMC_size(SELF);
        const INTVAL tresh = PMC_threshold(SELF);
        if (size) {
            PMC_size(copy)  = size;
            PMC_array(copy) = mem_gc_allocate_n_typed(INTERP, tresh, PMC *);
            mem_copy_n_typed(PMC_array(copy), PMC_array(SELF), tresh, PMC *);
            PObj_custom_mark_destroy_SETALL(copy);
        }
        PMC_threshold(copy) = tresh;
        PMC_offset(copy)    = PMC_offset(SELF);
#else   /* or compact the copy */
        PMC * const copy = SUPER();
        PMC_threshold(copy) = PMC_size(SELF);
        PMC_offset(copy)    = 0;
#endif
        return copy;
    }

/*

=item C<STRING *get_repr()>

Returns the Parrot string representation of the C<ResizablePMCArray>.

=cut

*/

    VTABLE STRING *get_repr() :no_wb {
        INTVAL  j;
        const INTVAL size = PMC_size(SELF);
        STRING *res = CONST_STRING(INTERP, "[ ");
        STRING *ret;

        for (j = 0; j < size; ++j) {
            PMC * const val = SELF.get_pmc_keyed_int(j);
            res = Parrot_str_concat(INTERP, res, VTABLE_get_repr(INTERP, val));
            if (j < size - 1)
                res = Parrot_str_concat(INTERP, res, CONST_STRING(INTERP, ", "));
        }
        ret = Parrot_str_concat(INTERP, res, CONST_STRING(INTERP, " ]"));
        return ret;
    }

/*

=item C<void splice(PMC *from, INTVAL offset, INTVAL count)>

Replaces C<count> elements starting at C<offset> with the elements in
C<from>.

Note that the C<from> PMC can be of any of the various array types.

=cut

*/

    VTABLE void splice(PMC *from, INTVAL offset, INTVAL count) {
        const INTVAL size = PMC_size(SELF);
        const INTVAL elems1 = VTABLE_elements(INTERP, from);
        INTVAL start  = PMC_offset(SELF);

        PMC **item = 0;
        INTVAL tail;
        INTVAL i;

        /* start from end? */
        if (offset < 0)
            offset += size;
        if (count < 0)
            Parrot_ex_throw_from_c_noargs(INTERP, EXCEPTION_OUT_OF_BOUNDS,
                    "illegal argument");
        if (offset < 0)
            Parrot_ex_throw_from_c_noargs(INTERP, EXCEPTION_OUT_OF_BOUNDS,
                    "index out of bounds");

        /* number of elements to the right of the splice (the "tail") */
        tail = size - offset - count;
        if (tail < 0) tail = 0;

        item = PMC_array(SELF);
        item += start;
        if (tail > 0 && count > elems1) {
            TRACE_RPAd("splice move tail left", SELF);
            TRACE_PMC(offset+elems1, item[offset+elems1]);
            /* we're shrinking the array, so first move the tail left */
            memmove(item + offset + elems1, item + offset + count,
                 tail * sizeof (PMC *));
        }
        /* now resize the array */
        SELF.set_integer_native(offset + elems1 + tail);
        start = PMC_offset(SELF);

        item = PMC_array(SELF);
        item += start;
        if (tail > 0 && count < elems1) {
            TRACE_RPAd("splice move tail right", SELF);
            TRACE_PMC(offset+elems1, item[offset+elems1]);
            /* the array grew, so move the tail to the right */
            memmove(item + offset + elems1, item + offset + count,
                 tail * sizeof (PMC *));
        }

        /* now copy C<from>'s elements into SELF */
        if (elems1 > 0) {
            TRACE_RPAd("splice copy from", SELF);
            TRACE_PMC(offset, item[offset]);
            PMC *iter = VTABLE_get_iter(INTERP, from);
            for (i = 0; i < elems1; i++)
                item[offset + i] = VTABLE_shift_pmc(INTERP, iter);
        }
    }

/*

=back

=head2 Methods

=over 4

=item METHOD append(PMC *other)

Append the other array to this array.

=cut

*/

    METHOD append(PMC *other) {
        const INTVAL n = VTABLE_elements(INTERP, SELF);
        const INTVAL m = VTABLE_elements(INTERP, other);
        if (!m)
            return;

        /* pre-size it */
        VTABLE_set_integer_native(INTERP, SELF, n + m);

        if (other->vtable->base_type == SELF->vtable->base_type
        ||  other->vtable->base_type == enum_class_FixedPMCArray) {
            PMC ** const other_data = PMC_array(other);
            PMC ** const this_data  = PMC_array(SELF);

            /* libc is faster at copying data than a manual loop here */
            memmove(this_data + n, other_data, m  * sizeof (PMC *));
        }
        else {
            PMC ** const this_data = PMC_array(SELF);
            INTVAL i;
            for (i = 0; i < m; ++i)
                this_data[n + i] = VTABLE_get_pmc_keyed_int(INTERP, other, i);
        }
        RETURN(void);
    }

/*

=item METHOD PMC* shift()

=item METHOD PMC* pop()

Method forms to remove and return a PMC from the beginning or
end of the array.

=cut

*/

    METHOD shift() :manual_wb {
        PMC * const value = VTABLE_shift_pmc(INTERP, SELF);
        RETURN(PMC *value);
    }

    METHOD pop() :manual_wb {
        PMC * const value = VTABLE_pop_pmc(INTERP, SELF);
        RETURN(PMC *value);
    }

/*

=item METHOD unshift(PMC* value)

=item METHOD push(PMC* value)

Method forms to add a PMC to the beginning or end of the array.

=cut

*/

    METHOD unshift(PMC* value) :manual_wb {
        VTABLE_unshift_pmc(INTERP, SELF, value);
    }

    METHOD push(PMC* value) :manual_wb {
        VTABLE_push_pmc(INTERP, SELF, value);
    }

}

/*

=back

=head2 Auxiliar functions

=over 4

=item C<static void do_shift(PARROT_INTERP, PMC *arr)>

Common part for all shift operations.

=item C<static void do_unshift(PARROT_INTERP, PMC *arr, PMC *val)>

Common part for all unshift operations.

=item C<static void throw_shift_empty(PARROT_INTERP)>

=item C<static void throw_pop_empty(PARROT_INTERP)>

Throws with the appropriate message.

=cut

*/

PARROT_DOES_NOT_RETURN
PARROT_INLINE
static void
throw_shift_empty(PARROT_INTERP)
{
    ASSERT_ARGS(throw_shift_empty)
    Parrot_ex_throw_from_c_noargs(interp, EXCEPTION_OUT_OF_BOUNDS,
            "Can't shift from an empty array");
}

PARROT_DOES_NOT_RETURN
PARROT_INLINE
static void
throw_pop_empty(PARROT_INTERP)
{
    ASSERT_ARGS(throw_pop_empty)
    Parrot_ex_throw_from_c_noargs(interp, EXCEPTION_OUT_OF_BOUNDS,
            "Can't pop from an empty array");
}

/*

=back

=head1 See also

F<docs/pdds/pdd17_basic_types.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4 cinoptions='\:2=2' :
 */
