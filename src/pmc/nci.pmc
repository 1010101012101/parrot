/*
Copyright (C) 2001-2010, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/nci.pmc - Native Call Interface

=head1 DESCRIPTION

The vtable functions for the native C call functions.

=head2 Methods

=over 4

=cut

*/

/* Cheat with this include, for whatever reason the space is required */
# include "ffi.h"

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */

static void build_libffi_func(PARROT_INTERP,
    ARGMOD(Parrot_NCI_attributes *nci))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2)
        FUNC_MODIFIES(*nci);

static ffi_type * nci_to_ffi_type(PARROT_INTERP, nci_sig_elem_t nci_t)
        __attribute__nonnull__(1);

#define ASSERT_ARGS_build_libffi_func __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(nci))
#define ASSERT_ARGS_nci_to_ffi_type __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp))
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */
/* HEADERIZER END: static */

#if (INTVAL_SIZE == 4)
#  define ffi_type_parrot_intval ffi_type_sint32
#elif (INTVAL_SIZE == 8)
#  define ffi_type_parrot_intval ffi_type_sint64
#else
#  error "unhandled INTVAL_SIZE value"
#endif

#if (NUMVAL_SIZE == 4)
#  define ffi_type_parrot_numval ffi_type_float
#elif (NUMVAL_SIZE == 8)
#  define ffi_type_parrot_numval ffi_type_double
#else
#  error "unhandled NUMVAL_SIZE value"
#endif

typedef struct pmc_holder_t {
    PMC* p;
    union {
        short  s;
        int    i;
        long   l;
        void  *ptr;
    };
    union {
        INTVAL  *ival;
        void   **pval;
    };
} pmc_holder_t;

typedef struct {
    INTVAL    i;
    FLOATVAL  n;
    STRING   *s;
    PMC      *p;
} parrot_var_t;

/*

=item C<static ffi_cif *sig_to_cif(PARROT_INTERP, Parrot_NCI_attributes *nci)>

=cut

*/

static void
sig_to_cif(PARROT_INTERP, ARGMOD(Parrot_NCI_attributes *nci)) {
    int        i;
    PMC       *sig   = nci->signature;
    INTVAL     argc  = VTABLE_elements(interp, sig) - 1;
    ffi_type  *ret_t = nci_to_ffi_type(interp, VTABLE_get_integer_keyed_int(interp, sig, 0));
    ffi_type **arg_t = mem_gc_allocate_n_zeroed_typed(interp, argc, ffi_type *);
    ffi_cif   *cif   = mem_gc_allocate_zeroed_typed(interp, ffi_cif);

    for (i = 0; i < argc; i++) {
        arg_t[i] = nci_to_ffi_type(interp, VTABLE_get_integer_keyed_int(interp, sig, i + 1));
    }

    if (ffi_prep_cif(cif, FFI_DEFAULT_ABI, argc, ret_t, arg_t) == FFI_OK) {
        nci->cif = cif;
        nci->arg_types = arg_t;
        return;
    }

    mem_gc_free(interp, arg_t);
    mem_gc_free(interp, cif);

    Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_JIT_ERROR, "invalid ffi signature");
}


/*

=item C<static ffi_type * nci_to_ffi_type(PARROT_INTERP, nci_sig_elem_t nci_t)>

=cut

*/

static ffi_type *
nci_to_ffi_type(PARROT_INTERP, nci_sig_elem_t nci_t) {
    switch (nci_t) {
      case enum_nci_sig_void:   return &ffi_type_void;
      case enum_nci_sig_null:   return &ffi_type_pointer;
      case enum_nci_sig_interp: return &ffi_type_pointer;

      case enum_nci_sig_float:  return &ffi_type_float;
      case enum_nci_sig_double: return &ffi_type_double;
      case enum_nci_sig_numval: return &ffi_type_parrot_numval;

      case enum_nci_sig_char:   return &ffi_type_schar;
      case enum_nci_sig_short:  return &ffi_type_sshort;
      case enum_nci_sig_int:    return &ffi_type_sint;
      case enum_nci_sig_long:   return &ffi_type_slong;
      case enum_nci_sig_intval: return &ffi_type_parrot_intval;

      case enum_nci_sig_string:
      case enum_nci_sig_cstring: 
      case enum_nci_sig_cstringref:
      case enum_nci_sig_bufref:
                                return &ffi_type_pointer;

      case enum_nci_sig_ptr:
      case enum_nci_sig_pmc:
      case enum_nci_sig_pmcinv:
      case enum_nci_sig_pmcslurp:
      case enum_nci_sig_ptrref:
      case enum_nci_sig_shortref:
      case enum_nci_sig_intref:
      case enum_nci_sig_longref:
                                return &ffi_type_pointer;
    }
}

/*

=item C<void sig_to_pcc_cif(PARROT_INTERP, Parrot_NCI_attributes *nci)>

generate Parrot_pcc_fill_params_from_c_args dynamic call infrastructure

=cut

*/

static void
sig_to_pcc_cif(PARROT_INTERP, Parrot_NCI_attributes *nci)
{
    INTVAL     argc  = Parrot_str_length(interp, nci->pcc_params_signature) + 3;
    ffi_type **arg_t =  nci->pcc_arg_types = 
                        mem_gc_allocate_n_zeroed_typed(interp, argc, ffi_type *);
    int i;

    arg_t[0] = &ffi_type_pointer; /* interp */
    arg_t[1] = &ffi_type_pointer; /* call object */
    arg_t[2] = &ffi_type_pointer; /* pcc signature */
    for (i = 3; i < argc; i++)
        arg_t[i] = &ffi_type_pointer; /* INSP pointer */

    if (ffi_prep_cif(&nci->pcc_cif, FFI_DEFAULT_ABI, argc, &ffi_type_void, arg_t) !=
        FFI_OK)
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_JIT_ERROR, "invalid ffi signature");
}

/*

=item C<void build_libffi_func(PARROT_INTERP, Parrot_NCI_attributes *nci)>

=cut

*/

static void
build_libffi_func(PARROT_INTERP, ARGMOD(Parrot_NCI_attributes *nci))
{
    ASSERT_ARGS(build_libffi_func)

    nci->signature = Parrot_nci_parse_signature(interp, nci->sig_str);

    Parrot_nci_sig_to_pcc(interp, nci->signature,
                            &nci->pcc_params_signature,
                            &nci->pcc_return_signature);

    /* Arity is length of the signature minus one (the return type). */
    nci->arity       = VTABLE_elements(interp, nci->signature) - 1;

    sig_to_cif(interp, nci);
    sig_to_pcc_cif(interp, nci);
}

pmclass NCI auto_attrs provides invokable {
    /* NCI thunk handling attributes */
    ATTR PMC       *signature;
    ATTR STRING    *sig_str;
    ATTR void      *func;                   /* Function pointer to call. */
    ATTR void      *orig_func;
    ATTR PMC       *fb_info;                /* Frame-builder info */

    /* Parrot Sub-ish attributes */
    ATTR STRING    *pcc_params_signature;
    ATTR STRING    *pcc_return_signature;
    ATTR INTVAL     arity;

    /* LibFFI attributes */
    ATTR void      *cif;
    ATTR void      *arg_types;
    ATTR ffi_cif    pcc_cif;
    ATTR ffi_type **pcc_arg_types;

    /* MMD fields */
    ATTR STRING    *long_signature;         /* The full signature. */
    ATTR PMC       *multi_sig;              /* type tuple array (?) */

/*

=item C<METHOD get_multisig()>

Return the MMD signature PMC, if any or a Null PMC.

=cut

*/

    METHOD get_multisig() {
        PMC *sig;
        GET_ATTR_multi_sig(INTERP, SELF, sig);
        if (PMC_IS_NULL(sig))
            sig = PMCNULL;
        RETURN(PMC *sig);
    }

/*

=item C<METHOD set_raw_nci_ptr(void *func)>

Sets the specified function pointer and raw flag.

=cut

*/

    METHOD make_raw_nci(PMC *func) {
        VTABLE_set_pointer(interp, SELF, (void *)func);
    }

/*

=item C<void init()>

Initializes the NCI with a C<NULL> function pointer.

=cut

*/

    VTABLE void init() {
        PObj_custom_mark_SET(SELF);
    }

/*

=item C<void set_pointer_keyed_str(STRING *key, void *func)>

Sets the specified function pointer and signature (C<*key>).

=cut

*/

    VTABLE void *get_pointer() {
        return PARROT_NCI(SELF)->orig_func;
    }

    VTABLE void set_pointer_keyed_str(STRING *key, void *func) {
        Parrot_NCI_attributes * const nci_info   = PARROT_NCI(SELF);

        /* Store the original function and signature. */
        SET_ATTR_func(INTERP, SELF, func);

        /* ensure that the STRING signature is constant */
        if (!PObj_constant_TEST(key)) {
            char * const key_c      = Parrot_str_to_cstring(INTERP, key);
            const size_t key_length = Parrot_str_byte_length(interp, key);
            key                     = string_make(interp, key_c, key_length, NULL, 0);
            Parrot_str_free_cstring(key_c);
        }

        nci_info->sig_str = key;
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs.

=cut

*/
    VTABLE void mark() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);

        Parrot_gc_mark_PMC_alive(interp, nci_info->fb_info);
        Parrot_gc_mark_PMC_alive(interp, nci_info->signature);
        Parrot_gc_mark_STRING_alive(interp, nci_info->sig_str);
        Parrot_gc_mark_STRING_alive(interp, nci_info->pcc_params_signature);
        Parrot_gc_mark_STRING_alive(interp, nci_info->pcc_return_signature);
        Parrot_gc_mark_STRING_alive(interp, nci_info->long_signature);
        Parrot_gc_mark_PMC_alive(interp, nci_info->multi_sig);
    }

/*

=item C<void destroy()>

Free all of the memory used internally to store various things, like libffi call signatures.

=cut

*/

    VTABLE void destroy() {
        if (PARROT_NCI(SELF)) {
            Parrot_NCI_attributes *nci = PARROT_NCI(SELF);
            mem_gc_free(INTERP, nci->cif);
            mem_gc_free(INTERP, nci->arg_types);
            mem_gc_free(INTERP, nci->pcc_arg_types);
        }
    }


/*

=item C<PMC *clone()>

Creates and returns a clone of the NCI.

=cut

*/

    VTABLE PMC *clone() {
        Parrot_NCI_attributes * const nci_info_self = PARROT_NCI(SELF);
        Parrot_NCI_attributes *nci_info_ret;
        void                  *cif;

        PMC * const ret     = Parrot_pmc_new(INTERP, SELF->vtable->base_type);
        nci_info_ret        = PARROT_NCI(ret);

        /* FIXME if data is malloced (JIT/i386!) then we need
         * the length of data here, to memcpy it
         * ManagedStruct or Buffer?
         */
        nci_info_ret->func                  = nci_info_self->func;
        nci_info_ret->fb_info               = nci_info_self->fb_info;
        nci_info_ret->orig_func             = nci_info_self->orig_func;
        nci_info_ret->cif                   = nci_info_self->cif;
        nci_info_ret->sig_str               = nci_info_self->sig_str;
        nci_info_ret->pcc_params_signature  = nci_info_self->pcc_params_signature;
        nci_info_ret->pcc_return_signature  = nci_info_self->pcc_params_signature;
        nci_info_ret->arity                 = nci_info_self->arity;
        PObj_get_FLAGS(ret)                |= (PObj_get_FLAGS(SELF) & 0x7);

        return ret;
    }

/*

=item C<INTVAL defined()>

Returns whether the NCI is defined.

=cut

*/

    VTABLE INTVAL defined() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        return nci_info->orig_func != NULL;
    }

/*

=item C<opcode_t *invoke(void *next)>

Calls the associated C function, returning C<*next>. If the invocant is a
class, the PMC arguments are shifted down.

=cut

*/

    VTABLE opcode_t *invoke(void *next) {
        Parrot_NCI_attributes * const nci_info    = PARROT_NCI(SELF);
        char                         *sig_str;
        PMC                          *cont;
        PMC                          *ctx         = CURRENT_CONTEXT(interp);
        PMC                          *call_object = Parrot_pcc_get_signature(interp, ctx);
        void (*func)(void*,void*,void*); /* a function pointer for our function to call */

        void **values; 
        parrot_var_t *pcc_arg;
        void **translation_pointers = NULL; /* Data translation pointers, used to hold values
                                               that are passed by reference so we can update
                                               the objects after the FFI call is over */
        void **middle_man = NULL; /* An array to hold various pointers so they are not lost if 
                                      the function changes values by reference */
        void *return_data; /* Holds return data from FFI call */
        int i, j;
        ffi_cif *cif;

        cif  = (ffi_cif*)nci_info->cif;
        func = (void (*)(void*, void*, void*))nci_info->func;

        if (!cif) {
            /* build the thunk only when necessary */
            build_libffi_func(interp, nci_info);
            cif = nci_info->cif;

            if (!cif && !func)
                Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "attempt to call NULL function");
        }

        /* dynamic call to Parrot_pcc_fill_params_from_c_args */
        {
            INTVAL  pcc_argc = Parrot_str_length(interp, nci_info->pcc_params_signature);
            char   *pcc_sig  = Parrot_str_to_cstring(interp, nci_info->pcc_params_signature);

            void **pcc_arg_ptr, **call_arg;

            ffi_arg ffi_ret_dummy;

            pcc_arg     = mem_gc_allocate_n_zeroed_typed(interp, pcc_argc, parrot_var_t);
            pcc_arg_ptr = mem_gc_allocate_n_zeroed_typed(interp, pcc_argc, void *);
            call_arg    = mem_gc_allocate_n_zeroed_typed(interp, pcc_argc + 3, void*);

            /* setup Parrot_pcc_fill_params_from_c_args required arguments */
            call_arg[0] = &interp;
            call_arg[1] = &call_object;
            call_arg[2] = &pcc_sig;

            // TODO: eliminate PCC signature parsing somehow
            for (i = 0; i < pcc_argc; i++) {
                switch (pcc_sig[i]) {
                  case 'I':
                    pcc_arg_ptr[i] = &pcc_arg[i].i;
                    break;
                  case 'N':
                    pcc_arg_ptr[i] = &pcc_arg[i].n;
                    break;
                  case 'S':
                    pcc_arg_ptr[i] = &pcc_arg[i].s;
                    break;
                  case 'P':
                    pcc_arg_ptr[i] = &pcc_arg[i].p;
                    break;
                }

                call_arg[i + 3] = &pcc_arg_ptr[i];
            }

            ffi_call(&nci_info->pcc_cif, FFI_FN(Parrot_pcc_fill_params_from_c_args), &ffi_ret_dummy, call_arg);

            mem_gc_free(interp, call_arg);
            mem_gc_free(interp, pcc_arg_ptr);
            Parrot_str_free_cstring(pcc_sig);
        }

        {
            values = mem_gc_allocate_n_zeroed_typed(interp, nci_info->arity, void *);
            middle_man = mem_gc_allocate_n_zeroed_typed(interp, nci_info->arity, void *);

            /*
             *  Apply Argument Transformations
             *   this is mostly to transform STRING* into char*
             *   and add the parrot interp argument if it needs it
             *   but other transformations might apply later, like packing an
             *   object into a ManagedStruct
             */
            translation_pointers = mem_internal_allocate_n_zeroed_typed(nci_info->arity, void*);
            for (i = 0, j = 0; i < (size_t)nci_info->arity; i++) {
                pmc_holder_t *pmc_holder;
                switch (VTABLE_get_integer_keyed_int(interp, nci_info->signature, i + 1)) {
                  case enum_nci_sig_interp:
                    values[i] = &interp;
                    break;
                  case enum_nci_sig_string:
                    translation_pointers[i] = pcc_arg[j++].s;
                    values[i]               = &translation_pointers[i];
                    break;
                  case enum_nci_sig_cstring:
                    translation_pointers[i] = STRING_IS_NULL(pcc_arg[j].s) ?
                                                (char *)NULL :
                                                Parrot_str_to_cstring(interp, pcc_arg[j].s);
                    j++;
                    values[i] = &translation_pointers[i];
                    break;
                  case enum_nci_sig_bufref:
                    translation_pointers[i] = STRING_IS_NULL(pcc_arg[j].s) ?
                                                (char *)NULL :
                                                Parrot_str_to_cstring(interp, pcc_arg[j].s);
                    j++;
                    middle_man[i]           = &translation_pointers[i];
                    values[i]               = &middle_man[i];
                    break;
                  case enum_nci_sig_cstringref:
                    values[i] = &Buffer_bufstart(pcc_arg[j++].s);
                    break;
                  case enum_nci_sig_char:
                    translation_pointers[i]            = mem_internal_allocate_zeroed_typed(char);
                    *(char *)(translation_pointers[i]) = (char)pcc_arg[j++].i;
                    values[i]                          = translation_pointers[i];
                    break;
                  case enum_nci_sig_shortref:
                    pmc_holder       = translation_pointers[i]
                                     = mem_internal_allocate_zeroed_typed(pmc_holder_t);
                    pmc_holder->p    = pcc_arg[j].p;
                    pmc_holder->ival = &pmc_holder->s;
                    pmc_holder->s    = (short)VTABLE_get_integer(interp, pcc_arg[j].p);
                    j++;
                    values[i]        = &pmc_holder->ival;
                    break;
                  case enum_nci_sig_short:
                    translation_pointers[i]             = mem_internal_allocate_zeroed_typed(short);
                    *(short *)(translation_pointers[i]) = (short)pcc_arg[j++].i;
                    values[i]                           = translation_pointers[i];
                    break;
                  case enum_nci_sig_intref:
                    pmc_holder       = translation_pointers[i]
                                     = mem_internal_allocate_zeroed_typed(pmc_holder_t);
                    pmc_holder->p    = pcc_arg[j].p;
                    pmc_holder->ival = &pmc_holder->i;
                    pmc_holder->i    = (int)VTABLE_get_integer(interp, pcc_arg[j].p);
                    j++;
                    values[i]        = &pmc_holder->ival;
                    break;
                  case enum_nci_sig_int:
                    translation_pointers[i]           = mem_internal_allocate_zeroed_typed(int);
                    *(int *)(translation_pointers[i]) = (int)pcc_arg[j++].i;
                    values[i]                         = translation_pointers[i];
                    break;
                  case enum_nci_sig_longref:
                    pmc_holder       = translation_pointers[i]
                                     = mem_internal_allocate_zeroed_typed(pmc_holder_t);
                    pmc_holder->p    = pcc_arg[j].p;
                    pmc_holder->ival = &pmc_holder->l;
                    pmc_holder->l    = (long)VTABLE_get_integer(interp, pcc_arg[j].p);
                    j++;
                    values[i]        = &pmc_holder->ival;
                    break;
                  case enum_nci_sig_long:
                    translation_pointers[i]            = mem_internal_allocate_zeroed_typed(long);
                    *(long *)(translation_pointers[i]) = (long)pcc_arg[j++].i;
                    values[i]                          = translation_pointers[i];
                    break;
                  case enum_nci_sig_ptrref:
                    pmc_holder       = translation_pointers[i]
                                     = mem_internal_allocate_zeroed_typed(pmc_holder_t);
                    pmc_holder->p    = pcc_arg[j].p;
                    pmc_holder->pval = &pmc_holder->ptr;
                    pmc_holder->ptr  = PMC_IS_NULL(pcc_arg[j].p) ?
                                        (void *)NULL :
                                        (void *)VTABLE_get_pointer(interp, pcc_arg[j].p);
                    j++;
                    values[i]        = &pmc_holder->pval;
                    break;
                  case enum_nci_sig_pmc:
                    translation_pointers[i] = pcc_arg[j++].p;
                    values[i]               = &translation_pointers[i];
                    break;
                  case enum_nci_sig_ptr:
                    translation_pointers[i] = PMC_IS_NULL(pcc_arg[j].p) ?
                                (void *)NULL : VTABLE_get_pointer(interp, pcc_arg[j].p);
                    j++;
                    values[i]               = &translation_pointers[i];
                    break;
                  case enum_nci_sig_float:
                    translation_pointers[i]             = mem_internal_allocate_zeroed_typed(float);
                    *(float *)(translation_pointers[i]) = (float)pcc_arg[j++].n;
                    values[i]                           = translation_pointers[i];
                    break;
                  case enum_nci_sig_double:
                    translation_pointers[i]              = mem_internal_allocate_zeroed_typed(double);
                    *(double *)(translation_pointers[i]) = (double)pcc_arg[j++].n;
                    values[i]                            = translation_pointers[i];
                    break;
                  case enum_nci_sig_numval:
                    translation_pointers[i]                = mem_internal_allocate_zeroed_typed(FLOATVAL);
                    *(FLOATVAL *)(translation_pointers[i]) = pcc_arg[j++].n;
                    values[i]                              = translation_pointers[i];
                    break;
                }
            }

            mem_gc_free(interp, pcc_arg); 
        }

        /*
         *  This will allow for any type of datat to be returned.
         *  Including one day Structures
         */
        return_data = mem_sys_allocate(cif->rtype->size);

        ffi_call(cif, FFI_FN(func), return_data, values);

        if (cif->rtype != &ffi_type_void) {
            char         *s;
            PMC          *ret_object;
            parrot_var_t  final_destination;
            s = Parrot_str_to_cstring(interp, nci_info->pcc_return_signature);
            switch (VTABLE_get_integer_keyed_int(interp, nci_info->signature, 0)) {
              case enum_nci_sig_ptr:
                final_destination.p = PMCNULL;

                if (*(void **)return_data != NULL) {
                    final_destination.p = Parrot_pmc_new(interp, enum_class_UnManagedStruct);
                    VTABLE_set_pointer(interp, final_destination.p, *(void **)return_data);
                }
                ret_object = Parrot_pcc_build_call_from_c_args(interp,
                                                                call_object,
                                                                s, final_destination.p);
                break;
              case enum_nci_sig_cstring:
                final_destination.s = Parrot_str_new(interp, *(char **)return_data, 0);
                ret_object = Parrot_pcc_build_call_from_c_args(interp,
                                                               call_object,
                                                               s, final_destination.s);
                break;
              case enum_nci_sig_float:
                final_destination.n = *(float *)return_data;

                ret_object = Parrot_pcc_build_call_from_c_args(interp, 
                                                        call_object, 
                                                        s, final_destination.n);
                break;
              default:
                switch (s[0]) {
                  case 'N':
                    ret_object = Parrot_pcc_build_call_from_c_args(interp,
                                                           call_object,
                                                           s, *(FLOATVAL *)return_data);
                  case 'I':
                    ret_object = Parrot_pcc_build_call_from_c_args(interp,
                                                           call_object,
                                                           s, *(INTVAL *)return_data);
                  case 'P':
                  case 'S':
                  default:
                    ret_object = Parrot_pcc_build_call_from_c_args(interp,
                                                           call_object,
                                                           s, *(void **)return_data);
                }
                break;
            }
            Parrot_str_free_cstring(s);
        }

        /*
         * Free memory used for cstrings,
         * and any other translations that use temporary memory
         */
        for (i = 0; i < (size_t)nci_info->arity; i++) {
            switch (VTABLE_get_integer_keyed_int(interp, nci_info->signature, i + 1)) {
              case enum_nci_sig_bufref:
                if (translation_pointers[i]) {
                    Parrot_str_free_cstring((char*)translation_pointers[i]);
                }
                break;
              case enum_nci_sig_cstring:
                if (translation_pointers[i]) {
                    Parrot_str_free_cstring((char*)translation_pointers[i]);
                }
                break;
              case enum_nci_sig_shortref:
                VTABLE_set_integer_native(interp, 
                            ((pmc_holder_t*)translation_pointers[i])->p, 
                            ((pmc_holder_t*)translation_pointers[i])->s);
                mem_sys_free(translation_pointers[i]);
                break;
              case enum_nci_sig_intref:
                VTABLE_set_integer_native(interp, 
                            ((pmc_holder_t*)translation_pointers[i])->p,
                            ((pmc_holder_t*)translation_pointers[i])->i);
                mem_sys_free(translation_pointers[i]);
                break;
              case enum_nci_sig_longref:
                VTABLE_set_integer_native(interp,
                            ((pmc_holder_t*)translation_pointers[i])->p,
                            ((pmc_holder_t*)translation_pointers[i])->l);
                mem_sys_free(translation_pointers[i]);
                break;
              case enum_nci_sig_ptrref:
                VTABLE_set_pointer(interp, 
                            ((pmc_holder_t*)translation_pointers[i])->p, 
                            ((pmc_holder_t*)translation_pointers[i])->ptr);
                mem_sys_free(translation_pointers[i]);
                break;
              case enum_nci_sig_double:
              case enum_nci_sig_char:
              case enum_nci_sig_short:
              case enum_nci_sig_int:
              case enum_nci_sig_long:
                if (translation_pointers[i]) {
                    mem_sys_free(translation_pointers[i]);
                }
                break;
              default:
                break;
            }
        }
    
        mem_gc_free(interp, middle_man);
        mem_gc_free(interp, return_data);
        mem_gc_free(interp, values);

        cont = INTERP->current_cont;

        /*
         * If the NCI function was tailcalled, the return result
         * is already passed back to the caller of this frame
         * - see  Parrot_init_ret_nci(). We therefore invoke the
         * return continuation here, which gets rid of this frame
         * and returns the real return address
         */
        if (cont && cont != NEED_CONTINUATION
        && (PObj_get_FLAGS(cont) & SUB_FLAG_TAILCALL)) {
            cont = Parrot_pcc_get_continuation(interp, CURRENT_CONTEXT(interp));
            next = VTABLE_invoke(INTERP, cont, next);
        }

        return (opcode_t *)next;
    }

/*

=item C<INTVAL get_integer()>

Returns the function pointer as an integer.

=cut

*/

    VTABLE INTVAL get_integer() {
        // XXX: TODO
        return 0;
    }

/*

=item C<INTVAL get_bool()>

Returns the boolean value of the pointer.

=cut

*/

    VTABLE INTVAL get_bool() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        return (0 != (INTVAL)nci_info->cif);
    }

/*

=item C<METHOD arity()>

Return the arity of the NCI (the number of arguments).

=cut

*/
    METHOD arity() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        INTVAL arity = 0;

        if (nci_info) {
            if (!nci_info->cif) {
                build_libffi_func(interp, nci_info);
            }
            if (nci_info->cif) {
                arity = nci_info->arity;
                RETURN(INTVAL arity);
            }
        }

        Parrot_ex_throw_from_c_args(INTERP, NULL,
            EXCEPTION_INVALID_OPERATION,
            "You cannot get the arity of an undefined NCI.");
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/draft/pdd16_native_call.pod>

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */

