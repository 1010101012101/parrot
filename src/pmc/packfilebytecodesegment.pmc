/*
Copyright (C) 2001-2008, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/packfilebytecodesegment.pmc - PackfileBytecodeSegment PMC

=head1 DESCRIPTION

This class implements a PackfileBytecode class, providing a PMC-based interface
for bytecode creation and manipulation.

See packfile.pmc for the toplevel Packfile interface; see PDD13 for the design
spec.

=head2 Methods

=over 4

=cut

*/

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* HEADERIZER END: static */

#include "pmc/pmc_packfileopmap.h"

pmclass PackfileBytecodeSegment auto_attrs extends PackfileSegment{
    ATTR PMC  *ops;    /* RIA of executable opcodes */
    ATTR PMC  *op_map; /* OpMap PMC */



/*

=item C<void init()>

Initialize PackfileBytecodeSegment.

=cut

*/
    VTABLE void init() {
        Parrot_PackfileBytecodeSegment_attributes * attrs =
                PMC_data_typed(SELF, Parrot_PackfileBytecodeSegment_attributes*);

        attrs->op_map = Parrot_pmc_new(INTERP, enum_class_PackfileOpMap);
        attrs->ops    = Parrot_pmc_new(INTERP, enum_class_ResizableIntegerArray);

        PObj_custom_mark_SET(SELF);
        SUPER();
    }

/*

=item C<void mark()>

Marks the object as live.

=cut

*/

    VTABLE void mark() {
        Parrot_PackfileBytecodeSegment_attributes * attrs =
            PARROT_PACKFILEBYTECODESEGMENT(SELF);

        Parrot_gc_mark_PMC_alive(INTERP, attrs->op_map);
        Parrot_gc_mark_PMC_alive(INTERP, attrs->ops);
        SUPER();
    }

/*

=item C<void *get_pointer()>

Return a pointer to a PackFile_ByteCode* built from this PMC's data.

=cut

*/

    VTABLE void *get_pointer() {
        INTVAL i, bc_seg_size, lib_count;
        STRING *oplib_name = CONST_STRING(INTERP, "oplib_name");
        STRING *lib_ops    = CONST_STRING(INTERP, "lib_ops");
        opcode_t *cursor;
        Parrot_PackfileBytecodeSegment_attributes *attrs =
            PMC_data_typed(SELF, Parrot_PackfileBytecodeSegment_attributes*);
        Parrot_PackfileOpMap_attributes *map_attrs =
            PMC_data_typed(attrs->op_map, Parrot_PackfileOpMap_attributes*);
        PackFile_ByteCode *bc_seg =
            mem_gc_allocate_zeroed_typed(INTERP, PackFile_ByteCode);


        bc_seg_size = 0;

        // TODO: calculate this while building bc segment for better efficiency
        bc_seg_size += VTABLE_elements(INTERP, attrs->ops);


        /* op count and number of libraries */
        bc_seg_size += 2;
        lib_count = VTABLE_elements(INTERP, map_attrs->op_maps);
        for (i = 0; i < lib_count; i++) {
            char *lib_name_cstring;
            PMC  *op_map = VTABLE_get_pmc_keyed_int(INTERP, map_attrs->op_maps, i);

            /* length of lib name as a cstring, plus padding */
            lib_name_cstring = Parrot_str_to_cstring(INTERP,
                        VTABLE_get_string_keyed_str(INTERP, op_map, oplib_name));
            bc_seg_size += PF_size_cstring(lib_name_cstring);
            mem_sys_free(lib_name_cstring);

            /* 3 for major, minor, patch */
            bc_seg_size += 3;

            /* 1 for number of ops */
            bc_seg_size += 1;

            /* 2*number of ops */
            bc_seg_size += (2 * VTABLE_elements(INTERP,
                        VTABLE_get_pmc_keyed_str(INTERP, op_map, lib_ops)));
        }

        bc_seg->base.type = PF_BYTEC_SEG;
        bc_seg->base.size = bc_seg_size;
        bc_seg->base.data = (opcode_t *) mem_sys_allocate(bc_seg_size);
        cursor = bc_seg->base.data;

        /* write bytecode bytes to segment */
        // TODO: use something more efficient than this, e.g. StringBuilder
        for (i = 0; i < VTABLE_elements(INTERP, attrs->ops); i++) {
            *cursor++ = VTABLE_get_integer_keyed_int(INTERP, attrs->ops, i);
        }

        /* write number of ops, number of libs */
        *cursor++ = map_attrs->op_count;
        *cursor++ = VTABLE_elements(INTERP, map_attrs->op_maps);

        /* for each lib */
        for (i = 0; i < VTABLE_elements(INTERP, map_attrs->op_maps); i++) {
            char *lib_name_cstring;
            PMC  *op_map    = VTABLE_get_pmc_keyed_int(INTERP, map_attrs->op_maps, i);
            PMC  *oplib     = VTABLE_get_pmc_keyed_str(INTERP, op_map, CONST_STRING(INTERP, "oplib"));
            PMC  *lib_ops   = VTABLE_get_pmc_keyed_str(INTERP, op_map, CONST_STRING(INTERP, "lib_ops"));
            PMC  *table_ops = VTABLE_get_pmc_keyed_str(INTERP, op_map, CONST_STRING(INTERP, "table_ops"));
            PMC  *version_array;
            INTVAL j, opmap_count;

            /* write lib name (PF_store_cstring) */
            lib_name_cstring = Parrot_str_to_cstring(INTERP,
                        VTABLE_get_string_keyed_str(INTERP, op_map, oplib_name));
            cursor = PF_store_cstring(cursor, lib_name_cstring);
            mem_sys_free(lib_name_cstring);

            /*  major, minor, patch */
            Parrot_pcc_invoke_method_from_c_args(INTERP, oplib, CONST_STRING(INTERP, "version"),
                    "->P", &version_array);

            /* major version, minor version, patch version */
            *cursor++ = VTABLE_pop_integer(INTERP, version_array);
            *cursor++ = VTABLE_pop_integer(INTERP, version_array);
            *cursor++ = VTABLE_pop_integer(INTERP, version_array);

            /* write number of mappings */
            opmap_count = map_attrs->op_count;
            *cursor++   = opmap_count;

            /* for each mapping */
            for (j = 0; j < opmap_count; j++) {
                *cursor++ = VTABLE_get_integer_keyed_int(INTERP, table_ops, j);
                *cursor++ = VTABLE_get_integer_keyed_int(INTERP, lib_ops, j);
            }

        }
    }


/*

=item C<void push_pmc()>

Add an op and its arguments to this bytecode.  The PMC should be a
ResizablePMCArray with the first PMC being a String containing the full name of
an op and the remaining PMCs being Integers.

=cut

*/

    VTABLE void push_pmc(PMC *p) {

        Parrot_PackfileBytecodeSegment_attributes *attrs =
            PMC_data_typed(SELF, Parrot_PackfileBytecodeSegment_attributes*);

        STRING *op_name;
        INTVAL  i, op_num, arr_size;

        if (!VTABLE_does(INTERP, p, CONST_STRING(INTERP, "array"))) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                    "PMC passed to push_pmc is not array-like");
        }

        op_num = VTABLE_get_integer_keyed_str(INTERP, attrs->op_map, 
                 VTABLE_get_string_keyed_int(INTERP, p, 0));

        if (op_num == -1) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                    "invalid op name: '%Ss'",
                    VTABLE_get_string_keyed_int(INTERP, p, 0));
        }

        /* add the things to attrs->ops */
        VTABLE_push_integer(INTERP, attrs->ops, op_num);
        arr_size = VTABLE_elements(INTERP, p);

        for (i = 1; i < arr_size; i++){
            VTABLE_push_integer(INTERP, attrs->ops,
                    VTABLE_get_integer_keyed_int(INTERP, p, i));
        }
    }

/*

=item C<void destroy()>

Destroy anything in this segment that need destroying.

=cut

*/

    VTABLE void destroy() {
        Parrot_PackfileBytecodeSegment_attributes * attrs =
            PARROT_PACKFILEBYTECODESEGMENT(SELF);
        VTABLE_destroy(INTERP, attrs->op_map);
        VTABLE_destroy(INTERP, attrs->ops);
        SUPER();
    }

/*

=item C<void load_lib()>

Load a dynop library so that ops contained in that library can be used in this
bytecode segment.

=cut

*/

    METHOD void load_lib(STRING *lib_name) {
        Parrot_PackfileBytecodeSegment_attributes * attrs =
            PARROT_PACKFILEBYTECODESEGMENT(SELF);
        Parrot_pcc_invoke_method_from_c_args(INTERP, SELF, CONST_STRING(INTERP, "load_lib"),
                "S->", lib_name);
    }


/*

=over 4

=item Packfile Interface Methods 

=back 4

=item C<STRING *pack()>

Serialize the segment.

=cut

*/
    METHOD pack() {
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_UNIMPLEMENTED,
                                    "PackfileBytecodeSegment.pack() not implemented yet.");
    }


/*

=item C<void unpack(STRING *data)>

Unpack a serialized segment string.

=cut

*/
    METHOD unpack(STRING *data) {
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_UNIMPLEMENTED,
                                    "PackfileBytecodeSegment.unpack() not implemented yet.");
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
