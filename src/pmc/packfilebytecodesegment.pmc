/*
Copyright (C) 2001-2008, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/packfilebytecodesegment.pmc - PackfileBytecodeSegment PMC

=head1 DESCRIPTION

This class implements a PackfileBytecode class, providing a PMC-based interface
for bytecode creation and manipulation.

See packfile.pmc for the toplevel Packfile interface; see PDD13 for the design
spec.

=head2 Methods

=over 4

=cut

*/

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* HEADERIZER END: static */

#include "pmc/pmc_packfileopmap.h"

pmclass PackfileBytecodeSegment auto_attrs extends PackfileSegment {
    ATTR PMC  *ops;    /* RIA of executable opcodes */
    ATTR PMC  *op_map; /* OpMap PMC */



/*

=item C<void init()>

Initialize PackfileBytecodeSegment.

=cut

*/
    VTABLE void init() {
        Parrot_PackfileBytecodeSegment_attributes * attrs =
                PMC_data_typed(SELF, Parrot_PackfileBytecodeSegment_attributes*);

        attrs->op_map = Parrot_pmc_new(INTERP, enum_class_PackfileOpMap);
        attrs->ops    = Parrot_pmc_new(INTERP, enum_class_ResizableIntegerArray);

        PObj_custom_mark_SET(SELF);
        SUPER();
    }

/*

=item C<void mark()>

Marks the object as live.

=cut

*/

    VTABLE void mark() {
        Parrot_PackfileBytecodeSegment_attributes * attrs =
            PARROT_PACKFILEBYTECODESEGMENT(SELF);

        Parrot_gc_mark_PMC_alive(INTERP, attrs->op_map);
        Parrot_gc_mark_PMC_alive(INTERP, attrs->ops);
        SUPER();
    }

/*

=item C<void *get_pointer()>

Return a pointer to a PackFile_ByteCode* built from this PMC's data.

=cut

*/

    VTABLE void *get_pointer() {
        INTVAL op_count, lib_count;
        size_t i;

        STRING *oplib_name = CONST_STRING(INTERP, "oplib_name");
        STRING *lib_ops    = CONST_STRING(INTERP, "lib_ops");
        PMC    *ops, *op_map;

        PackFile_ByteCode_OpMapping * mapping;

        /* ByteCode to return */
        PackFile_ByteCode * const bc = mem_gc_allocate_zeroed_typed(interp, PackFile_ByteCode);
        bc->base.type = PF_BYTEC_SEG;

        /* Create proper ByteCode structure from internal PMCs */

        /* Copy ops into ByteCode */
        GET_ATTR_ops(INTERP, SELF, ops);
        bc->base.size = VTABLE_get_integer(INTERP, ops);
        bc->base.data = mem_gc_allocate_n_typed(INTERP, bc->base.size, opcode_t);

        /* Not very efficient... */
        for (i = 0; i < bc->base.size; ++i) {
            bc->base.data[i] = VTABLE_get_integer_keyed_int(INTERP, ops, i);
        }

        /* Create various dynop mapping related structures */
        GET_ATTR_op_map(INTERP, SELF, op_map);
        op_count = VTABLE_get_integer(INTERP, op_map);

        bc->op_count = op_count;
        bc->op_func_table = mem_gc_allocate_n_zeroed_typed(interp, op_count, op_func_t);
        /* TODO Fill it */

        bc->op_info_table = mem_gc_allocate_n_zeroed_typed(interp, op_count, op_info_t*);
        /* TODO Fill it */

        /* Construct mappings */
        mapping = VTABLE_get_pointer(INTERP, op_map);
        memcpy(&bc->op_mapping, mapping, sizeof (PackFile_ByteCode_OpMapping));
        /* Don't free "mapping". Caller will do it */

        return bc;
    }


/*

=item C<void push_pmc()>

Add an op and its arguments to this bytecode.  The PMC should be a
ResizablePMCArray with the first PMC being a String containing the full name of
an op and the remaining PMCs being Integers.

=cut

*/

    VTABLE void push_pmc(PMC *p) {

        Parrot_PackfileBytecodeSegment_attributes *attrs =
            PMC_data_typed(SELF, Parrot_PackfileBytecodeSegment_attributes*);

        STRING *op_name;
        INTVAL  i, op_num, arr_size;

        if (!VTABLE_does(INTERP, p, CONST_STRING(INTERP, "array"))) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                    "PMC passed to push_pmc is not array-like");
        }

        op_num = VTABLE_get_integer_keyed_str(INTERP, attrs->op_map, 
                 VTABLE_get_string_keyed_int(INTERP, p, 0));

        if (op_num == -1) {
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                    "invalid op name: '%Ss'",
                    VTABLE_get_string_keyed_int(INTERP, p, 0));
        }

        /* add the things to attrs->ops */
        VTABLE_push_integer(INTERP, attrs->ops, op_num);
        arr_size = VTABLE_elements(INTERP, p);

        for (i = 1; i < arr_size; i++){
            VTABLE_push_integer(INTERP, attrs->ops,
                    VTABLE_get_integer_keyed_int(INTERP, p, i));
        }
    }

/*

=item C<void destroy()>

Destroy anything in this segment that need destroying.

=cut

*/

    VTABLE void destroy() {
        Parrot_PackfileBytecodeSegment_attributes * attrs =
            PARROT_PACKFILEBYTECODESEGMENT(SELF);
        VTABLE_destroy(INTERP, attrs->op_map);
        VTABLE_destroy(INTERP, attrs->ops);
        SUPER();
    }

/*

=item C<void load_lib()>

Load a dynop library so that ops contained in that library can be used in this
bytecode segment.

=cut

*/

    METHOD void load_lib(STRING *lib_name) {
        Parrot_PackfileBytecodeSegment_attributes * attrs =
            PARROT_PACKFILEBYTECODESEGMENT(SELF);
        Parrot_pcc_invoke_method_from_c_args(INTERP, SELF, CONST_STRING(INTERP, "load_lib"),
                "S->", lib_name);
    }


/*

=over 4

=item Packfile Interface Methods 

=back 4

=item C<STRING *pack()>

Serialize the segment.

=cut

*/
    METHOD pack() {
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_UNIMPLEMENTED,
                                    "PackfileBytecodeSegment.pack() not implemented yet.");
    }


/*

=item C<void unpack(STRING *data)>

Unpack a serialized segment string.

=cut

*/
    METHOD unpack(STRING *data) {
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_UNIMPLEMENTED,
                                    "PackfileBytecodeSegment.unpack() not implemented yet.");
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
