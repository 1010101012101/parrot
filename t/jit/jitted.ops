=head1 NAME

jitted.ops - Small subset of ops for JIT testing purpose.

Just because all ops parsing will take _a huge_ amount of time...

=cut

op noop() {
}

op end() :flow {
    goto ADDRESS(0);
}

op set(out STR, in STR) {
    $1 = $2;
}

op set(out INT, in INT) {
    $1 = $2;
}

op say(in INT) :base_io {
    Parrot_io_printf(interp, "%ld", (INTVAL)$1);
    Parrot_io_printf(interp, "\n");
}

op say(in STR) :base_io {
    STRING * const s = $1;
    /* if (s && s->bufused) */
        Parrot_io_printf(interp, "%Ss", $1);
    Parrot_io_printf(interp, "\n");
}

inline op say(in NUM) :base_io {
    Parrot_io_printf(interp, "%.15g\n", $1);
}

op say(invar PMC) :base_io {
    PMC * const p = $1;

    if (PMC_IS_NULL(p)) {
        opcode_t *handler = Parrot_ex_throw_from_op_args(interp, expr NEXT(),
             EXCEPTION_UNEXPECTED_NULL,
            "Null PMC in say");
        goto ADDRESS(handler);
    }
    else {
        STRING * const s = VTABLE_get_string(interp, p);
        if (s)
            Parrot_io_printf(interp, "%Ss", s);
        Parrot_io_printf(interp, "\n");
    }
}


op add(inout INT, in INT) :base_core {
    $1 += $2;
}


op branch(in LABEL) :base_loop :flow {
    goto OFFSET($1);
}

inline op eq(in INT, in INT, inconst LABEL) :base_core {
    if ($1 == $2) {
        goto OFFSET($3);
    }
}

inline op dec(inout INT) :base_core {
    $1--;
}

inline op inc(inout INT) :base_core {
    $1++;
}


