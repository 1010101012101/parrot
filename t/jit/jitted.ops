=head1 NAME

jitted.ops - Small subset of ops for JIT testing purpose.

Just because all ops parsing will take _a huge_ amount of time...

#include "parrot/parrot.h"

=cut

BEGIN_OPS_PREAMBLE

#include "parrot/dynext.h"
#include "parrot/embed.h"
#include "parrot/runcore_api.h"
#include "pmc/pmc_continuation.h"
#include "pmc/pmc_fixedintegerarray.h"
#include "pmc/pmc_parrotlibrary.h"

END_OPS_PREAMBLE

op noop() {
}

op end() :flow {
    goto ADDRESS(0);
}

inline op set(out INT, in INT) :base_core {
    $1 = $2;
}

inline op set(out INT, in NUM) :base_core {
    $1 = (INTVAL)($2);
}

inline op set(out INT, in STR) :base_core {
    $1 = Parrot_str_to_int(interp, $2);
}

inline op set(out NUM, in NUM) :base_core {
    $1 = $2;
}

inline op set(out NUM, in INT) :base_core {
    $1 = (FLOATVAL)$2;
}

inline op set(out NUM, in STR) :base_core {
    $1 = Parrot_str_to_num(interp, $2);
}

inline op set(out NUM, invar PMC) :base_core {
    $1 = VTABLE_get_number(interp, $2);
}

inline op set(out STR, invar PMC) :base_core {
    $1 = VTABLE_get_string(interp, $2);
}

inline op set(out STR, invar STR) :base_core {
    $1 = $2;
}

inline op set(out STR, inconst STR) :base_core {
    $1 = $2;
}

inline op set(out STR, in INT) :base_core {
    $1 = Parrot_str_from_int(interp, $2);
}

inline op set(out STR, in NUM) :base_core {
    $1 = Parrot_str_from_num(interp, $2);
}

inline op set(out PMC, inconst PMC) :base_core {
    $1 = $2;
}

inline op set(out PMC, invar PMC) :base_core {
    $1 = $2;
}

inline op set(invar PMC, in INT) :base_core {
    VTABLE_set_integer_native(interp, $1, $2);
}

inline op set(invar PMC, in NUM) :base_core {
    VTABLE_set_number_native(interp, $1, $2);
}

inline op set(invar PMC, invar STR) :base_core {
    VTABLE_set_string_native(interp, $1, $2);
}

inline op set(invar PMC, inconst STR) :base_core {
    VTABLE_set_string_native(interp, $1, $2);
}
inline op set(out INT, invar PMC) :base_core {
    $1 = VTABLE_get_integer(interp, $2);
}


op say(in INT) :base_io {
    Parrot_io_printf(interp, "%ld", (INTVAL)$1);
    Parrot_io_printf(interp, "\n");
}

op say(in STR) :base_io {
    STRING * const s = $1;
    /* if (s && s->bufused) */
    if (s)
        Parrot_io_printf(interp, "%Ss", s);
    Parrot_io_printf(interp, "\n");
}

inline op say(in NUM) :base_io {
    Parrot_io_printf(interp, "%.15g\n", $1);
}

op say(invar PMC) :base_io {
    PMC * const p = $1;

    if (PMC_IS_NULL(p)) {
        opcode_t *handler = Parrot_ex_throw_from_op_args(interp, expr NEXT(),
             EXCEPTION_UNEXPECTED_NULL,
            "Null PMC in say");
        goto ADDRESS(handler);
    }
    else {
        STRING * const s = VTABLE_get_string(interp, p);
        if (s)
            Parrot_io_printf(interp, "%Ss", s);
        Parrot_io_printf(interp, "\n");
    }
}


op add(inout INT, in INT) :base_core {
    $1 += $2;
}


op branch(in LABEL) :base_loop :flow {
    goto OFFSET($1);
}

inline op eq(in INT, in INT, inconst LABEL) :base_core {
    if ($1 == $2) {
        goto OFFSET($3);
    }
}

inline op dec(inout INT) :base_core {
    $1--;
}

inline op inc(inout INT) :base_core {
    $1++;
}


op set_args(inconst PMC) :flow {
    opcode_t * const raw_args = CUR_OPCODE;
    PMC * const signature = $1;
    PMC * const call_sig = Parrot_pcc_build_sig_object_from_op(interp,
            PMCNULL, signature, raw_args);
    INTVAL argc;
    GETATTR_FixedIntegerArray_size(interp, signature, argc);
    Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), call_sig);
    goto OFFSET(argc + 2);
}

op get_params(inconst PMC) :flow {
    opcode_t * const raw_params  = CUR_OPCODE;
    PMC      * const signature   = $1;
    PMC      * const ctx         = CURRENT_CONTEXT(interp);
    PMC      * const ccont       = Parrot_pcc_get_continuation(interp, ctx);
    PMC      * const caller_ctx  = Parrot_pcc_get_caller_ctx(interp, ctx);
    PMC      * const call_object = Parrot_pcc_get_signature(interp, caller_ctx);
    INTVAL argc;

    Parrot_pcc_fill_params_from_op(interp, call_object, signature, raw_params,
            PARROT_ERRORS_PARAM_COUNT_FLAG);

    /* TODO Factor out with Sub.invoke */
    if (PObj_get_FLAGS(ccont) & SUB_FLAG_TAILCALL) {
        PObj_get_FLAGS(ccont) &= ~SUB_FLAG_TAILCALL;
        Parrot_pcc_dec_recursion_depth(interp, ctx);
        Parrot_pcc_set_caller_ctx(interp, ctx, Parrot_pcc_get_caller_ctx(interp, caller_ctx));
    }
    GETATTR_FixedIntegerArray_size(interp, signature, argc);
    goto OFFSET(argc + 2);
}

op set_returns(inconst PMC) :flow {
    opcode_t * const raw_args  = CUR_OPCODE;
    PMC      * const signature = $1;
    PMC      * const call_sig  = Parrot_pcc_build_sig_object_from_op(interp,
                Parrot_pcc_get_signature(interp,
                Parrot_pcc_get_caller_ctx(interp, CURRENT_CONTEXT(interp))),
                    signature, raw_args);
    INTVAL argc;

    Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), call_sig);

    GETATTR_FixedIntegerArray_size(interp, signature, argc);
    goto OFFSET(argc + 2);
}

op get_results(inconst PMC) :flow {
    opcode_t * const raw_params  = CUR_OPCODE;
    PMC      * const signature   = $1;
    PMC             *ctx         = CURRENT_CONTEXT(interp);
    PMC             *call_object = Parrot_pcc_get_signature(interp, ctx);

    INTVAL argc;

    Parrot_pcc_fill_params_from_op(interp, call_object, signature, raw_params,
            PARROT_ERRORS_RESULT_COUNT_FLAG);

    GETATTR_FixedIntegerArray_size(interp, signature, argc);
    Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), PMCNULL);
    goto OFFSET(argc + 2);
}

inline op invokecc(invar PMC) :flow {
    PMC      * const p     = $1;
    opcode_t *dest         = expr NEXT();
    PMC      * const signature = Parrot_pcc_get_signature(interp,
                                    CURRENT_CONTEXT(interp));

    Parrot_pcc_set_pc(interp, CURRENT_CONTEXT(interp), dest);

    if (!PMC_IS_NULL(signature))
        Parrot_pcc_set_object(interp, signature, NULL);
    interp->current_cont   = NEED_CONTINUATION;
    dest                   = VTABLE_invoke(interp, p, dest);

    goto ADDRESS(dest);
}

inline op invoke(invar PMC, invar PMC) :flow {
    opcode_t   *dest       = expr NEXT();
    PMC * const p          = $1;
    PMC * const signature  = Parrot_pcc_get_signature(interp,
                                    CURRENT_CONTEXT(interp));

    Parrot_pcc_set_pc(interp, CURRENT_CONTEXT(interp), dest);

    if (!PMC_IS_NULL(signature))
        Parrot_pcc_set_object(interp, signature, NULL);
    interp->current_cont   = $2;

    dest = VTABLE_invoke(interp, p, dest);
    goto ADDRESS(dest);
}


