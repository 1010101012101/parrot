.version 0
.chunk "caller"
.constants
0 "1..1\n"
1 "ok 1 control flow in 'caller' at start\n"
2 "value of I23 is "
3 "callee"
4 "caller back from goto_chunk\n"
5 "\n"
.metadata
.bytecode

    set_imm I0, 0, 1
    set_imm S0, 0, 0
    deref   S0, CONSTS, S0
    print_s I0, S0, x
    # print "ok 1 control flow in 'caller' at start"
    set_imm S0, 0, 1
    deref   S0, CONSTS, S0
    print_s I0, S0, x

    # print "value of I23 is " ...
    set_imm I23, 39, 15
    set_imm S1, 0, 2
    deref   S1, CONSTS, S1
    print_s I0, S1, x
    print_i I0, I23, x
    set_imm S2, 0, 5
    deref   S2, CONSTS, S2
    print_s I0, S2, x

    # create a new call frame

    # point P1 at the current call frame
    set       P1,  CF, x

    # allocate a new call frame from the gc
    set_imm  I10, 8, 0
    set_imm  I11, 0, 0
    gc_alloc P0, I10, I11

    # intialize P0 (the new call frame) - INTERP
    # set new cf's PCF to the current cf (P1)
    set_ref  P0, INTERP, INTERP
    set_ref  P0, CHUNK, CHUNK
    set_ref  P0, CONSTS, CONSTS 
    set_ref  P0, MDS, MDS
    set_ref  P0, BCS, BCS
    set_ref  P0, PCF, CF
    set_ref  P0, CF, P0

    # initialize some values to zero
    set_imm  P2, 0, 0
    set_ref  P0, EH,       P2
    set_ref  P0, RETPC,    P2
    set_ref  P0, SPILLCF,  P2

    # set the return PC and chunk for the current cf
    set_imm I13, 0, 9
    add_i   RETPC, PC, I13

    # set the new call frame's PC to be post_set so that when it's # activated,
    # control flow will continue as normal
    set_imm I12, 0, 3
    add_i   I12, I12, PC
    set_ref P0, PC, I12

    # activate the new call frame and goto the callee chunk
    set     CF, P0, 99
post_set:
    set_imm S0, 0, 3
    deref   S0, CONSTS, S0
    set_imm I0, 0, 1
    goto_chunk I0, S0, x

    # We're back, so fix the parent call frame's PC and activate it.
    # The current CF's CHUNK, CONSTS, etc are updated by goto_chunk, so use
    # those values to update PCF.
    # TODO: Rethink if goto_chunk should update these, or if it should be the M0
    # code's responsibility.
retpc:

    set_ref  PCF, CHUNK, CHUNK
    set_ref  PCF, CONSTS, CONSTS
    set_ref  PCF, MDS, MDS
    set_ref  PCF, BCS, BCS

    set_imm I1, 0, 2
    add_i   I1, PC, I1
    set_ref PCF, PC, I1

activate_cf:
    set     CF, PCF, x

    # print "caller at end "
    set_imm S3, 0, 4
    deref   S3, CONSTS, S3
    print_s I0, S3, 98

    # print "value of I23 is " ...
    set_imm S4, 0, 2
    deref   S4, CONSTS, S4
    print_s I0, S4, 99
    print_i I0, I23, x
    print_s I0, S2, x

    set_imm I1, 0, 0
    exit    I1, x, x
    
.chunk "callee"
.constants
0 "in callee chunk\n"
1 "value of I23 is "
2 "parent call frame's value of I23 is "
3 "OH NOES!  Contol flow misflowed!\n"
4 "\n"
.metadata
.bytecode

    # print "in callee chunk"
    set_imm I0, 0, 1
    set_imm S0, 0, 0
    deref   S0, CONSTS, S0
    print_s I0, S0, x

    #print "value of I23 is "...
    set_imm S1, 0, 1
    deref   S1, CONSTS, S1
    print_s I0, S1, x
    set_imm I23, 99, 99
    print_i I0, I23, x
    set_imm S3, 0, 4
    deref   S3, CONSTS, S3
    print_s I0, S3, x

    # poke into the parent call frame
    set_imm S2, 0, 2
    deref   S2, CONSTS, S2
    print_s I0, S2, x
    set_imm I2, 0, I23
    deref   I1, PCF, I2
    print_i I0, I1, x
    print_s I0, S3, x

    # figure out return PC and chunk
    # P0 is the parent call frame
    set_imm I3, 0,  PCF
    deref   P0, CF, I3
    # I4 is the parent call frame's RETPC
    set_imm I4, 0,  RETPC
    deref   I4, P0, I4
    # P1 is the parent call frame's CHUNK
    set_imm I3, 0,  CHUNK
    deref   S3, P0, I3
    goto_chunk I4, S3, x

    # should be unreachable
    set_imm S0, 0, 3
    set_imm I0, 0, 1
    print_s I0, S0, x




# it's not really PASM, but the highlighting works well
# vim: expandtab shiftwidth=4 ft=pasm:    
