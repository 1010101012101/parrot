.version 0
.chunk "byte_ops_test"
.constants
0 "1..1\n"
1 "ok 1 hash of jellyfish string is correct\n"
2 "nok 1 hash of jellyfish string is not correct\n"
3 "I wish I were a jellyfish that cannot fall down stairs."
# XXX: the assembler isn't smart enough to properly store ints in m0b.
4 67827064
.metadata
.bytecode

    # 'x' => 120
    # 'quux' => 3281278855
    # 'I wish I were a jellyfish that cannot fall down stairs.' => 67827064

    set_imm I0, 0, 1
    set_imm S0, 0, 0
    deref   S0, CONSTS, S0
    print_s I0, S0, x
    
    ##################################
    # calculate the hash of string 3 #
    ##################################
hash_calc_init:

    set_imm S0, 0, 3
    deref   S0, CONSTS, S0

    # I1 = number of bytes in string
    set_imm I1, 0, 0
    get_word I1, S0, I1
    sub_i    I1, I1, I0

    # I2 = index into string (excluding header)
    set_imm I2, 0, 0
    # I3 = tmp
    set_imm I3, 0, 0
    # I4 = current hash value (hash)
    set_imm I4, 0, 0
    # I5 = temporary register for hash calculations
    set_imm I5, 0, 0

    # algorithm:
    # while (ch = *str++)
        # hash = ch + (hash << 6) + (hash << 16) - hash;
hash_loop_start:
    # tmp = current character of string
    set_imm I3, 0, 8
    add_i   I3, I3, I2
    get_byte I3, S0, I3

    # tmp += (hash << 6);
    set_imm I5, 0, 6
    shl     I5, I4, I5
    add_i   I3, I3, I5

    # tmp += (hash << 16);
    set_imm I5, 0, 16
    shl     I5, I4, I5
    add_i   I3, I3, I5    

    # hash = tmp - hash;
    sub_i   I4, I3, I4

    # increment the index into the string
    set_imm I5, 0, 1
    add_i   I2, I2, I5

    # if we're at the end of the string, break
    sub_i I5, I2, I1
    not I5, I5, x
    goto_if hash_loop_end, I5
    goto    hash_loop_start, x

hash_loop_end:
    
    # I4 contains the calculated hash
    # store known-good hash in I1
    # The m0 assembler can't currently deal with large int constants, so
    # calculate a known-good hash manually.  It should add up to 67827064.
    set_imm I1, 4, 10
    set_imm I2, 245, 120
    set_imm I3, 0, 16
    shl     I1, I1, I3
    add_i   I1, I1, I2

    sub_i   I1, I1, I4

    goto_if hash_test_fail, I1
    goto    hash_test_ok, x

hash_test_fail:
    set_imm S0, 0, 2
    goto print_result, x

hash_test_ok:
    set_imm S0, 0, 1
    goto print_result, x
    
print_result:
    deref   S0, CONSTS, S0
    print_s I0, S0, x

# This code isn't really PASM, but the highlighting works well.
# vim: expandtab shiftwidth=4 ft=pasm: 
