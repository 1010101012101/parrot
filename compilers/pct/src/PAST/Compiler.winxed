/*
=head1 NAME

PAST::Compiler - PAST Compiler

=head1 DESCRIPTION

PAST::Compiler implements a basic compiler for PAST nodes.
By default PAST::Compiler transforms a PAST tree into POST.

=head2 Signature Flags

Throughout the compiler PAST uses a number of 1-character
"flags" to indicate allowable register types and conversions.
This helps the compiler generate more efficient code and know
what sorts of conversions are allowed (or desired).  The
basic flags are:

    P,S,I,N   PMC, string, int, or num register
    Q         keyed PMC, next flag indicates type of key
    s         string register or constant
    i         int register or constant
    n         num register or constant
    r         any register result
    v         void (no result)
    *         any result type except void
    +         PMC, int register, num register, or numeric constant
    ~         PMC, string register, or string constant
    :         argument (same as '*'), possibly with :named or :flat
    0-9       use the nth input operand as the output result of this operation

These flags are used to describe signatures and desired return
types for various operations.  For example, if an opcode is
specified with a signature of C<I~P*>, then the opcode places
its result in an int register, its first child is coerced into
some sort of string value, its second child is coerced into a
PMC register, and the third and subsequent children can return
any value type.

=cut

*/

$include_const 'cclass.pasm';
$include_const 'except_types.pasm';
$include_const 'interpinfo.pasm';

class P6metaclass;
class PAST.Node;
class PAST.Stmt;

inline is_cclass(int cclass, string str, int pos) return int {
    int ret;
    ${ is_cclass ret, cclass, str, pos };
    return ret;
}

inline repeat(string str, int times) return string {
    string ret;
    ${ repeat ret, str, times };
    return ret;
}

namespace PAST.Compiler {
    // TEMPREG_BASE and UNIQUE_BASE identify the base location for
    // the temporary register set and unique registers
    const int TEMPREG_BASE = 100;
    const int UNIQUE_BASE  = 1000;

    function onload[anon, load, init]() {
        load_bytecode('PCT/HLLCompiler.pbc');
        var p6meta = new P6metaclass;
        var cproto = p6meta.new_class('PAST::Compiler', 'PCT::HLLCompiler':[named('parent')], '%!symtable':[named('attr')]);
        cproto.language('PAST');
        cproto.stages(split(' ', 'post pir evalpmc'));

        // %piropsig is a table of common opcode signatures
        var piropsig = {
            'add':        'PP+',
            'band':       'PPP',
            'bxor':       'PPP',
            'bnot':       'PP',
            'bor':        'PPP',
            'can':        'IPs',
            'chr':        'Si',
            'clone':      'PP',
            'concat':     'PP~',
            'copy':       '0PP',
            'defined':    'IP',
            'delete':     'vQ*',
            'die':        'v~',
            'div':        'PP+',
            'does':       'IPs',
            'downcase':   'Ss',
            'elements':   'IP',
            'exists':     'IQ*',
            'exit':       'vi',
            'fdiv':       'PP+',
            'find_codepoint':   'Is',
            'find_dynamic_lex': 'Ps',
            'find_name':  'Ps',
            'getinterp':  'P',
            'getprop':    'PP~',
            'getstderr':  'P',
            'getstdin':   'P',
            'getstdout':  'P',
            'index':      'Issi',
            'isa':        'IP~',
            'isfalse':    'IP',
            'isnull':     'IP',
            'issame':     'IPP',
            'istrue':     'IP',
            'join':       'SsP',
            'length':     'Is',
            'load_bytecode': 'vs',
            'load_language': 'vs',
            'loadlib':    'P~',
            'mod':        'PP+',
            'mul':        'PP+',
            'neg':        'PP',
            'new':        'P~',
            'newclosure': 'PP',
            'not':        'PP',
            'ord':        'Isi',
            'pop':        'PP',
            'pow':        'NN+',
            'print':      'v*',
            'printerr':   'v*',
            'push':       '0P*',
            'repeat':     'Ssi',
            'replace':    'Ssiis',
            'say':        'v*',
            'set':        'PP',
            'setprop':    '0P~P',
            'setattribute': '0P~P',
            'shift':      'PP',
            'shl':        'PP+',
            'shr':        'PP+',
            'sleep':      'v+',
            'splice':     '0PPii',
            'split':      'Pss',
            'sub':        'PP+',
            'substr':     'Ssii',
            'titlecase':  'Ss',
            'trace':      'vi',
            'typeof':     'SP',
            'unshift':    '0P*',
            'upcase':     'Ss'
        };
        ${ set_global '%piropsig', piropsig };

        // %valflags specifies when PAST::Val nodes are allowed to
        // be used as a constant.  The 'e' flag indicates that the
        // value must be quoted+escaped in PIR code.
        var valflags = {
            'String':   's~*:e',
            'Integer':  'i+*:',
            'Float':    'n+*:',
            '!macro_const':     'i+*:c',
            '!cclass':          'i+*:c',
            '!except_severity': 'i+*:c',
            '!except_types':    'i+*:c',
            '!iterator':        'i+*:c',
            '!socket':          'i+*:c'
        };
        ${ set_global '%valflags', valflags };

        // %!controltypes holds the list of exception types for each
        // type of exception handler we support
        var controltypes = {
            'CONTROL':  '.CONTROL_ALL',
            'RETURN':   '.CONTROL_RETURN',
            'OK':       '.CONTROL_OK',
            'BREAK':    '.CONTROL_BREAK',
            'CONTINUE': '.CONTROL_CONTINUE',
            'ERROR':    '.CONTROL_ERROR',
            'GATHER':   '.CONTROL_TAKE',
            'LEAVE':    '.CONTROL_LEAVE',
            'EXIT':     '.CONTROL_EXIT',
            'NEXT':     '.CONTROL_NEXT',
            'LAST':     '.CONTROL_LAST',
            'REDO':     '.CONTROL_REDO'
        };
        ${ set_global '%!controltypes', controltypes };

        ${ set_global '$!serno', var(UNIQUE_BASE) };

        return;
    }

/*
=head2 Compiler methods

=over 4

=item to_post(node [, 'option'=>option, ...])

Compile the abstract syntax tree given by C<past> into POST.

=cut

*/

    function to_post[method](var past, options [slurpy, named]) {
        self.*'%!symtable' = {};

        var blockpast;
        ${ get_global blockpast, '@?BLOCK' };
        if (blockpast == null) {
            blockpast = [];
            ${ set_global '@?BLOCK', blockpast };
        }
        ${ .lex '@*BLOCKPAST', blockpast };
        var sub;
        ${ .lex '$*SUB', sub };
        var lexregs;
        ${ .lex '%*LEXREGS', lexregs };

        var tempregs;
        ${ find_dynamic_lex tempregs, '%*TEMPREGS' };
        if (tempregs == null)
            tempregs = self.tempreg_frame();
        ${ .lex '%*TEMPREGS', tempregs };

        var ret = self.as_post(past, 'v':[named('rtype')]);
        return ret;
    }

/*
=item escape(str)

Return C<str> as a PIR constant string.

=cut

*/

    function escape[method](string str) {
        string estr = Winxed_Builtins.escape(str);
        if (indexof(estr, "\\x") >= 0 || indexof(estr, "\\u") >= 0)
            estr = 'unicode:"' + estr;
        else
            estr = '"' + estr;
        estr += '"';
        return estr;
    }

/*
=item unique([STR fmt])

Generate a unique number that can be used as an identifier.
If C<fmt> is provided, then it will be used as a prefix to the
unique number.

=cut

*/
    function unique[method](string fmt [optional], int has_fmt [opt_flag]) {
        if (!has_fmt)
            fmt = '';
        var serno;
        ${ get_global serno, '$!serno' };
        string ret = fmt + string(serno);
        ++serno;
        return ret;
    }

/*
=item uniquereg(rtype)

Generate a unique register based on C<rtype>, where C<rtype>
is one of the signature flags described above.

=cut

*/
    function uniquereg[method](string rtype) {
        if (!rtype)
            return self.panic('rtype not set');
        if (rtype == 'v')
            return '';
        int i = indexof('Ss~Nn+Ii', rtype);
        rtype = 'P';
        if (i >= 0)
            rtype = substr('SSSNNNII', i, 1);
        return self.unique('$' + rtype);
    }

/*
=item tempreg_frame()

Create a new temporary register frame, using register
identifiers TEMPREG_BASE up to UNIQUE_BASE.

=cut

*/
    function tempreg_frame[method]() {
        return {
            'i': TEMPREG_BASE,
            'n': TEMPREG_BASE,
            's': TEMPREG_BASE,
            'p': TEMPREG_BASE
        };
    }

/*
=item tempreg(rtype)

Generate a unique register by allocating from the temporary
register pool frame in %*TEMPREGS.  %*TEMPREGS is a hash that
has the next register identifier to be used for I, N, S, and
P registers.  It also contains the names of any registers
that have been "reserved" in the current frame (e.g. because
they hold the return value from a PAST::Stmt node).

If there are no temporary registers available, allocate and
return a permanent one instead (similar to C<uniquereg> above).

=cut

*/
    function tempreg[method](string rtype) {
        if (!rtype)
            return self.panic('rtype not set');
        if (rtype == 'v')
            return '';
        int i = indexof('Ss~Nn+Ii', rtype);
        rtype = 'P';
        if (i >= 0)
            rtype = substr('SSSNNNII', i, 1);
        var tempregs;
        ${ find_dynamic_lex tempregs, '%*TEMPREGS' };
        // if we don't have a temporary register pool, just make a unique one
        if (tempregs != null && tempregs) {
            int rnum = tempregs[rtype];
            // If we've run out of temporary registers, just make a unique one
            while (rnum < UNIQUE_BASE) {
                string reg = rnum++;
                tempregs[rtype] = rnum;
                reg = '$' + rtype + reg;
                if (!int(tempregs[reg]))
                    return reg;
            }
        }

        // fall back to returning a globally allocated register
        return self.unique('$' + rtype);
    }

/*
=item coerce(post, rtype)

Return a POST tree that coerces the result of C<post> to have a
return value compatible with C<rtype>.  C<rtype> can also be
a specific register, in which case the result of C<post> is
forced into that register (with conversions as needed).

=cut

*/

    function coerce[method](var post, string rtype) {
        if (!rtype)
            return self.panic('rtype note set');

        string pmctype;
        string result;
        string rrtype;

        // if rtype is a register, then set result and use the register
        // type as rtype
        if (substr(rtype, 0, 1) == '$') {
            result = rtype;
            rtype = substr(result, 1, 1);
        }

        // these rtypes allow any return value, so no coercion needed.
        if (indexof('v*:', rtype) >= 0) goto end;

        // figure out what type of result we already have
        :(string source) = post.result();
        switch (substr(source, 0, 1)) {

        case '$': // source_reg
            // source is some sort of register
            // if a register is all we need, we're done
            if (rtype == 'r') goto end;
            string s0 = substr(source, 1, 1);
            // if we have the correct register type already, we're done
            if (s0 == rtype) {
                if (!result) goto end;
                break;
            }
            s0 = downcase(s0);
            if (s0 == rtype) goto end;
            // figure it out based on the register type
            if (s0 == 's') goto source_str;
            if (rtype == '+') goto end;
            if (s0 == 'i') goto source_int;
            if (s0 == 'n') goto source_num;
        source_pmc:
            if (indexof('SINsin', rtype) < 0) goto end;
            break;

        case '"':
        source_str:
            if (rtype == '~' || rtype == 's') goto end;
            rrtype = 'S';
            pmctype = "'String'";
            break;

        case '.': // source_int_num_or_const
            if (!is_cclass(CCLASS_ALPHABETIC, source, 1))
                goto source_int_or_num;
            if (indexof('ins+~', rtype) >= 0) goto end;
            rrtype = 'P';
            break;

        case '-':
        source_int_or_num:
            if (rtype == '+') goto end;
            // existence of an 'e' or '.' implies num
            if (indexof(source, '.') >= 0) goto source_num;
            if (indexof(source, 'E') >= 0) goto source_num;

        source_int:
            if (rtype == 'i') goto end;
            rrtype = 'I';
            pmctype = "'Integer'";
            break;

        source_num:
            if (rtype == 'n') goto end;
            rrtype = 'N';
            pmctype = "'Float'";
            break;

        default:
            if (is_cclass(CCLASS_NUMERIC, source, 0))
                goto source_int_or_num;
            if (substr(source, 0, 8) == 'unicode:')
                goto source_str;
            // assume that whatever is left acts like a PMC
            goto source_pmc;
        }

        // okay, we know we have to do a coercion.
        // If we just need the value in a register (rtype == 'r'),
        // then create result based on the preferred register type (rrtype).
        if (rtype == 'r')
            result = self.tempreg(rrtype);
        // if we haven't set the result target yet, then generate one
        // based on rtype.  (The case of rtype =='r' was handled above.)
        if (!result)
            result = self.tempreg(rtype);
        // create a new ops node to hold the coersion, put C<post> in it.
        using POST.Ops;
        post = Ops.new(post, result:[named('result')]);
        // if we need a new pmc (rtype == 'P' && pmctype defined), create it
        if (rtype == 'P' && pmctype)
            post.push_pirop('new', result, pmctype);
        // store the value into the target register
        post.push_pirop('set', result, source);

    end:
        return post;
    }

/*
=item post_children(node [, 'signature'=>signature] )

Return the POST representation of evaluating all of C<node>'s
children in sequence.  The C<signature> option is a string of
flags as described in "Signature Flags" above.  Since we're
just evaluating children nodes, the first character of
C<signature> (return value type) is ignored.  Thus a C<signature>
of C<v~P*> says that the first child needs to be something
in string context, the second child should be a PMC, and the
third and subsequent children can be any value they wish.

=cut

*/
    function post_children[method]( var node, options [slurpy, named] ) {
        using POST.Ops;
        var ops = Ops.new(node:[named('node')]);

        string pushop = (node.childorder() == 'right') ? 'unshift' : 'push';

        // get any conversion types
        string signature = options['signature'];
        if (!signature) signature = '**';
        int sigmax = length(signature) - 1;

        // if the signature contains a ':', then we're doing
        // flagged arguments (:flat, :named)
        var posargs = new 'ResizableStringArray';
        var namedargs;
        if (indexof(signature, ':') >= 0)
            namedargs = new 'ResizableStringArray';

        var iter = node.iterator();
        int sigidx = 0;
        string rtype;
        while (iter) {
            if (sigidx < sigmax)
                rtype = substr(signature, ++sigidx, 1);
            var cpast = shift_var(iter);
            var cpost;
            string arg;
            if (rtype != 'Q') {
                cpost = self.as_post(cpast, rtype:[named('rtype')]);
                cpost = self.coerce(cpost, rtype);
                if (cpast instanceof PAST.Node) {
                    var isflat = cpast.flat();
                    var npast  = cpast.named();
                    arg = cpost;
                    if (rtype == ':' && npast) {
                        if (isflat) {
                            arg += ' :named :flat';
                        } else {
                            var npost = self.as_post(npast, '~':[named('rtype')]);
                            cpost = ops.new(cpost);
                            cpost.push(npost);
                            arg += ' :named(' + string(npost) + ')';
                        }
                        push(namedargs, arg);
                    } else {
                        if (isflat)
                            arg += ' :flat';
                        push(posargs, arg);
                    }
                } else {
                    push(posargs, cpost);
                }
                ops.*pushop(cpost);
            } else {
                // rtype is 'Q', so construct a keyed pmc argument
                // first, get the base PMC
                cpost = self.as_post(cpast, 'P':[named('rtype')]);
                cpost = self.coerce(cpost, 'P');
                // now process the key arg
                if (!iter) break;
                var kpast = shift_var(iter);
                rtype = substr(signature, ++sigidx, 1);
                var kpost = self.as_post(kpast, rtype:[named('rtype')]);
                kpost = self.coerce(kpost, rtype);
                // now construct the keyed PMC
                arg = string(cpost) + '[' + string(kpost) + ']';
                kpost = ops.new(kpost);
                kpost.push(cpost);
                push(posargs, arg);
                ops.*pushop(kpost);
            }
        }
        return ops, posargs, namedargs;
    }

/*

=back

=head2 Methods on C<PAST::Node> arguments

The methods below are used to transform PAST nodes into their
POST equivalents.

=head3 Defaults

=over 4

=item as_post(node) (General)

Return a POST representation of C<node>.  Note that C<post> is
a multimethod based on the type of its first argument, this is
the method that is called when no other methods match.

=item as_post(Any)

This is the "fallback" method for any unrecognized node types.
We use this to throw a more useful exception in case any non-PAST
nodes make it into the tree.

=cut

*/
    function as_post[method, multi('_','_')](var node, options [slurpy, named]) {
        if (node == null)
            return self.panic("PAST::Compiler can't compiler a null node");

        self.panic("PAST::Compiler can't compile node of type ", string(typeof(node)));
    }

/*
=item as_post(Undef)

Return an empty POST node that can be used to hold a (PMC) result.

=cut

*/
    function as_post[method, multi('_', 'Undef')](var node, options [slurpy, named]) {
        using POST.Ops;
        :(string result) = self.tempreg('P');
        return Ops.new(result:[named('result')]);
    }

/*
=item as_post(Integer)

=item as_post(Float)

=item as_post(String)

Handle Integer, Float, and String nodes in the PAST tree, by
generating a constant or an appropriate register setting.

=cut

*/
    function as_post[method, multi('_', 'Integer')](var node, options [slurpy, named]) {
        using POST.Ops;
        return self.coerce(Ops.new(node:[named('result')]), options['rtype']);
    }

    function as_post[method, multi('_', 'Float')](var node, options [slurpy, named]) {
        using POST.Ops;
        return self.coerce(Ops.new(node:[named('result')]), options['rtype']);
    }

    function as_post[method, multi('_', 'String')](var node, options [slurpy, named]) {
        using POST.Ops;
        :(string value) = self.escape(node);
        return self.coerce(Ops.new(value:[named('result')]), options['rtype']);
    }

/*
=item as_vivipost(String class)

Generate POST to create a new object of type C<class>.  This
is typically invoked by the various vivification methods below
(e.g., in a PAST::Var node to default a variable to a given type).

=cut

*/
    function as_vivipost[method, multi('_', 'String')](var node, options [slurpy, named]) {
        using POST.Op;
        :(string result)  = self.tempreg('P');
        :(string escaped) = self.escape(node);
        return Op.new(result, escaped, 'new':[named('pirop')], result:[named('result')]);
    }

/*
=item as_vivipost(PAST::Node node)

=cut

*/
    function as_vivipost[method, multi('_', '_')](var node, options [slurpy, named]) {
        return self.as_post(node, options:[flat, named]);
    }

/*
=item node_as_post(node)

Common code for as_post(PAST::Node) and as_post(PAST::Stmts)

=cut

*/
    function node_as_post[method](var node, options [slurpy, named]) {
        string rtype = options['rtype'];
        :(string signature) = node.signature();
        if (!signature)
            signature = repeat('v', elements(node.list())) + rtype;
        var ops = self.post_children(node, signature:[named('signature')]);
        var result = ops[-1];
        int i = indexof('0123456789', substr(signature, 0, 1));
        if (i >= 0)
            result = ops[i];
        ops.result(result);
        if (rtype)
            ops = self.coerce(ops, rtype);
        var eh = node.handlers();
        if (eh)
            ops = self.wrap_handlers(ops, eh, rtype:[named('rtype')]);
        return ops;
    }

/*
=item as_post(PAST::Node node)

Return the POST representation of executing C<node>'s children in
sequence.  The result of the final child is used as the result
of this node.

=cut

*/
    function as_post[method, multi('_', class PAST.Node)](var node, options [slurpy, named]) {
        // Original PIR labeled this method with subid('Node.as_post')
        return self.node_as_post(node, options:[flat, named]);
    }

/*

=back

=head3 C<PAST::Stmt>

=over 4

=item as_post(PAST::Stmt node)

Return the POST representation of a C<PAST::Stmt>.  This is
essentially the same as for C<PAST::Node> above, but also
defines the boundaries of temporary register allocations.

=cut

*/
    function as_post[method, multi('_', class PAST.Stmt)](var node, options [slurpy, named]) {
        var outerregs;
        ${ find_dynamic_lex outerregs, '%*TEMPREGS' };
        var tempregs;
        if (outerregs != null)
            tempregs = clone(outerregs);
        ${ .lex '%*TEMPREGS', tempregs };

        var post = self.node_as_post(node, options:[flat, named]);

        if (outerregs != null) {
            string rtype = options['rtype'];
            if (rtype != 'v') {
                :(string result) = post.result();
                if (substr(result, 0, 1) == '$')
                    outerregs[result] = 1;
            }
        }

        return post;
    }
}

/*

=back

*/
