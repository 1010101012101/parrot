/*
=head1 NAME

PAST::Compiler - PAST Compiler

=head1 DESCRIPTION

PAST::Compiler implements a basic compiler for PAST nodes.
By default PAST::Compiler transforms a PAST tree into POST.

=head2 Signature Flags

Throughout the compiler PAST uses a number of 1-character
"flags" to indicate allowable register types and conversions.
This helps the compiler generate more efficient code and know
what sorts of conversions are allowed (or desired).  The
basic flags are:

    P,S,I,N   PMC, string, int, or num register
    Q         keyed PMC, next flag indicates type of key
    s         string register or constant
    i         int register or constant
    n         num register or constant
    r         any register result
    v         void (no result)
    *         any result type except void
    +         PMC, int register, num register, or numeric constant
    ~         PMC, string register, or string constant
    :         argument (same as '*'), possibly with :named or :flat
    0-9       use the nth input operand as the output result of this operation

These flags are used to describe signatures and desired return
types for various operations.  For example, if an opcode is
specified with a signature of C<I~P*>, then the opcode places
its result in an int register, its first child is coerced into
some sort of string value, its second child is coerced into a
PMC register, and the third and subsequent children can return
any value type.

=cut

*/

$include_const 'cclass.pasm';
$include_const 'except_types.pasm';
$include_const 'interpinfo.pasm';

class P6metaclass;

inline is_cclass(int cclass, string str, int pos) return int {
    int ret;
    ${ is_cclass ret, cclass, str, pos };
    return ret;
}

namespace PAST.Compiler {
    // TEMPREG_BASE and UNIQUE_BASE identify the base location for
    // the temporary register set and unique registers
    const int TEMPREG_BASE = 100;
    const int UNIQUE_BASE  = 1000;

    function onload[anon, load, init]() {
        load_bytecode('PCT/HLLCompiler.pbc');
        var p6meta = new P6metaclass;
        var cproto = p6meta.new_class('PAST::Compiler', 'PCT::HLLCompiler':[named('parent')], '%!symtable':[named('attr')]);
        cproto.language('PAST');
        cproto.stages(split(' ', 'post pir evalpmc'));

        // %piropsig is a table of common opcode signatures
        var piropsig = {
            'add':        'PP+',
            'band':       'PPP',
            'bxor':       'PPP',
            'bnot':       'PP',
            'bor':        'PPP',
            'can':        'IPs',
            'chr':        'Si',
            'clone':      'PP',
            'concat':     'PP~',
            'copy':       '0PP',
            'defined':    'IP',
            'delete':     'vQ*',
            'die':        'v~',
            'div':        'PP+',
            'does':       'IPs',
            'downcase':   'Ss',
            'elements':   'IP',
            'exists':     'IQ*',
            'exit':       'vi',
            'fdiv':       'PP+',
            'find_codepoint':   'Is',
            'find_dynamic_lex': 'Ps',
            'find_name':  'Ps',
            'getinterp':  'P',
            'getprop':    'PP~',
            'getstderr':  'P',
            'getstdin':   'P',
            'getstdout':  'P',
            'index':      'Issi',
            'isa':        'IP~',
            'isfalse':    'IP',
            'isnull':     'IP',
            'issame':     'IPP',
            'istrue':     'IP',
            'join':       'SsP',
            'length':     'Is',
            'load_bytecode': 'vs',
            'load_language': 'vs',
            'loadlib':    'P~',
            'mod':        'PP+',
            'mul':        'PP+',
            'neg':        'PP',
            'new':        'P~',
            'newclosure': 'PP',
            'not':        'PP',
            'ord':        'Isi',
            'pop':        'PP',
            'pow':        'NN+',
            'print':      'v*',
            'printerr':   'v*',
            'push':       '0P*',
            'repeat':     'Ssi',
            'replace':    'Ssiis',
            'say':        'v*',
            'set':        'PP',
            'setprop':    '0P~P',
            'setattribute': '0P~P',
            'shift':      'PP',
            'shl':        'PP+',
            'shr':        'PP+',
            'sleep':      'v+',
            'splice':     '0PPii',
            'split':      'Pss',
            'sub':        'PP+',
            'substr':     'Ssii',
            'titlecase':  'Ss',
            'trace':      'vi',
            'typeof':     'SP',
            'unshift':    '0P*',
            'upcase':     'Ss'
        };
        ${ set_global '%piropsig', piropsig };

        // %valflags specifies when PAST::Val nodes are allowed to
        // be used as a constant.  The 'e' flag indicates that the
        // value must be quoted+escaped in PIR code.
        var valflags = {
            'String':   's~*:e',
            'Integer':  'i+*:',
            'Float':    'n+*:',
            '!macro_const':     'i+*:c',
            '!cclass':          'i+*:c',
            '!except_severity': 'i+*:c',
            '!except_types':    'i+*:c',
            '!iterator':        'i+*:c',
            '!socket':          'i+*:c'
        };
        ${ set_global '%valflags', valflags };

        // %!controltypes holds the list of exception types for each
        // type of exception handler we support
        var controltypes = {
            'CONTROL':  '.CONTROL_ALL',
            'RETURN':   '.CONTROL_RETURN',
            'OK':       '.CONTROL_OK',
            'BREAK':    '.CONTROL_BREAK',
            'CONTINUE': '.CONTROL_CONTINUE',
            'ERROR':    '.CONTROL_ERROR',
            'GATHER':   '.CONTROL_TAKE',
            'LEAVE':    '.CONTROL_LEAVE',
            'EXIT':     '.CONTROL_EXIT',
            'NEXT':     '.CONTROL_NEXT',
            'LAST':     '.CONTROL_LAST',
            'REDO':     '.CONTROL_REDO'
        };
        ${ set_global '%!controltypes', controltypes };

        ${ set_global '$!serno', var(UNIQUE_BASE) };

        return;
    }

/*
=head2 Compiler methods

=over 4

=item to_post(node [, 'option'=>option, ...])

Compile the abstract syntax tree given by C<past> into POST.

=cut

*/

    function to_post[method](var past, options [slurpy, named]) {
        self.*'%!symtable' = {};

        var blockpast;
        ${ get_global blockpast, '@?BLOCK' };
        if (blockpast == null) {
            blockpast = [];
            ${ set_global '@?BLOCK', blockpast };
        }
        ${ .lex '@*BLOCKPAST', blockpast };
        var sub;
        ${ .lex '$*SUB', sub };
        var lexregs;
        ${ .lex '%*LEXREGS', lexregs };

        var tempregs;
        ${ find_dynamic_lex tempregs, '%*TEMPREGS' };
        if (tempregs == null)
            tempregs = self.tempreg_frame();
        ${ .lex '%*TEMPREGS', tempregs };

        var ret = self.as_post(past, 'v':[named('rtype')]);
        return ret;
    }

/*
=item escape(str)

Return C<str> as a PIR constant string.

=cut

*/

    function escape[method](string str) {
        string estr = Winxed_Builtins.escape(str);
        if (indexof(estr, "\\x") >= 0 || indexof(estr, "\\u") >= 0)
            estr = 'unicode:"' + estr;
        else
            estr = '"' + estr;
        estr += '"';
        return estr;
    }

/*
=item unique([STR fmt])

Generate a unique number that can be used as an identifier.
If C<fmt> is provided, then it will be used as a prefix to the
unique number.

=cut

*/
    function unique[method](string fmt [optional], int has_fmt [opt_flag]) {
        if (!has_fmt)
            fmt = '';
        var serno;
        ${ get_global serno, '$!serno' };
        string ret = fmt + string(serno);
        ++serno;
        return ret;
    }

/*
=item uniquereg(rtype)

Generate a unique register based on C<rtype>, where C<rtype>
is one of the signature flags described above.

=cut

*/
    function uniquereg[method](string rtype) {
        if (!rtype)
            return self.panic('rtype not set');
        if (rtype == 'v')
            return '';
        int i = indexof('Ss~Nn+Ii', rtype);
        rtype = 'P';
        if (i >= 0)
            rtype = substr('SSSNNNII', i, 1);
        return self.unique('$' + rtype);
    }

/*
=item tempreg_frame()

Create a new temporary register frame, using register
identifiers TEMPREG_BASE up to UNIQUE_BASE.

=cut

*/
    function tempreg_frame[method]() {
        return {
            'i': TEMPREG_BASE,
            'n': TEMPREG_BASE,
            's': TEMPREG_BASE,
            'p': TEMPREG_BASE
        };
    }

/*
=item tempreg(rtype)

Generate a unique register by allocating from the temporary
register pool frame in %*TEMPREGS.  %*TEMPREGS is a hash that
has the next register identifier to be used for I, N, S, and
P registers.  It also contains the names of any registers
that have been "reserved" in the current frame (e.g. because
they hold the return value from a PAST::Stmt node).

If there are no temporary registers available, allocate and
return a permanent one instead (similar to C<uniquereg> above).

=cut

*/
    function tempreg[method](string rtype) {
        if (!rtype)
            return self.panic('rtype not set');
        if (rtype == 'v')
            return '';
        int i = indexof('Ss~Nn+Ii', rtype);
        rtype = 'P';
        if (i >= 0)
            rtype = substr('SSSNNNII', i, 1);
        var tempregs;
        ${ find_dynamic_lex tempregs, '%*TEMPREGS' };
        // if we don't have a temporary register pool, just make a unique one
        if (tempregs != null && tempregs) {
            int rnum = tempregs[rtype];
            // If we've run out of temporary registers, just make a unique one
            while (rnum < UNIQUE_BASE) {
                string reg = rnum++;
                tempregs[rtype] = rnum;
                reg = '$' + rtype + reg;
                if (!int(tempregs[reg]))
                    return reg;
            }
        }

        // fall back to returning a globally allocated register
        return self.unique('$' + rtype);
    }

/*
=item coerce(post, rtype)

Return a POST tree that coerces the result of C<post> to have a
return value compatible with C<rtype>.  C<rtype> can also be
a specific register, in which case the result of C<post> is
forced into that register (with conversions as needed).

=cut

*/

    function coerce[method](var post, string rtype) {
        if (!rtype)
            return self.panic('rtype note set');

        string pmctype;
        string result;
        string rrtype;

        // if rtype is a register, then set result and use the register
        // type as rtype
        if (substr(rtype, 0, 1) == '$') {
            result = rtype;
            rtype = substr(result, 1, 1);
        }

        // these rtypes allow any return value, so no coercion needed.
        if (indexof('v*:', rtype) >= 0) goto end;

        // figure out what type of result we already have
        :(string source) = post.result();
        switch (substr(source, 0, 1)) {

        case '$': // source_reg
            // source is some sort of register
            // if a register is all we need, we're done
            if (rtype == 'r') goto end;
            string s0 = substr(source, 1, 1);
            // if we have the correct register type already, we're done
            if (s0 == rtype) {
                if (!result) goto end;
                break;
            }
            s0 = downcase(s0);
            if (s0 == rtype) goto end;
            // figure it out based on the register type
            if (s0 == 's') goto source_str;
            if (rtype == '+') goto end;
            if (s0 == 'i') goto source_int;
            if (s0 == 'n') goto source_num;
        source_pmc:
            if (indexof('SINsin', rtype) < 0) goto end;
            break;

        case '"':
        source_str:
            if (rtype == '~' || rtype == 's') goto end;
            rrtype = 'S';
            pmctype = "'String'";
            break;

        case '.': // source_int_num_or_const
            if (!is_cclass(CCLASS_ALPHABETIC, source, 1))
                goto source_int_or_num;
            if (indexof('ins+~', rtype) >= 0) goto end;
            rrtype = 'P';
            break;

        case '-':
        source_int_or_num:
            if (rtype == '+') goto end;
            // existence of an 'e' or '.' implies num
            if (indexof(source, '.') >= 0) goto source_num;
            if (indexof(source, 'E') >= 0) goto source_num;

        source_int:
            if (rtype == 'i') goto end;
            rrtype = 'I';
            pmctype = "'Integer'";
            break;

        source_num:
            if (rtype == 'n') goto end;
            rrtype = 'N';
            pmctype = "'Float'";
            break;

        default:
            if (is_cclass(CCLASS_NUMERIC, source, 0))
                goto source_int_or_num;
            if (substr(source, 0, 8) == 'unicode:')
                goto source_str;
            // assume that whatever is left acts like a PMC
            goto source_pmc;
        }

        // okay, we know we have to do a coercion.
        // If we just need the value in a register (rtype == 'r'),
        // then create result based on the preferred register type (rrtype).
        if (rtype == 'r')
            result = self.tempreg(rrtype);
        // if we haven't set the result target yet, then generate one
        // based on rtype.  (The case of rtype =='r' was handled above.)
        if (!result)
            result = self.tempreg(rtype);
        // create a new ops node to hold the coersion, put C<post> in it.
        using POST.Ops;
        post = Ops.new(post, result:[named('result')]);
        // if we need a new pmc (rtype == 'P' && pmctype defined), create it
        if (rtype == 'P' && pmctype)
            post.push_pirop('new', result, pmctype);
        // store the value into the target register
        post.push_pirop('set', result, source);

    end:
        return post;
    }
}

/*

=back

*/
