/*
=head1 NAME

PAST - Parrot abstract syntax tree

=head1 DESCRIPTION

This file implements the various abstract syntax tree nodes
for compiling programs in Parrot.

=cut

*/

class P6metaclass;
class PAST.Node;
class PAST.Op;
class PAST.Stmts;
class PAST.Stmt;
class PAST.Val;
class PAST.Var;
class PAST.Block;
class PAST.Control;
class PAST.VarList;

namespace PAST.Node {
    function onload[anon, load, init]() {
        var p6meta = new P6metaclass;
        var base = p6meta.new_class('PAST::Node', 'PCT::Node':[named('parent')]);

        p6meta.new_class('PAST::Op', base:[named('parent')]);
        p6meta.new_class('PAST::Stmts', base:[named('parent')]);
        p6meta.new_class('PAST::Stmt', base:[named('parent')]);
        p6meta.new_class('PAST::Val', base:[named('parent')]);
        p6meta.new_class('PAST::Var', base:[named('parent')]);
        p6meta.new_class('PAST::Block', base:[named('parent')]);
        p6meta.new_class('PAST::Control', base:[named('parent')]);
        p6meta.new_class('PAST::VarList', base:[named('parent')]);

        return;
    }

/*
=head1 PAST Node types

=head2 PAST::Node

C<PAST::Node> is the base class for all PAST nodes, and is
derived from PCT::Node.  A node has an array component to
hold its children, and a hash component for its attributes.
However, we tend to use accessor methods for accessing the node's
attributes instead of accessing the hash directly.

Every PAST node inherits C<name>, C<source>, and C<pos> attributes
from C<PCT::Node>.  The C<name> attribute is the node's name, if
any, while C<source> and C<pos> are used to identify the location
in the original source code for the node.  The C<source> and C<pos>
values are generally set by the C<node> method inherited from
C<PCT::Node>.

Other node attributes are generally defined by subclasses of C<PAST::Node>.

=over 4

=item returns([value])

Accessor method -- sets/returns the return type for the invocant.

=cut

*/

    function returns[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('returns', value, has_value);
    }

/*
=item arity([value])

Accessor method -- sets/returns the arity (number of expected arguments)
for the node.

=cut

*/

    function arity[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('arity', value, has_value);
    }

/*
=item named([value])

Accessor method -- for named arguments, sets/returns the name to be
associated with the argument.

=cut

*/

    function named[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('named', value, has_value);
    }

/*
=item flat([value])

Accessor method -- sets/returns the "flatten" flag on arguments.

=cut

*/

    function flat[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('flat', value, has_value);
    }

/*
=item handlers([node array])

Accessor method -- sets/returns handlers associated with this node.
Handlers can be used for PAST::Block and PAST::Stmts nodes.

=cut

*/

    function handlers[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('handlers', value, has_value);
    }

/*
=item handle_types([value])

Accessor method -- sets/returns the exception types this node
handles. This is evaluated if the node is used as a block
handler, the node is a PAST::Control node, or the node is
a PAST::Op node of type 'try'.

=cut

*/

    function handle_types[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('handle_types', value, has_value);
    }

/*
=item handle_types_except([value])

Accessor method -- sets/returns the exception types this node
does not handle. Same as handle_types, but all exceptions not
matching the specified ones will be caught.

=cut

*/

    function handle_types_except[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('handle_types_except', value, has_value);
    }

/*
=item lvalue([flag])

Get/set the C<lvalue> attribute, which indicates whether this
variable is being used in an lvalue context.

=cut

*/

    function lvalue[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('lvalue', value, has_value);
    }

/*
=item signature([signature])

Get/set the signature to be used for evaluating any
children nodes.

=cut

*/

    function signature[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('signature', value, has_value);
    }

/*
=item childorder([order])

Get/set the order in which children nodes should be evaluated
(via Compiler::post_children).  If C<order> is 'right' then
children are evaluated last-to-first, otherwise they're
evaluated first-to-last.

=cut

*/

    function childorder[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('childorder', value, has_value);
    }
}

namespace PAST.Val {
/*

=back

=head2 PAST::Val

C<PAST::Val> nodes represent constant values in the abstract
syntax tree.  The C<name> attribute represents the value of the
node.

=over 4

=item value([value])

Get/set the constant value for this node.

=cut


*/

    function value[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('value', value, has_value);
    }

/*
=item lvalue([value])

Throw an exception if we try to make a PAST::Val into an lvalue.

=cut

*/

    function lvalue[method](var value [optional], int has_value [opt_flag]) {
        if (has_value && value)
            die('Unable to set lvalue on PAST::Val node');
        return self.attr('lvalue', value, has_value);
    }
}

namespace PAST.Var {
/*

=back

=head2 PAST::Var

C<PAST::Var> nodes represent variables within the abstract
syntax tree.  The variable name (if any) is given as the node's
C<name> attribute.

=over 4

=item scope([value])

Get/set the PAST::Var node's "scope" (i.e., how the variable
is accessed or set).  Allowable values include "package", "lexical",
"parameter", "keyed", "attribute" and "register", representing
HLL global, lexical, block parameter, array/hash variables, object
members and (optionally named) Parrot registers respectively.

=cut

*/

    function scope[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('scope', value, has_value);
    }

/*
=item isdecl([flag])

Get/set the node's C<isdecl> attribute (for lexical variables) to C<flag>.
A true value of C<isdecl> indicates that the variable given by
this node is to be created within the current lexical scope.
Otherwise, the node refers to a lexical variable from an outer scope.

=cut

*/

    function isdecl[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('isdecl', value, has_value);
    }

/*
=item directaccess([flag])

Get/set the node's C<directaccess> attribute (for lexical variables) to C<flag>.
A true value of C<isdecl> indicates that the variable given by this node
can be accessed directly through the assigned register without going
through the lexpad. Otherwise, find_lex/store_lex instructions will be used
for retrieval and storage.

=cut

*/

    function directaccess[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('directaccess', value, has_value);
    }

/*
=item namespace([namespace])

Get/set the variable's namespace attribute to the array of strings
given by C<namespace>.  Useful only for variables with a C<scope>
of 'package'.

=cut

*/

    function namespace[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('namespace', value, has_value);
    }

/*
=item slurpy([flag])

Get/set the node's C<slurpy> attribute (for parameter variables) to C<flag>.
A true value of C<slurpy> indicates that the parameter variable given by this
node is to be created as a slurpy parameter (consuming all remaining arguments
passed in).

=cut

*/

    function slurpy[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('slurpy', value, has_value);
    }

/*
=item call_sig([flag])

Get/set the node's C<call_sig> attribute (for parameter variables) to C<flag>.
A true value of C<call_sig> indicates that the parameter variable given by this
node is to be created as a C<:call_sig> parameter. If you use this, it should be
the only parameter.

=cut

*/

    function call_sig[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('call_sig', value, has_value);
    }

/*
=item viviself([type])

If the variable needs to be instantiated, then C<type> indicates
either the type of the value to create for the node or (future
implementation) a PAST tree to create the value.

=cut

*/

    function viviself[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('viviself', value, has_value);
    }

/*
=item vivibase([type])

For keyed nodes, C<type> indicates the type of aggregate to
create for the base if the base doesn't specify its own 'viviself'
attribute.

=cut

*/

    function vivibase[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('vivibase', value, has_value);
    }

/*
=item multitype([type])

Get/set MMD type of Var when used as parameter of Block.

=cut

*/

    function multitype[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('multitype', value, has_value);
    }
}

namespace PAST.Op {
/*

=back

=head2 PAST::Op

C<PAST::Op> nodes represent the operations in an abstract syntax
tree.  The primary function of the node is given by its C<pasttype>,
secondary functions may be given by the node's C<name>, C<pirop>,
or other attributes.

=over 4

=item pasttype([type])

A C<PAST::Op> node's C<pasttype> determines the type of operation to
be performed.  Predefined values of C<pasttype> are:

assign     - Copy the value of the node's second child into
             the variable expression given by its first child.

bind       - Bind the variable given by the node's first child
             to the value given by its second child.

if         - Evaluate the first child; if the first child is
             true then evaluate the second child (if any)
             otherwise evaluate the third child (if any).
             If either the second or third child are missing,
             then they evaluate as the result of the first child.

unless     - Same as 'if' above, but reverse the evaluation
             of the second and third children nodes.

while      - Evaluate the first child, if the result is
             true then evaluate the second child and repeat.

until      - Evaluate the first child, if the result is
             false then evaluate the second child and repeat.

for        - Iterate over the first child. For each element,
             invoke the sub in the second child, passing the
             element as the only parameter.

call       - Call a subroutine, passing the results of any
             child nodes as arguments.  The subroutine to be
             called is given by the node's C<name> attribute,
             if the node has no C<name> attribute then the
             first child is assumed to evaluate to a callable
             sub.

pirop      - Execute the named PIR opcode, passing the results
             of any children nodes as arguments.

inline     - Execute the sequence of PIR statements given
             by the node's C<inline> attribute (a string).
             See the C<inline> method below for details.

callmethod - Invokes a method on an object, using children
             nodes as arguments.  If the node has a C<name>
             attribute, then the first child is the invocant
             and any remaining children are arguments.  If
             the node doesn't have a C<name> attribute, then
             the first child evaluates to the method to be
             called, the second child is the invocant, and
             the remaining children are arguments to the method call.

try        - (preliminary) Execute the code given by the first
             child, and if any exceptions occur then handle them
             using the code given by the second child.

If a node doesn't have a value set for C<pasttype>, then it
assumes "pirop" if its C<pirop> attribute is set, otherwise it
assumes "call".

=cut

*/

    function pasttype[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('pasttype', value, has_value);
    }

/*
=item pirop([opcode])

Get/set the PIR opcode to be executed for this node.  The PAST
implementation knows about the argument types for many of the
PIR opcodes, and will try to automatically convert the results
of any children nodes into the correct types if needed.  (In
general, the implementation tries to convert things to PMCs
whenever it isn't certain what else to do.)  The table of
PIR opcodes that PAST "knows" about is in F<POST.pir>.

=cut

*/

    function pirop[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('pirop', value, has_value);
    }

/*
=item lvalue([flag])

Get/set whether this node is an lvalue, or treats its first
child as an lvalue (e.g., for assignment).

=item inline([STRING code])

Get/set the code to be used for inline PIR when C<pasttype> is
"inline".  The C<code> argument is PIR text to be inserted in
the final generated code sequence.  Sequences of "%0", "%1",
"%2", ... "%9" in C<code> are replaced with the evaluated
results of the first, second, third, ..., tenth children nodes.
(If you need more than ten arguments to your inline PIR, consider
making it a subroutine call instead.)

The register to hold the result of the inline PIR operation is
given by "%r", "%t", or "%u" in the C<code> string:

  %r   - Generate a unique PMC register for the result.
  %t   - Generate a unique PMC register for the result,
         and initialize it with an object of type C<returns>
         before the execution of the inline PIR.
  %u   - Re-use the first child's PMC (%0) if it's a temporary
         result, otherwise same as %t above.
  %v   - (void) Re-use the first child's PMC (%0) as the result
         of this operation.

=cut

*/

    function inline[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('inline', value, has_value);
    }

/*
=item opattr(hash)

Set a variety of C<PAST::Op> attributes based on entries
in C<hash>.  Typically C<hash> is an entry in the operator
precedence table, and the attributes being set correspond
to traits in the grammar.

=cut

*/

    function opattr[method](var hash) {
        for (string key in split(' ', "pasttype pirop inline lvalue")) {
            var value = hash[key];
            if (value != null)
                self.*key(value);
        }
    }
}

/*

=back

=head2 PAST::Stmt

C<PAST::Stmt> encapsulates sequence points within a program, particularly
with respect to allocation and use of temporary registers.

=head2 PAST::Stmts

C<PAST::Stmts> is a container of C<PAST::Node> without any specific methods.

=head2 PAST::Block

C<PAST::Block> nodes represent lexical scopes within an abstract
syntax tree, and roughly translate to individual Parrot subroutines.
A C<PAST::Block> node nested within another C<PAST::Block> node
acts like a nested lexical scope.

If the block has a C<name> attribute, that becomes the name of
the resulting Parrot sub, otherwise a unique name is automatically
generated for the block.

=over 4

=item blocktype([STRING type])

Get/set the type of the block.  The currently understood values
are 'declaration', 'immediate', and 'method'.  'Declaration' indicates
that a block is simply being defined at this point, while
'immediate' indicates a block that is to be immediately
executed when it is evaluated in the AST (e.g., the immediate
blocks in Perl6 C<if>, C<while>, and other similar statements).

=cut

*/

namespace PAST.Block {

    function blocktype[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('blocktype', value, has_value);
    }

/*
=item closure([value])

Get/set the closure flag for the block to C<value>.  If set,
any block reference returned by the node is to a clone of the
block that has captured the current lexical context.

=cut

*/

    function closure[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('closure', value, has_value);
    }

/*
=item control([value])

Get/set the control exception handler for this block to C<value>.
The exception handler can be any PAST tree.  The special (string)
value "return_pir" generates code to handle C<CONTROL_RETURN> exceptions.

=cut

*/

    function control[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('control', value, has_value);
    }

/*
=item loadinit([past])

Get/set the "load initializer" for this block to C<past>.
The load initializer is a set of operations to be performed
as soon as the block is compiled/loaded.  For convenience,
requests to C<loadinit> autovivify an empty C<PAST::Stmts>
node if one does not already exist.

Within the load initializer, the C<block> PMC register is
automatically initialized to refer to the block itself
(to enable attaching properties, adding the block as a method,
storing in a symbol table, etc.).

=cut

*/

    function loadinit[method](var value [optional], int has_value [opt_flag]) {
        if (!has_value && !exists self['loadinit']) {
            using PAST.Stmts;
            value = Stmts.new();
            has_value = 1;
        }
        return self.attr('loadinit', value, has_value);
    }

/*
=item namespace([namespace])

Get/set the namespace for this block.  The C<namespace> argument
can be either a string or an array of strings.

=cut

*/

    function namespace[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('namespace', value, has_value);
    }

/*
=item multi([multi])

Get/set the multi signature for this block.  The C<multi> argument
can be either a string or an array of strings.

=cut

*/

    function multi[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('multi', value, has_value);
    }

/*
=item hll([hll])

Get/set the C<hll> for this block.

=cut

*/

    function hll[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('hll', value, has_value);
    }

/*
=item loadlibs([lib1, lib2, ...])

Get/set the libraries to be loaded at startup. EXPERIMENTAL (not subject to
deprecation policy, yet).

=cut

*/

    function loadlibs[method](var libs [slurpy]) {
        int has_value = elements(libs);
        return self.attr('loadlibs', libs, has_value);
    }

/*
=item nsentry([nsentry])

Get/set the C<nsentry> for this block.

=cut

*/

    function nsentry[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('nsentry', value, has_value);
    }

/*
=item symbol(name [, attr1 => val1, attr2 => val2, ...])

If called with named arguments, sets the symbol hash corresponding
to C<name> in the current block.  The HLL is free to select
any symbol attributes desired, although the 'scope' attribute
is typically used to assist with lexical scoping of PAST::Var
nodes.

If no named arguments are given, returns the current
attribute hash for symbol C<name>.

=cut

*/

    function symbol[method](string name, attr [slurpy, named]) {
        var symtable = self['symtable'];
        if (symtable == null)
            self['symtable'] = symtable = {};

        var symbol = symtable[name];
        if (symbol == null) {
            if (attr)
                symtable[name] = attr;
            return attr;
        }

        for (string key in attr)
            symbol[key] = attr[key];
        return symbol;
    }

/*
=item symbol_defaults([attr1 => val1, attr2 => val2, ... ])

Set default attributes for non-existent symbols in the
symbol hash (see C<symbol> above).  If no named arguments
are given, returns the default attribute hash itself.

Currently we just use the '' entry of the symbol hash to
store the default attributes, but it's probably not safe
to rely on this behavior in the future.

=cut

*/

    function symbol_defaults[method](attr [slurpy, named]) {
        return self.symbol('', attr:[flat, named]);
    }

/*
=item symtable([value])

Get/set the symbol table for the block.  May be deprecated in
favor of the C<symbol> method above.

=cut

*/

    function symtable[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('symtable', value, has_value);
    }

/*
=item lexical([flag])

Get/set whether the block is lexically nested within
the block that contains it.

=cut

*/

    function lexical[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('lexical', value, has_value, 1);
    }

/*
=item compiler([name])

Indicate that the children nodes of this block are to be
compiled using compiler C<name> instead of the standard
PAST compiler.

=cut

*/

    function compiler[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('compiler', value, has_value);
    }

/*
=item compiler_args()

Specify named arguments to be passed to the compiler set
through the compiler attribute. Not used if compiler is
not set.

=cut

*/

    function compiler_args[method](value [named, slurpy]) {
        int has_value = elements(value);
        return self.attr('compiler_args', value, has_value);
    }

/*
=item subid([subid])

If C<subid> is provided, then sets the subid for this block.
Returns the current subid for the block, generating a unique
subid for the block if one does not already exist.

=cut

*/

    function subid[method](var value [optional], int has_value [opt_flag]) {
        if (!has_value && !exists self['subid']) {
            value = self.unique();
            var suffix;
            ${ get_global suffix, '$!subid_suffix' };
            if (suffix == null) {
                suffix = '_' + string(time());
                ${ set_global '$!subid_suffix', suffix };
            }
            value = string(value) + string(suffix);
            has_value = 1;
        }

        return self.attr('subid', value, has_value);
    }

/*
=item pirflags([pirflags])

Get/set any pirflags for this block.

=cut

*/

    function pirflags[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('pirflags', value, has_value);
    }

/*
=item tempregs([tempregs])

Get/set whether this block is allowed to create a fresh
bank of temporary registers.  Default is disabled -- i.e.,
the block uses the same temporary register bank as its
outer statement.

=cut

*/

    function tempregs[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('tempregs', value, has_value);
    }
}

namespace PAST.VarList {

    function bindvalue[method](var value [optional], int has_value [opt_flag]) {
        return self.attr('bindvalue', value, has_value);
    }

}

/*

=back

=head1 AUTHOR

Patrick Michaud <pmichaud@pobox.com> is the author and maintainer.
Please send patches and suggestions to the Parrot porters or
Perl 6 compilers mailing lists.

Converted to Winxed by Brian Gernhardt <brian@gernhardtsoftware.com>

=head1 HISTORY

2006-11-20  Patrick Michaud added first draft of POD documentation.
2007-11-21  Re-implementation with pdd26 compliance, compiler toolkit
2012-04-24  Converted to Winxed

=head1 COPYRIGHT

Copyright (C) 2006-2012, Parrot Foundation.

=cut

*/
