# Copyright (C) 2011, Parrot Foundation.

=head1 PDD 32: M0 Design Spec

=head2 Abstract

This document specifies M0, the set of microcode-like opcodes (ops) on which
a future implementation of Parrot internals will be based. This document
also specifies how these ops will interact with other subsystems and their
requisite runtime environment.

=head2 Status

This document is a draft under active development.  Nothing is set in stone
yet.  If you would like to suggest improvements, please talk with cotto,
bacek, atrodo or dukeleto.

=head2 M0 Milestones

This is a list of things that we expect the M0 VM to be able to do as this
spec progresses.  They're pretty basic, but that's the idea behind M0.

Completed milestones:

=over

=item * print 42 (hard-coded instructions are fine at this point)

=item * assemble an M0 assembly listing into M0 bytecode

=item * print "hello, world\n"

=item * add two integer registers, store the result

=back

Incomplete milestones:

=over

=item * calculate the hash of a hard-coded string (any non-trivial algorithm)

=item * call a function with an argument, return a value

=item * calculate the sum of a 10-element array of ints

=item * disassemble binary M0 bytecode into an M0 assembly listing

=back

=head2 Definitions

=over

=item * M0

C<M0> refers to the specification for a minimal virtual machine capable of
executing the ops described in this document.  The M0 VM should have the same
expressive power as C and will live at the same level that C currently does.
This means that M0 explicitly does not need to know about higher-level concepts
such as garbage collection and Parrot's calling conventions.

=item * M0 ops

This is the lowest-level set of ops supported by an M0-compliant VM.  These
ops are a subset of the C<M0> specification.

=item * chunk

A chunk is a self-contained unit of code.  Chunks correspond roughly to
functions and have a constants table, a metadata segment and a bytecode
segment.  The constants table is used to store any persistent data.  The
metadata segment stores information about the code, for example annotations or
variable names.  The bytecode segment contains the executable ops.

=item * MOP

Meta object protocol.

=item * Lorito

Lorito refers to C<M0> and the levels above it, such as C<M1> which is written
in C<M0> ops, and possibily an C<M2> level which is written in C<M1> ops. More
specifically it refers to a new implementation of Parrot internals. A new MOP
is planned for Lorito and it will most probably live at the C<M1> op level.

=item * Call Frame

This refers to an M0 call frame structure, which is the central datastructure
at the M0 level.  A call frame contains all the state of an executing chunk,
including PC, active exception handlers, INSP registers, parent call frame and
so forth.  When M0 code implements continuation-passing style, the call frame
is what acts as the continuation.

=back

=head2 Design Goals

There are three goals that M0 needs to meet:

=over

=item 1

Have executable code with equivalent power to C.

=item 2

Have a form of code that can be easily analyzed.

=item 3

Have a single form of code used to implement the majority of Parrot, rather
than having a mix of C and PIR.

=back

We are also designing M0 to be as simple as possible.  M0 should contain as few
ops as are needed to retain the ability to generate efficient bytecode.  The
complexity of Parrot will be built on top of M0, in PIR (a.k.a. M1) and above.
This simplicity exists to facilitate multiple implementations, e.g. a quick and
dirty prototype implementation in JavaScript, a space-optimized implementation
targeted for mobile devices, an adaptively-optimizing jit targeted for server
use, etc.  M0's simplicity should be extreme; the moment M0 gets ops for the
sake of developer efficiency or ease of use, it has failed its design goals.

There will be no stacks in M0, not even for argument passing. All internal
control flow apart from basic gotos with code segments must be in
continuation-passing style.  This will give M0-based code several benefits.  It
will ensure immunity from stack-smashing attacks and related programming
errors.  It will also eliminate the nested (inferior) runloop problem and opens
up interesting possibilities for an Erlang-like concurrency implementation.

CPS will also allow Parrot to use many pre-existing JIT algorithms, such
as those described in the paper "Trace Based Compilation in Interpreter-less
Execution Environments" [TBC].

=head2 Scope of This Document

This document only covers M0 and the minimum VM necessary to support it.
Anything beyond that, e.g. the meta-object model or in-memory layout of call
frames, is beyond its scope.

=head2 Call Frames

This is the central data structure at the M0 level.  The call frame graph
contains most of the state that is needed to execute M0 bytecode.  A pointer to
the current call frame will be passed to each op as the implicit first
argument, though this pointer (or equivalent) will not be stored in bytecode.
It layout is described in detail in the C<Register Types and Call Frame
Structure> section.

Call frames were previously referred to as contexts.  The name "call frame" was
chosen to better reflect common usage and hopefully reduce confusion.

=head2 Registers

An M0 VM has 256 registers, each of which is large enough to hold an INSP value.

=head2 List of Ops

M0 ops are very low-level and provide the simplest possible way of interacting
with the VM.  Apart from print/gripe/say (which are intended only for the early
stages of an M0 VM's development), M0 ops should painfully minimal.  It's
expected that common operations will be painful.  That's what compilers are
for.

The names and number of the ops below may change at any time, possibly without
any rational reason, until the spec is more stable.  As a way to verify that
the op set is complete, we will look at how a representative selection of PIR's
existing core ops and the dynops used by HLLs could be reimplemented in terms
of M0 ops.

In descriptions, C<$1> refers to the value of the first argument to an op,
C<$2> to the second and C<$3> to the third.  Any op can operate on any
register; types are only by convention.  As far as an M0 VM is conerned, the
256 ops are nothing more than an array of 256 opcode_t-sized chunks of data.

Note that this documentation uses a C-like syntax to differentiate between a
register's number and the value pointed to by the regster. C<$1> refers to a
register's value C<*$1> refers to what a register points at.

Ops tend to be consistent in the way they use registers.  When applicable,
C<*$1> is used as the destination, C<*$2> is used as the first argument and
C<*$2> is used as the second argument or modifier.

=head3 Control Flow (4 ops)

=over

=item * noop - do nothing

Explicitly do nothing.  C<$1>, C<$2> and C<$3> are ignored.

=item * goto - go to a fixed offset in the current bytecode segment

Unconditionally transfer control flow to a fixed offset within the current
bytecode segment.  The target address is calculated as 256 * C<$1> + C<$*2>.
C<$3> is ignored.

=item * goto_if - conditionally go to a fixed offset in the current bytecode segment

Transfer control flow to a fixed offset within the current bytecode segment if
C<*$3> is non-zero when treated as an integer.  As with C<goto>, the target
address is calculated as 256 * C<*$1> + C<*$2>.

=item * goto_chunk - go to an offset in another chunk

Unconditionally transfer control flow to a fixed offset within another chunk's
bytecode segment.  The target address is calculated as 256 * C<$1> + C<$*2>.
C<*$3> is the name of the target chunk.

=back

=head3 Math/numeric ops (12 ops)

=over

=item * add_i - integer addition

=item * add_n - add two numeric registers

Treat C<*$2> and C<*$3> as integer or floating-point values, add them and store
the result in C<*$1>.

=item * sub_i - subtract two integer registers

=item * sub_n - subtract two numeric registers

Treat C<*$2> and C<*$3> as integer or floating-point values, subtract C<*$3>
from C<*$2> and store the result in C<*$1>.

=item * mult_i - multiply two integer registers

=item * mult_n - multiply two numeric registers

Treat C<*$2> and C<*$3> as integer or floating-point values, multiply C<*$1> by
C<*$3> and store the result in C<*$1>.

=item * div_i - divide two integer registers

=item * div_n - divide two numeric registers

Treat C<*$2> and C<$*2> as integer or floating-point values, divide C<$*1> by
C<$*2> and store the result in C<$*0>.

=item * mod_i - remainder of of $3/$2 (integer)

=item * mod_n - remainder of of $3/$2 (numeric)

Treat C<*$2> and C<*$3> as integer or floating-point values, divide C<*$1> by
C<*$3> and store the remainder in C<*$1>.  Division by zero will make the the
M0 interpreter sad.

=item * nfromi - convert to numeric from integer

Assume that C<*$2> is an integer value, convert it to a floating-point value
and store the result in C<*$1>.  C<$3> is ignored.

{{{
    TODO: Define the semantics of C<nfromi> and C<ifromn> more completely.
    They're pretty underdefined as it stands now.
}}}

=item * ifromn - convert to integer from numeric

Assume that C<*$2> is a floating-point value, convert it to an integer value
and store the result in C<*$1>.  C<$3> is ignored.

=back

=head3 Bitwise ops (6 ops)

=over

=item * ashr - right bitshift with sign extension

Shift the value in C<*$2> right by the number of bits in C<*$3>, with sign
extension, and store the result in C<*$1>.

=item * lshr - right bitshift without sign extension

Shift the value in C<*$2> right by the number of bits in C<$*2>, without sign
extension, and store the result in C<$*0>.

=item * shl - left bitshift

Shift the value in C<*$2> left by the number of bits in C<*$3> and store the
result in C<*$1>.

=item * and - bitwise AND

Store C<*$2> & C<*$3> into C<*$1>.

=item * or - bitwise OR

Store C<*$2> | C<*$3> into C<*$1>.

=item * xor - bitwise exclusive OR

Store C<*$2> ^ C<*$3> into C<*$1>.

=back

=head3 Memory/GC ops (4 ops)

=over

=item * gc_alloc - allocate memory from the GC

Allocate C<*$2> bytes, store the pointer C<*$1>.  C<*$3> contains flags
indicating any special properties required of the returned chunk of memory.  A
pointer returned by C<gc_alloc> does not need to be freed.
{{{
    TODO: define what flags are valid for C<*$3> and what criteria exist for
    adding new ones
}}}

=item * sys_alloc - allocate memory using malloc or its equivalent

Allocate C<*$2> bytes, store the pointer C<*$1>.  C<$3> is ignored.  The
pointer returned by C<sys_alloc> must be released with C<sys_free> to avoid
memory leaks.  This is a direct interface to the underlying implementation's
C<malloc()> implementation (or equivalent) and does not go through ffi.

=item * sys_free - free memory using free() or its equivalent

Free the region of memory which C<*$1> points at.  C<$2> and C<$3> are ignored.
This is a direct interface to the underlying implementation's C<free()>
implementation (or equivalent) and does not go through ffi.

=item * copy_mem - copy data to/from memory

Write C<*$3> bytes from the memory location starting at C<*$2> to C<*$1>.
Segfaults may result.  Be careful.

=back

=head3 Register ops (3)

=item * set - set a register to a value

Set C<*$1> to whatever is in C<*$2>.  C<$3> is ignored.

=item * set_imm - set a register to a hard-coded value from the bytecode stream

Set C<*$1> to C<$2> * 256 +  C<$3>.

=item * deref - dereference a register

Treat C<*$3> as index and C<*$2> as a register set.  Set C<*$1> to the value at
address C<*$2> + C<*$3>.

=back

=head3 FFI ops (4 ops)

=over

=item * csym - look up a function by name

Look up the function pointer for using the name in C<*$2> in the C function
namespace and put the pointer into C<*$1>.  C<$3> is ignored.  C<*$2> is assumed
to point at a C string.

Note that this function wraps the C<csym> C function.  Use it to access
C<Parrot_dlopen> and C<Parrot_dlsym> to deal wih dynamic libraries.

=item * ccall_arg - set an argument for a ccall

Take two arguments: an argument type in C<*$1> and an argument source in C<$2>.
C<*$1> is an immediate constant indicating the type of the argument.  The
possible values of C<*$1> will be similar to those used by libffi
(https://github.com/atgreen/libffi/blob/master/doc/libffi.info ).  C<$2>
indicates which M0 register should be used to populate the value of the current
argument.  C<$3> is ignored.

=item * ccall_ret - get a return value from a ccall

C<ccall_ret> is similar to C<ccall_arg>, except that it copies the return value
of the previously-called function into C<*$2>.  C<$3> is ignored.

=item * ccall - invoke a function

C<ccall> uses the function pointer in C<*$1> to call a C function, assuming that
its arguments have been set up correctly.  C<$2> and C<$3> are ignored.

=back

=head3 Temporary ops (3 ops)

=over

=item * print_s  - prints a string

Print the string at C<*$2> to the filehandle C<*$1>.

=item * print_i  - prints an int

Print the integer at C<*$2> to the filehandle C<*$1>.

=item * print_n  - prints a number

Print the floating-point number at C<*$2> to the filehandle C<*$1>.

=item * exit - exit with the given status (go through ffi)

Call C's C<exit> function with C<*$1>.  C<$2> and C<$3> are ignored.

=back

These are too high-level and can be written in terms of simpler ops:

=over

=item * new  - create a new PMC
       * allocate memory
       * set default values
=item * store - store a register in a PMC, or vice versa

=item * get_cf - Get the current Lorito call frame

=item * invoke_cf - Invoke the current Lorito call frame
       * set return PC in call frame
       * switch code segment, if necessary
       * get (new) current PC from call frame

=item * new_cf - Create a new Lorito call frame
       * allocate memory
       * set default values

=item * load_bytecode - load bytecode into the current Lorito call frame
       * allocate memory
       * make a couple of system calls (hand-waving here)

=item * mark_unused - tell the GC that this previously allocated memory is now unused

=back

=head2 Textual Representation

M0's textual format will mirror its binary representation.  It will consist of
a series of named chunks with the following format.  Any line beginning with an
octothorpe (#) is a comment and will be ignored.

The first line that is not a comment or empty defines the version of M0 that
is being used. This is so that if ops are added in the future, we can differentiate
between different versions of M0 source code and bytecode.

The current version is 0.

=head3 Chunk Format

A chunk consists of a chunk identifier, a constants chunk, a metadata chunk and
a bytecode chunk.  A chunk represents self-contained computational units,
approximately analogous to a function.

=head3 Chunk Identifier

A chunk identifier consists of a single line beginning with '.chunk', followed
by a chunk name.  The name consists of a double quote-delimited utf-8 string
which must be unique. The empty string is allowed as a chunk name.

  .chunk "chunk_name"

This name is the primary way that code will refer to a chunk.  It is roughly
analogous to a function's name in an HLL.

=head3 Constants Segment

The constants segment contains a numbered list of chunks of data.  Data can be
either an integer, a floating point number, a quote-delimited utf-8 string or
arbitrary data in hex notation.  For simplicity's sake, strings will only
support escaping double-quotes.  Any other data should be stored as a hex
string.  This data is accessible through the C<load_const> op.  Any constant
data used by the metadata segment and the bytecode segment will be stored here.

  .constants
  0 1234
  1 1.12345e-12
  2 "asdfasdfs"
  3 "hello, \"world\""
  4 0x00ffbeef
  5 "line"
  6 23

=head3 Metadata Segment

The metadata segment consists of triplets of integers mapping a name and a
bytecode offset to a value.  The first number is an offset into the bytecode
segment.  This is the instruction at which the metadata first takes effect.
The second number is the offset into the constants table that contains the name
of the metadata entry.  The third is the offset into the constants table that
contains the value.

  .metadata
  #at pc 1234, "line" is 23
  1243 5 6

=head3 Bytecode Segment

The bytecode segment consists of a list of mnemonics for instructions and their
arguments.  All instructions take three int arguments between 0 and 255, even
if they aren't all used.

  .bytecode
    set   1, 3, 9
    add_i 3, 2, 3
    cmp_i 2, 3, 3
    goto  0, 0, 0

=head4 Register Names

Instruction arguments may also use the register names specified in the C<Types>
section in place of numeric arguments.  This is nothing more than syntactic
sugar.  The two ops below will assemble to identical bytecode.  When
disassembling M0 bytecode, it is up to the disassembler to determine which form
will be output.

  div_i I0, I3, I4
  div_i 12, 15, 16

As a way to filter out visual noise from M0 bytecode assembly listings, the
value C<x> may be used as an instruction argument to indicate that the
argument's value is ignored.  C<x> is an alias for 0.

  goto 0, 12, x

=head4 Labels

In M0's textual bytecode representation, labels may be used to represent
bytecode offsets within a chunk.  There is at most a one-to-one mapping between
instructions and labels; an instruction may be prefixed by at most one label
and the use of a label to identify more than one instruction is invalid.  A
label consists of an identifer ([a-zA-Z][a-zA-Z9-0-9_]*) and may not have the
same name as a register (e.g. I0, INTERP, BCS, etc).  

A label may be used as the first argument to C<goto> or C<goto_if> as an
alternative to specifying the bytecode offset explicitly.  Use of labels with
any other ops is invalid.

  .bytecode
  set_var I0, 0, 0
  set_var I1, 0, 1
  loop: add_i I0, I0, I1
  goto  loop, x

Labels exist only in M0's textual representation.  During assembly they are
translated into an immediate bytecode offset.  For example, the above snippet
would translate to:

  .bytecode
  # offset 0, 0
  set_var I0,  0, 0
  # offset 1, 0
  set_var I1,  0, 1
  # offset 2, 0
  add_i   I0, I0, 1

  # label "loop" translated to offset 0, 2
  goto     0,  2, x 

It is explicitly valid to use a label before it has been defined.  This means
that the assembler must be smart enough to accept undefined labels during
parsing and fill in their values in bytecode once a chunk is fully parsed.

=head3 Full Example

The following should be a working "hello world" program in M0.

    .version 0
    .chunk "hello"
    .constants
    0 1
    1 "hello, world"
    2 0x0A00
    3 0
    .metadata
    .bytecode
    #I0 is 0
    set_var I0, 0, 0
    #I1 is "hello"
    set_var I1, 0, 1
    #I2 is "\n"
    set_var I2, 0, 2
    #I3 is 0
    set_var I3, 0, 3
    #print "hello" to stdout
    # x is arbitrary
    print_s I0, I1, x
    #print "\n" to stdout
    print_s I0, I2, x
    #exit with status 0
    exit I3, x, x


=head2 Binary Representation

M0's binary representation will be composed of a fixed header, a single
directory segment and a number of chunks.  Chunks correspond roughly to
functions and have the following segments:

=over 4

=item * a constants segment containing the data that the segment needs

=item * a metadata segment that carries any extra data like HLL line numbers, function names, annotations and custom data

=item * a code segment containing the ops

=back

{{{
NOTE: We should design the binary format of M0 in a way that allows it to be mmapped
by an interpreter. Which considerations does this imply?
}}}

The header has the following structure:

  "\376M0B\r\n\032\n" : 8-byte magic number (copied/modified from pbc)
  0x00       : 1 byte version number (currently 0)
  0x?        : 1 byte number of bytes in an I registers
  0x?        : 1 byte number of bytes in an N register
  0x?        : 1 byte number of bytes in a opcode_t
  0x?        : 1 byte number of bytes in a pointer
  0x?        : 1 byte for endianness
  xxxxx      : padding

The directory segment will be a list of offsets to the starts of chunks within
the file.  It will have the following structure:

  opcode_t : M0_DIR_SEG
  opcode_t : number of chunks in this segment
  opcode_t : number of opcode_t-sized units in this segment
  [
    opcode_t : offset of a constants segment
    opcode_t : size of chunk name
    [
      opcode_t : chunk name
    ]
  ]

The constants segment will contain any data needed to execute the bytecode.
Data in constants table must be explictly loaded into registers as needed.

  opcode_t : M0_CONST_SEG
  opcode_t : number of constants in this segment
  opcode_t : number of opcode_t-sized units in this segment
  [
    opcode_t : number of bytes in constant data
    ...      : constant data
  ]

The metadata segment contains any data about the bytecode that might come in
handy.  The actual data will live in the constants table; this segment just
provides a way to map values to names and bytecode offsets.

  opcode_t : M0_META_SEG
  opcode_t : number of entries in this segment
  opcode_t : number of opcode_t-sized units in this segment
  [
    opcode_t : bytecode offset relative to the start of the current bc seg where this data becomes effective
    opcode_t : offset into constants table for the name of this piece of metadata
    opcode_t : offset into constants table for the value of this piece of metadata
  ]

The bytecode segment contains a series of executable ops.  A pointer (or its
equivalent for a non-C language) to the current call frame will be passed as
the first argument to every op, but this pointer will not be stored in
bytecode.

  opcode_t : M0_BC_SEG
  opcode_t : number of ops in this segment
  opcode_t : number of opcode_t-sized units in this segment
  [
    char : opcode
    char : arg1
    char : arg2
    char : arg3
  ]

=head3 Segment Numbers

    M0_DIR_SEG       0x01
    M0_CONST_SEG     0x02
    M0_META_SEG      0x03
    M0_BC_SEG        0x04

=head3 Opcode Numbers

In the interest of compatibility between implementations, the following is a
canonical list of the ops an M0 implementation must implement and the numbers
they must correspond to.  Other opcode numbers are implementation-specific and
are not require to have any defined semantics.

    0x00 noop
    0x01 goto
    0x02 goto_if
    0x03 goto_chunk
    0x04 add_i
    0x05 add_n
    0x06 sub_i
    0x07 sub_n
    0x08 mult_i
    0x09 mult_n
    0x0A div_i
    0x0B div_n
    0x0C mod_i
    0x0D mod_n
    0x0E iton
    0x0F ntoi
    0x10 ashr
    0x11 lshr
    0x12 shl
    0x13 and
    0x14 or
    0x15 xor
    0x16 gc_alloc
    0x17 sys_alloc
    0x18 sys_free
    0x19 copy_mem 
    0x1A set
    0x1B set_imm
    0x1C deref
    0x1D csym
    0x1E ccall_arg
    0x1F ccall_ret
    0x20 ccall
    0x21 print_s
    0x22 print_i
    0x23 print_n
    0x24 alloc
    0x25 free
    0x26 exit

=head2 Execution

Execution of an binary M0 file beings with the first op in the bytecode segment
of the first chunk.  Each op consists of a 1-byte op number and 3 byte-sized
arguments.  The op number is used as an offset into a table of function
pointers (or something equivalent).  The current call frame is passed as the
first argument to all op functions.  The remaining three bytes of the op are
passed to the op function directly.  It is up to the op function how to
interpret these values.

=head3 M0 Runloop

The runloop is the part of the interpreter that executes ops directly.  The
runloop does need to accomplish the following:

=over

=item * fetch the instruction at the current PC

=item * execute the instruction

=item * increment the pc, if needed

=back

Execution of an M0 bytecode file starts with the first op of the first bytecode
segment in a file and ends when the interpreter exits.

=head2 Interaction Between Bytecode Segments

This section will specify the following:
 * how to reliably transfer control flow between chunks
 * how to reliably map between sub names and chunks
 * how values from one sub are accessed by another (arguments/returns)

=head2 Exceptions and Exception Handling

{{{
NOTE: This section is in flux.  It's all open for discussion and should by no
means be considered final.
}}}

The exception system is based around call frames, just as regular control flow
is.  Exception handlers should be static constructs so that they only have a
runtime cost when exceptions are thrown.  Exception handlers are attached to a
call frame's EH register.

Exception handlers must be chainable.  When a handler cannot handle an
exception, it must invoke its parent handler (preferably tailcalling).  If it
has no parent handler, it must look through previous call frames until it finds
one.  There must be a default top-level exception handler that handles all
exceptions.  The top-level exception handler should  print some debugging
information to stderr and exit with a non-zero exit code.

{{{
Does it make sense to require M0 interpreter implementations to install the
default exception handler?
}}}

An exception is a chunk that knows how to do a few things.  It needs to look
through the call chain for the first exception handler and invoke it, passing
any relevant data to the handler.  An exception may be resumed by invoking its
parent call frame

Throwing an exception means creating a context, looking up a handler and
invoking the handler with the exception as an argument.  If an exception
handler refuses to handle an exception, the handler is responsible for finding
the next handler.  The exception's responsibilities end when the first handler
is invoked.

=head2 Objects

In Lorito, we'll still have INSP registers like PIR, but the S registers will
be PMCs that happen to be strings.  Additionally, PMCs and objects are being
unified. M0's idea of an object/PMC is a blob of memory which obeys a primitive
vtable interface, which is really just looking up an integer index in memory.

=head2 Memory Model

Memory can be allocated with C<sys_alloc> and C<gc_alloc> and freed with
C<sys_free>, if needed.  C<copy_mem> is used to copy values into and out of
memory.

{{{
Will some memory be protected in M0?
}}}

=head2 Register Spilling

In the event that the register allocator runs out of registers and needs to
spill, an overflow call frame can be created and stored in the SPILLCF
register.  The overflow call frame will contain a copy of all INSP registers
and the SPILLCF register itself.  To despill, the register allocator must copy
all values fromt the overflow call frame between SPILLCF and the last INSP
register (P60) into the current call frame.

This method ensures that all objects referenced by the call frame will remain
reachable by the GC and that an arbitrary amount of register spilling is
possible, if needed.  Register spilling is a last resort, and it is not
expected to be a common occurance.

=head2 Structs

Structs (as implemented in C) will be an abstraction on top of M0.  M0 will not
be concerned with them directly.

=head2 Register Types and Call Frame Structure

There are four register types, Integer, Numeric, PMC and String. The string
type will merely be syntactic sugar for accessing a PMC.  From an M0
perpsective, S and P registers will be treated as opaque pointers.

Each M0 register will be 8 bytes (or have equivalent precision).  A compliant
call frame will use 2KB (8*265B).
{{{
    NOTE: This is still up for debate.  2K per call frame can get expensive on
    embedded systems, especially if all registers aren't used.  Given that
    there's a well-defined mechanism for register spilling, it's an option to
    reduce the number of registers in a call frame if it turns out that typical
    generated M0 code does just fine with 32, 25 or fewer registers of each
    type.  All this may be a premature optimization though.

}}}

M0 registers will not have innate types; they'll be nothing more than a
collection of bits which are assumed to have a certain type by M0's ops.  The
types that ops attribute to register values will be based on the position of
the register in an M0 call frame's register set.  The proposed structure uses the
first 8 registers for information specific to the call frame and has 60 of each primitive
type:

    number  type
    0       INTERP - global interpreter data (see C<Interpreter Data>)
    1       PC  - current instruction within the current bytecode segment
    2       EH  - current exception handler
    3       PCF - parent call frame
    4       CHUNK - the name of the currently-executing chunk
    5       CONSTS - pointer to constants segment
    6       MDS - pointer to metadata segment
    7       BCS - pointer to bytecode segment
    8       REGSZ - number of bytes in a register (hard-coded)
    9       RETPC - return PC
    10      SPC4RNT - this space for rent
    11      SPILLCF - overflow call frame (see C<Register Spilling>)
    12-72   I0 - I60
    73-133  N0 - N60
    134-194 S0 - S60
    195-255 P0 - P60

This means that an op which is passed the wrong value could pretty easily cause
chaos by clobbering the PC or changing the pointer to the current call frame.

=head2 Interpreter Data

While most of the interesting parts of runtime data will live in a call frame,
it still make sense to store some data in a global interpreter data structure.
This will include the following items, stored in the same way as call frame
data.

    number  name        description
    0       OP_FUNCS    array of functions that implement ops
    1       CHUNKS      array of all loaded chunks
    2       CHUNK_INFO  array of chunk metadata (currently just names)
    3       CALL_FRAMES array of all initial call frames
    4       CONFIG      static global config data

=head2 MOP interaction

A MOP will be implemented at the C<M1> level, so C<M0> must merely make it this
possible. The C<M0> does not and should not understand any structures at higher
levels. This will loosely couple C<M0> and C<M1> and allow them to evolve
independently.

=head2 FFI

=head3 FFI considerations

M0's FFI should be amenable to interpretation both by interpreters implemented
in C and high-level languages such as Python or Perl, to direct compilation to
machine code, to jitting and to compilation to static C.  Where possible, M0's
design should not impose any constraints that preclude efficient implementation
of any of type of interpreter.

M0 must be implemented such that only programs which make direct use of ffi
require it to be presence.  An M0 program which does not make use of FFI should
run without modification on an implementation that does not support ffi.

=head3 Implementation

M0's FFI will implement similar functionality to dlfunc and dlvar in the form
of a minimal set of atoms which are sufficient to emulate that functionality.

M0 will know enough about FFI to build a static call frame and call a C
function pointer according to C calling conventions.  M0 will have four ops to
support this: C<csym>, C<ccall_arg>, C<ccall_ret> and C<ccall>.  These are
documented below.

=over 4

=item * csym sym, "function_name"

C<csym> looks up the function pointer for C<function_name> in the C function
namespace and puts the pointer into the register C<sym>.

=item * ccall_arg arg_type, arg_src

C<ccall_arg> takes two arguments: an argument type and an argument source.
C<arg_type> is a constant indicating the type of the argument.  The possible
values of C<arg_type> will be similar to those used by libffi
(https://github.com/atgreen/libffi/blob/master/doc/libffi.info ).  C<arg_src>
indicates which M0 register should be used to populate the value of the
current argument.

=item * ccall_ret arg_type, arg_dest

C<ccall_ret> is similar to C<ccall_arg>, except that it copies the return value
of the previously-called function into the register indicated by C<arg_dest>.

=item * ccall fp

C<ccall> uses an existing function pointer to call a C function.  It assumes
that arguments have been set up correctly.  Hilarity and segfaults are likely
to result from breaking this assumption.

=back

=head3 Examples

The following example code calls a function called C<hello_func>, which takes
no arguments and has no return value, in the library C<libhello.so>.  The use
of strings as direct arguments is a simplification for explanatory purposes.
In actual M0 bytecode, the string would be an index into the constants table.

    dlopen_fp = csym "Parrot_dlopen"
    dlsym_fp  = csym "Parrot_dlsym"
    ccall_arg FFI_POINTER, "libhello.so" #hand-waving
    ccall     dlopen_fp
    ccall_ret FFI_POINTER, libhello

    ccall_arg FFI_POINTER, "hello_func" #more hand-waving
    ccall     dlsym_fp
    ccall_ret FFI_POINTER, hello_func

    ccall hello_func

This example shows how to call a function "multiply_int32" which take two
32-bit int arguments and returns an value of the same type and lives in
"libmath.so".  It assumes that dlsym_fp and dlopen_fp have been initialized as
in the first example.

    #dlsym_fp is a pointer to Parrot_dlsym
    #dlopen_fp is a pointeer to Parrot_dlopen

    ccall_arg FFI_POINTER, "libmath.so"
    ccall     dlopen_fp
    ccall_ret FFI_POINTER, libmath

    ccall_arg FFI_POINTER, libmath
    ccall_arg FFI_POINTER, "multiply_int32"
    ccall     dlsym_fp
    ccall_ret FFI_POINTER, multiply_fp

    set       arg0, 12
    set       arg1, 10

    ccall_arg FFI_UINT32, arg0
    ccall_arg FFI_UINT32, arg1
    ccall     multiply_fp
    ccall_ret FFI_UINT32, ret

    say ret  # will print "120"

This example shows how to call an internal function (i.e. one that does not
live in an external shared library) with the same signature as above.

    set       arg0, 12
    set       arg1, 10
    csym      func, "Parrot_multiply_ints"

    ccall_arg FFI_UINT32, arg0
    ccall_arg FFI_UINT32, arg1
    ccall     func
    ccall_ret FFI_UINT32, ret

    say ret  # will print "120"

=head3 Constants

These are the constants which an M0-compliant FFI implementation should deal
with.  They are based on the types used by libffi.

    FFI_VOID
    FFI_UINT
    FFI_SINT
    FFI_UINT16
    FFI_SINT16
    FFI_UINT32
    FFI_SINT32
    FFI_UINT64
    FFI_SINT64
    FFI_FLOAT
    FFI_DOUBLE
    FFI_UCHAR
    FFI_SCHAR
    FFI_USHORT
    FFI_SSHORT
    FFI_UINT
    FFI_SINT
    FFI_ULONG
    FFI_SLONG
    FFI_LONGDOUBLE
    FFI_POINTER

=head2 Concurrency

This section will describe primitives that will be needed to allow data sharing and
synchronization between call frames.

The Actor model of concurrency currently looks promising http://en.wikipedia.org/wiki/Actor_model .
One implementation of the Actor model on the JVM is Akka : http://akka.io/

=head2 Security

M0 will have security mechanisms such that an optional cryptographic hash of
the bytecode will be stored in a dedicated chunk in the bytecode file.  This
will not be tied to any one crypto algorithm, and crypto algorithms which are
portable and run on all platforms that Parrot supports are likely candidates
for a default. This part of the spec is still in flux. One option we have is to
specify a textual string such as "SHA1" and store the accompanying hash. Then
the M0 interpreter will verify the SHA1 sum matches and give a loud error and
bomb out if it doesn't.

If implemented, hashes will only be stored in bytecode and will be generated as
an optional post-processing step on the m0b file.

=head1 Lorito

=head2 Description

This section covers the parts of Lorito that are not directly relevant to
someone implementing an M0-compatible VM.  These topics are important to a
complete implementation of Lorito but do not need to be directly addressed by
M0 VM implementations.

Shouldn't this be a different spec document? Perhaps PDD33 for M1 ?

=head2 Op Composition

Op composition is considered magic-like and will not be part of M0.

=head2 Implementation

The newest prototype of this spec is being worked on in the 'm0-prototype'
branch:

    https://github.com/parrot/parrot/tree/m0-prototype


=head2 References

[TBC] - http://www.ics.uci.edu/~franz/Site/pubs-pdf/ICS-TR-10-01.pdf

=cut

__END__
Local Variables:
  fill-column:78
End:
