# Copyright (C) 2011, Parrot Foundation.

=head1 PDD 32: M0 Design Spec

=head2 Abstract

This document specifies M0, the set of microcode-like ops on which Parrot will
be based, and their requisite runtime environment.

=head2 Status

This document is a draft under active development.  Nothing is set in stone
yet.  If you would like to suggest improvements, please talk with cotto,
bacek, atrodo, chromatic or dukeleto.

=head2 M0 Milestones

This is a list of things that we expect the M0 VM to be able to do as this
spec progresses.  They're pretty basic, but that's the idea behind M0.

=over

=item * print 42 (hard-coded instructions are fine at this point)

=item * assemble an M0 assembly listing into M0 bytecode

=item * disassemble binary M0 bytecode into an M0 assembly listing

=item * print "hello, world\n"

=item * add two integer registers, store the result

=item * calculate the sum of a 10-element array of ints

=item * calculate the hash of a hard-coded string (any non-trivial algorithm)

=item * call a function with an argument, return a value

=back

=head2 Definitions

=over

=item * M0

C<M0> refers to the specification for a minimal virtual machine capable of
executing the ops described in this document.  The M0 VM should have the same
expressive power as C and will live at the same level that C currently does.
This means that M0 explicitly does not need to know about higher-level concepts
such as garbage collection and Parrot's calling conventions.

=item * M0 ops

This is the lowest-level set of ops supported by an M0-compliant VM.  These
ops are a subset of the C<M0> specification.

=item * Lorito

Lorito refers to the combination of C<M0>, a meta-object model and the way
that they're used as a foundation for Parrot.

=item * Lorito Context

This refers to a Lorito Context PMC, which is the most important datastructure
at the M0 level. You could say that it is the "secret sauce" of M0. The exact
details of the Lorito Context PMC are still in flux.

A Context will contain:
INSP registers (fixed number of each)
PC    - currently executing instruction (bytecode segment and offset)
EH    - exception handler address (bytecode segment and offset)
EX    - exception payload
caller - calling context

=item * thunk

When discussing M0, C<thunk> refers to small generated functions that convert
between different calling conventions.  These are also referred to as wrappers
or "glue code".

=back

=head2 Design Goals

There are three goals that M0 needs to meet:

=over

=item 1

Have executable code with equivalent power to C.

=item 2

Have a form of code that can be easily analyzed.

=item 3

Have a single form of code used to implement the majority of Parrot, rather
than having a mix of C and PIR.

=back

We are also designing M0 to be as simple as possible, i.e. M0 should contain as
few ops as possible.  The complexity of Parrot will be built on top of M0, in
M1 (which will be written in M0) and beyond.  This is to facilitate multiple
implementations, e.g. a quick and dirty prototype implementation in JavaScript,
a space-optimized implementation targeted for mobile devices, a tracing jit
targeted for server use, etc.  M0's simplicity should be extreme; the moment M0
gets ops for the sake of efficiency or ease of use, it has failed its design
goals.

There will be no stacks in M0, not even for argument passing. Everything must
be in continuation-passing-style.

=head2 Scope

This document only covers M0 and the minimum VM necessary to support it.
Anything beyond that, e.g. the meta-object model or layout of contexts, is
beyond its scope.

=head2 List of Ops

M0 ops are very low-level and provide the simplest possible way of interacting
with the VM.  Apart from print/gripe/say (which are intended only for the early
stages of an M0 VM's development), M0 ops should painfully minimal.  It's
expected that common operations will be painful.  That's what compilers are
for.

The names and number of the ops below may change at any time, possibly without
any rational reason, until the spec is more stable.  As a way to verify that
the op set is complete, we will look at how a representative selection of PIR's
existing core ops and the dynops used by HLLs could be reimplemented in terms
of M0 ops.

=head3 Math/numeric ops (10 ops)

=over

=item * add_i - add two integer registers

=item * add_n - add two numeric registers

=item * mult_i - multiply two integer registers

=item * mult_n - multiply two numeric registers

=item * iton - coerce integer to numeric

=item * ntoi - coerce numeric to integer

=item * shr - right circular bitshift

=item * shl - leftward circular bitshift

=item * cmp_i - integer comparison

=item * cmp_n - numeric comparison

=back

=head3 Memory ops (4 ops)

=over

=item * set  - sets a register to a value (type-ignorant)

=item * memset - set a region of memory to a value stored in a register

=item * memget - get a region from memory and copy it into a register

=item * get_var - point a register at the first byte of a variable on the variables table

=back

=head3 FFI ops (4 ops)

=over

=item * csym - look up a function by name (use this to find Parrot_dlopen/Parrot_dlsym)

=item * ccall_arg - set an argument for a ccall

=item * ccall_ret - get a return value from a ccall

=item * ccall - invoke a function handle

=back

=head3 Temporary ops (4 ops)

=over

=item * print  - prints a string to a file handle

=item * alloc - allocate memory (go through ffi)

=item * free - free memory (go through ffi)

=item * exit - exit with the given status (go through ffi)

=back

These are too magical and can be written in terms of simpler ops:

=over

=item * new  - create a new PMC
       * allocate memory
       * set default values
=item * store - store a register in a PMC, or vice versa

=item * get_cc - Get the current Lorito context

=item * invoke_cc - Invoke the current Lorito context
       * set return PC in context
       * switch code segment, if necessary
       * get (new) current PC from context

=item * new_ctx - Create a new Lorito context
       * allocate memory
       * set default values

=item * load_bytecode - load bytecode into the current Lorito context
       * allocate memory
       * make a couple of system calls (hand-waving here)

=item * mark_unused - tell the GC that this previously allocated memory is now unused

=back

=head2 Textual Representation

Describe what the textual form of M0 will look like.  The emphasis should be
on ease of consumption.  We won't be writing a large amount of M0 code by
hand; it's just fine if it's painful to do so for non-trivial use cases.

=head2 Binary Representation

M0's binary representation will be composed of a fixed header, a single
directory segment and a bunch of segment triplets describing a chunk of
bytecode:

=over 4

=item * a bytecode segment containing the ops

=item * a variables table segment containing the objects that the segment needs

=item * a metadata segment that carries any extra data like HLL line numbers, function names, annotations and custom data.

=back

We should design the binary format of M0 in a way that allows it to be mmapped
by an interpreter.

The header will look like:

  'asdfasdf' : 8-byte magic number (copy from pbc)
  0x?        : 1 byte number of bytes in an I registers
  0x?        : 1 byte number of bytes in an N register
  0x?        : 1 byte number of bytes in a opcode_t
  0x?        : 1 byte number of bytes in a pointer
  0x?        : 1 byte for endianness
  xxxxx      : padding

directory:

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : M0_DIR_SEG
  [
    opcode_t : offset of first byte of bytecode segment
    opcode_t : offset of first byte of vartable segment
    opcode_t : offset of first byte of metadata segment
  ]

bytecode segment: This segment contains a series of executable ops.

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : M0_BC_SEG
  [
    char : opcode
    char : ctx_arg
    char : arg1
    char : arg2
    char : arg3
    ...  : padding (maybe)
  ]

variables segment:  Any data lives here and is loaded into registers as needed.

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : M0_VARS_SEG
  [
    opcode_t : number of bytes in variable data
    ...      : variable data
  ]

metadata segment: Any data about the bytecode that might come in handy is
tracked here.  The actual data will live in the variables segment; this table
just provides a way to map those values to names and bytecode offsets.

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : M0_META_SEG
  [
    opcode_t : bytecode offset relative to the start of the current bc seg where this data becomes effective
    opcode_t : offset into vartable for the name of this piece of metadata
    opcode_t : offset into vartable for the value of this piece of metadata
  ]

=head2 Binary instruction format

Initially, M0 ops will be packed without any padding.  Once we have a
representative sample of running M0 code, we will benchmark various padding
strategies to find which have the best performance characteristics for a
typical expected workload.  A viable M0 interpreter implemented in a low-level
langauge like C will be needed to properly test this. 

=head2 M0 Runloop

The runloop is the part of the interpreter that executes ops directly.  It
doesn't much matter how those ops are executed, but the runloop does need to
accomplish the following:

=over

=item * fetch the instruction at the current PC

=item * execute the instruction

=item * increment the pc, if needed

=back

=head2 Objects

In Lorito, we'll still have INSP registers like PIR, but the S registers will
be PMCs that happen to be strings.  Additionally, PMCs and objects are being
unified. M0's idea of an object/PMC is a blob of memory which obeys a primitive
vtable interface, which is really just looking up an integer index in memory.

=head2 Memory Model

Memory can be allocated with alloc() and freed with free(). One can retrieve
values from memory with memget() and changed with memset().

Will some memory be protected in M0?

=head2 structs

Structs (as implemented in C) will be an abstraction on top of M0.  M0 will not
be concerned with the directly.

=head2 Types

There are four register types, Integer, Numeric, PMC and String. The string
type will merely be syntax sugar for accessing a PMC.

M0 registers will not have innate types; they'll be nothing more than a
collection of bits which are interpreted by M0's ops as having a certain type.
The types that ops attribute to register values will be based on the position
of the register in an M0 context's register set.  For example if an M0 context
has 25 registers (which it won't), their types might be as follows:

    number  type
    0       current context
    1       PC
    2       EH
    3       EX
    4       calling context
    5-9     I
    10-14   N
    15-19   S
    20-24   P

This means that an op which is passed the wrong value could pretty easily cause
chaos by clobbering the PC or changing the pointer to the current context.

=head2 Immediate Values

M0 supports loading values from the variables table into registers via the
C<get_var> instruction.

=head2 MOP interaction

describe this here - the mop is mostly a higher-level concern than M0 cares
about, but M0 will need to describe how PMCs and strings behave.  To make that
happen, M0 needs to have some minimal concept of a pmc (and an object, since
they'll be the same thing under Lorito).

=head2 FFI

=head3 FFI considerations

M0's FFI should be amenable to interpretation both by intperpreters implemented
in C and high-level languages such as Python or Perl, to direct compilation to
machine code, to jitting and to compilation to static C.  Where possible, M0's
design should not impose any constraints that preclude efficient implementation
of any of type of interpreter.

=head3 Implementation

M0's FFI will implement similar functionality to dlfunc and dlvar in the form
of a minimal set of atoms which are sufficient to emulate that functionality.

M0 will know enough about FFI to build a static call frame and call a C
function pointer according to C calling conventions.  M0 will have four ops to
support this: C<csym>, C<ccall_arg>, C<ccall_ret> and C<ccall>.  These are
documented below.

=over 4

=item * csym sym, "function_name"

C<csym> looks up the function pointer for C<function_name> in the C function
namespace and puts the pointer into the register C<sym>.

=item * ccall_arg arg_type, arg_src

C<set_arg> takes two arguments: an argument type and an argument source.
C<arg_type> is a constant indicating the type of the argument.  The possible
values of C<arg_type> will be similar to those used by libffi
(https://github.com/atgreen/libffi/blob/master/doc/libffi.info ).  C<arg_src>
indicates which M0 register should be used to populate the value of the
current argument.

=item * ccall_ret arg_type, arg_dest

C<ccall_ret> is similar to C<ccall_arg>, except that it copies the return value
of the previously-called function into the register indicated by C<arg_dest>.

=item * ccall func_handle

C<ccall> uses an existing function pointer to call a C function.  It assumes
that arguments have been set up correctly.  Hilarity and segfaults are likely
to result from breaking this assumption.

=back

=head3 Examples

The following example code calls a function called C<hello_func>, which takes
no arguments and has no return value, in the library C<libhello.so>.  The use
of strings as direct arguments is a simplification for explanatory purposes.
In actual M0 bytecode, the string would be an index into the variables table. 

    dlopen_fp = csym "Parrot_dlopen"
    dlsym_fp  = csym "Parrot_dlsym"
    ccall_arg FFI_POINTER, "libhello.so" #hand-waving
    ccall     dlopen_fp
    ccall_ret FFI_POINTER, libhello

    ccall_arg FFI_POINTER, "hello_func" #more hand-waving
    ccall     dlsym_fp
    ccall_ret FFI_POINTER, hello_func

    ccall hello_func

This example shows how to call a function "multiply_int32" which take two
32-bit int arguments and returns an value of the same type and lives in
"libmath.so".  It assumes that dlsym_fp and dlopen_fp have been initialized as
in the first example.

    #dlsym_fp is a pointer to Parrot_dlsym
    #dlopen_fp is a pointeer to Parrot_dlopen

    ccall_arg FFI_POINTER, "libmath.so"
    ccall     dlopen_fp
    ccall_ret FFI_POINTER, libmath

    ccall_arg FFI_POINTER, libmath
    ccall_arg FFI_POINTER, "multiply_int32"
    ccall     dlsym_fp
    ccall_ret FFI_POINTER, multiply_fp

    set       arg0, 12
    set       arg1, 10

    ccall_arg FFI_UINT32, arg0
    ccall_arg FFI_UINT32, arg1
    ccall     multiply_fp
    ccall_ret FFI_UINT32, ret

    say ret  # will print "120"

This example shows how to call an internal function (i.e. one that does not
live in an external shared library) with the same signature as above.

    set       arg0, 12
    set       arg1, 10
    csym      func, "Parrot_multiply_ints"

    ccall_arg FFI_UINT32, arg0
    ccall_arg FFI_UINT32, arg1
    ccall     func
    ccall_ret FFI_UINT32, ret

    say ret  # will print "120"

=head2 Concurrency

describe what primitives will be needed to allow data sharing and
synchronization between contexts.

=head1 Lorito

=head2 Description

This section covers the parts of Lorito that are not directly relevant to
someone implementing an M0-compatible VM.  These topics are important to a
complete implementation of Lorito but do not need to be directly addressed by
M0 VM implementations.

<this space intentionally left blank, for now>

=head2 Op Composition

<this space for rent>

=head2 Implementation

<this space intentionally left blank, for now>

=head2 References

<this space intentionally left blank, for now>

=cut

__END__
Local Variables:
  fill-column:78
End:
