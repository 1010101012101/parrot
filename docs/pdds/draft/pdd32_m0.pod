# Copyright (C) 2011, Parrot Foundation.

=head1 PDD 32: M0 Design Spec

=head2 Abstract

This document specifies M0, the set of microcode-like ops on which Parrot will
be based, and their requisite runtime environment.

=head2 Status

This document is a draft under active development.  Nothing is set in stone
yet.  If you would like to suggest improvements, please talk with cotto,
bacek, atrodo, chromatic or dukeleto.

=head2 M0 Milestones

This is a list of things that we expect the M0 VM to be able to do as this
spec progresses.  They're pretty basic, but that's the idea behind M0.

=over

=item * print 42 (hard-coded instructions are fine at this point)

=item * assemble an M0 assembly listing into M0 bytecode

=item * disassemble binary M0 bytecode into an M0 assembly listing

=item * print "hello, world\n"

=item * add two integer registers, store the result

=item * calculate the sum of a 10-element array of ints

=item * calculate the hash of a hard-coded string (any non-trivial algorithm)

=item * call a function with an argument, return a value

=back

=head2 Definitions

=over

=item * M0

C<M0> refers to the specification for a minimal virtual machine capable of
executing the ops described in this document.  The M0 VM should have the same
expressive power as C and will live at the same level that C currently does.
This means that M0 explicitly does not need to know about higher-level concepts
such as garbage collection and Parrot's calling conventions.

=item * M0 ops

This is the lowest-level set of ops supported by an M0-compliant VM.  These
ops are a subset of the C<M0> specification.

=item * Lorito

Lorito refers to the combination of C<M0>, a meta-object model and the way
that they're used as a foundation for Parrot.

=item * Lorito Context

This refers to a Lorito Context PMC, which is the most important datastructure
at the M0 level. You could say that it is the "secret sauce" of M0. The exact
details of the Lorito Context PMC are still in flux.

A Context will contain:
INSP registers (fixed number of each)
PC    - currently executing instruction (bytecode segment and offset)
EH    - exception handler address (bytecode segment and offset)
EX    - exception payload
caller - calling context

=item * thunk

When discussing M0, C<thunk> refers to small generated functions that convert
between different calling conventions.  These are also referred to as wrappers
or "glue code".

=back

=head2 Design Goals

There are three goals that M0 needs to meet:

=over

=item 1

Have executable code with equivalent power to C.

=item 2

Have a form of code that can be easily analyzed.

=item 3

Have a single form of code used to implement the majority of Parrot, rather
than having a mix of C and PIR.

=back

We are also designing M0 to be as simple as possible, i.e. M0 should contain as
few ops as possible.  The complexity of Parrot will be built on top of M0, in
M1 (which will be written in M0) and beyond.  This is to facilitate multiple
implementations, e.g. a quick and dirty prototype implementation in JavaScript,
a space-optimized implemention targeted for mobile devices, a tracing jit
targeted for server use, etc.  M0's simplicity should be extreme; the moment M0
gets ops for the sake of efficiency or ease of use, it has failed its design
goals.

There will be no stacks in M0, not even for argument passing. Everything must
be in Continuation-Passing-Style.

=head2 Scope

This document only covers M0 and the minimum VM necessary to support it.
Anything beyond that, e.g. the meta-object model or layout of contexts, is
beyond its scope.

=head2 List of Ops

M0 ops are very low-level and provide the simplest possible way of interacting
with the VM.  Apart from print/gripe/say (which are intended only for the early
stages of an M0 VM's development), M0 ops should painfully minimal.  It's
expected that common operations will be painful.  That's what compilers are
for.

The names and number of the ops below may change at any time, possibly without
any rational reason, until the spec is more stable.  As a way to verify that
the op set is complete, we will look at how a representative selection of PIR's
existing core ops and the dynops used by HLLs could be reimplemented in terms
of M0 ops.

=over

=item * print  - prints a string to a file handle

=item * add_i - add two integer registers

=item * add_n - add two numeric registers

=item * mult_i - multiply two integer registers

=item * mult_n - multiply two numeric registers

=item * set  - sets a register to a value

=item * get  - gets the value of a register

=item * cmp_i - integer comparison

=item * cmp_n - numeric comparison

=item * alloc - allocate memory

=item * free - free memory

=item * memset - set a region of memory to a value stored in a register

=item * memget - get a region from memory and copy it into a register

=item * shr - right circular bitshift

=item * shl - leftward circular bitshift

=item * int2num - coerce integer to numeric

=item * num2int - coerce numeric to integer

=back

These are too magical and can be written in terms of simpler ops:

=over

=item * new  - create a new PMC
       * allocate memory
       * set default values
=item * store - store a register in a PMC, or vice versa

=item * get_cc - Get the current Lorito context

=item * invoke_cc - Invoke the current Lorito context
       * set return PC in context
       * switch code segment, if necessary
       * get (new) current PC from context

=item * new_ctx - Create a new Lorito context
       * allocate memory
       * set default values

=item * load_bytecode - load bytecode into the current Lorito context
       * allocate memory
       * make a couple of system calls (hand-waving here)

=item * mark_unused - tell the GC that this previously allocated memory is now unused

=back

=head2 Textual Representation

Describe what the textual form of M0 will look like.  The emphasis should be
on ease of consumption.  We won't be writing a large amount of M0 code by
hand; it's just fine if it's painful to do so for non-trivial use cases.

=head2 Binary Representation

proposal: M0's binary representation will be composed of a fixed header, a
single directory segment and a bunch of segment triplets describing a chunk
of bytecode:

=item * a bytecode segment containing the ops

=item * a variables table segment containing the objects that the segment needs

=item * a metadata segment that carries any extra data like HLL line numbers, function names, annotations and custom data.

We should design the binary format of M0 in a way that allows it to be mmapped
by an interpreter.

The header will look like:

  'asdfasdf' : 8-byte magic number (copy from pbc)
  0x?        : 1 byte number of bytes in an I registers
  0x?        : 1 byte number of bytes in an N register
  0x?        : 1 byte number of bytes in a opcode_t
  0x?        : 1 byte number of bytes in a pointer
  0x?        : 1 byte for endianness
  xxxxx      : padding

directory:

  opcode_t, number of opcode_t-sized units in this segment
  opcode_t, type of m0 directory segment
  [
    opcode_t : offset of bytecode segment
    opcode_t : offset of vartable segment
    opcode_t : offset of metadata segment
  ]

m0-bytecode - ops (many per file)

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : type of m0 bytecode segment
  [
    opcode_t : ops
  ]

m0-vartable - constants table, but they're not necessarily constants: first
context has these, other contexts get COW'd copies (one per bytecode segment)

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : type of m0 variables table segment
  [
    opcode_t: offset within segment to name
    opcode_t: pointer to object data
  ]

m0-metadata - anything else (line numbers, function names, annotations, etc)
(one per bytecode segment)

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : type of m0 metadata segment
  [
    opcode_t : data (idk)
  ]

=head2 Binary instruction format

describe the binary encoding of a single M0 instruction and how it should be
interpreteted.

Initially, M0 ops will be packed without any padding.  Once we have a
representative sample of running M0 code, we will benchmark various padding
strategies to find which have the best performance characteristics for a
typical expected workload.  A viable M0 interpreter implemented in a low-level
langauge like C will be needed to properly test this. 

=head2 M0 Runloop

The runloop is the part of the interpreter that executes ops directly.  It
doesn't much matter how those ops are executed, but the runloop does need to
accomplish the following:

=over

=item * fetch the instruction at the current PC

=item * execute the instruction

=item * increment the pc, if needed

=back

=head2 metadata

describe metadata here, e.g. debugging information, aggregate op tracking
info, whatever

=head2 Op Composition

M0 will not support op composition unless necessary.

=head2 Objects

In Lorito, we'll still have INSP registers like PIR, but the S registers will
be PMCs that happen to be strings.  Additionally, PMCs and objects are being
unified. M0's idea of an object/PMC is a blob of memory which obeys a primitive
vtable interface, which is really just looking up an integer index in memory.

=head2 Memory Model

Memory can be allocated with alloc() and freed with free(). One can retrieve
values from memory with memget() and changed with memset().

Will some memory be protected in M0?

=head2 structs

describe structs here, as far as they're relevant to m0

=head2 Types

There are four register types, Integer, Numeric, PMC and String. The string
type will merely be syntax sugar for accessing a PMC.

M0 registers will not have innate types; they'll be nothing more than a
collection of bits which are interpreted by M0's ops as having a certain type.
The types that ops attribute to register values will be based on the position
of the register in an M0 context's register set.  For example if an M0 context
has 25 registers (which it won't), their types might be as follows:

number  type
0       current context
1       PC
2       EH
3       EX
4       calling context
5-9     I
10-14   N
15-19   S
20-24   P

This means that an op which is passed the wrong value could pretty easily cause
chaos by clobbering the PC or changing the pointer to the current context.

=head2 MOP interaction

describe this here - the mop is mostly a higher-level concern than M0 cares
about, but M0 will need to describe how PMCs and strings behave.  To make that
happen, M0 needs to have some minimal concept of a pmc (and an object, since
they'll be the same thing under Lorito).

=head2 FFI

=head3 FFI considerations

M0's ffi should be amenable to interpretation, compilation to machine code
(including jitting) and compilation to static C.  Where possible, M0's design
should not impose any constraints that preclude efficient implementation of any
of type of interpreter.  Part of this means avoiding the assumption that the
basic mechanism of foreign function calls is a thunk.

=head3 Possible Implementations

M0's FFI will need to implement similar functionality to dlfunc and dlvar in
the form of a minimal set of atoms which are sufficient to expose that
functionality.

M0 will know enough about FFI to create a reusable handle that takes M0 values,
sets up the C function call according to C calling conventions (Q: which ones?)
and calls it.  M0 will have three ops to support this: set_arg and set_return
to indicate which M0 registers are to be used in the call, and ccall to call
the C function through the generated .

=item * set_arg func_handle, arg_type, arg_src

set_arg takes three arguments: a ffi function handle, an argument type and an
argument source.  The function handle indicate which function is being operated
on; its value and internals are implementation-dependent.  C<arg_type> is a
constant indicating the type of the argument.  The values of this argument will
be similar to those used by libffi
(https://github.com/atgreen/libffi/blob/master/doc/libffi.info ).  C<arg_src>
indicates which M0 register should be used to populate or recieve the value of
the approrpiate argument.

=item * set_ret func_handle, arg_type, arg_dest

set_ret is similar to set_arg, except that it always sets the type and
destination of the return value from the function invocation.

=item * ccall function_handle

ccall uses an existing function handle to call into a C function.

example code for calling no arg, no ret function:
.local int lib, fnh
lib = dlopen 'libhello.so'
fnh = newfhn 0
dlfunc fnh, lib, "hello_func"
ccall fnh

example code for calling 2 int32 arg, 1 int32 return
.local int ret, arg0, arg1
.local int lib, fnh
arg0 = 12
arg1 = 10
lib = dlopen "libmath.so"
fnh = newfnh 3
dlfunc fnh, lib, "multiply_int32"
set_ret fnh, FFI_UINT32, ret
set_arg fnh, FFI_UINT32, arg0
set_arg fnh, FFI_UINT32, arg1
ccall fnh
say ret  # will print "120"

example code for calling 2 int32 arg, 1 int32 return
.local int ret, arg0, arg1
.local int lib, fnh
arg0 = 12
arg1 = 10
fnh = newfnh 3
cfunc fnh, "multiply_int32"
set_ret fnh, FFI_UINT32, ret
set_arg fnh, FFI_UINT32, arg0
set_arg fnh, FFI_UINT32, arg1
ccall fnh
say ret  # will print "120"

=head2 Concurrency

describe what primitives will be needed to allow data sharing and
synchronization between contexts.

=head1 Lorito

=head2 Description

This section covers the parts of Lorito that are not directly relevant to
someone implementing an M0-compatible VM.  These topics are important to a
complete implementation of Lorito but do not need to be directly addressed by
M0 VM implementations.

<this space intentionally left blank, for now>

=head2 Implementation

<this space intentionally left blank, for now>

=head2 References

<this space intentionally left blank, for now>

=cut

__END__
Local Variables:
  fill-column:78
End:
