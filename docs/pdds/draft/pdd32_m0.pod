# Copyright (C) 2011, Parrot Foundation.

=head1 PDD 32: M0 Design Spec

=head2 Abstract

This document specifies M0, the set of microcode-like opcodes (ops) on which
a future implementation of Parrot internals will be based. This document
also specifies how these ops will interact with other subsystems and their
requisite runtime environment.

=head2 Status

This document is a draft under active development.  Nothing is set in stone
yet.  If you would like to suggest improvements, please talk with cotto,
bacek, atrodo, chromatic or dukeleto.

=head2 M0 Milestones

This is a list of things that we expect the M0 VM to be able to do as this
spec progresses.  They're pretty basic, but that's the idea behind M0.

=over

=item * print 42 (hard-coded instructions are fine at this point)

=item * assemble an M0 assembly listing into M0 bytecode

=item * disassemble binary M0 bytecode into an M0 assembly listing

=item * print "hello, world\n"

=item * add two integer registers, store the result

=item * calculate the sum of a 10-element array of ints

=item * calculate the hash of a hard-coded string (any non-trivial algorithm)

=item * call a function with an argument, return a value

=back

=head2 Definitions

=over

=item * M0

C<M0> refers to the specification for a minimal virtual machine capable of
executing the ops described in this document.  The M0 VM should have the same
expressive power as C and will live at the same level that C currently does.
This means that M0 explicitly does not need to know about higher-level concepts
such as garbage collection and Parrot's calling conventions.

=item * M0 ops

This is the lowest-level set of ops supported by an M0-compliant VM.  These
ops are a subset of the C<M0> specification.

=item * MOP

Meta object protocol.

=item * Lorito

Lorito refers to C<M0> and the levels above it, such as C<M1> which is written
in C<M0> ops, and possibily an C<M2> level which is written in C<M1> ops. More
specifically it refers to a new implementation of Parrot internals. A new MOP
is planned for Lorito and it will most probably live at the C<M1> op level.

=item * Lorito Context

This refers to a Lorito Context PMC, which is the most important datastructure
at the M0 level. You could say that it is the "secret sauce" of M0. The exact
details of the Lorito Context PMC are still in flux.

=item * thunk

When discussing M0, C<thunk> refers to small generated functions that convert
between different calling conventions.  These are also referred to as wrappers
or "glue code".

=back

=head2 Design Goals

There are three goals that M0 needs to meet:

=over

=item 1

Have executable code with equivalent power to C.

=item 2

Have a form of code that can be easily analyzed.

=item 3

Have a single form of code used to implement the majority of Parrot, rather
than having a mix of C and PIR.

=back

We are also designing M0 to be as simple as possible, i.e. M0 should contain as
few ops as possible.  The complexity of Parrot will be built on top of M0, in
M1 (which will be written in M0) and beyond.  This is to facilitate multiple
implementations, e.g. a quick and dirty prototype implementation in JavaScript,
a space-optimized implementation targeted for mobile devices, a tracing jit
targeted for server use, etc.  M0's simplicity should be extreme; the moment M0
gets ops for the sake of efficiency or ease of use, it has failed its design
goals.

There will be no stacks in M0, not even for argument passing. Everything must
be in continuation-passing-style.

=head2 Scope

This document only covers M0 and the minimum VM necessary to support it.
Anything beyond that, e.g. the meta-object model or layout of contexts, is
beyond its scope.

=head2 Contexts

This is the central datastructure at the M0 level.  It will contain most of
the state that is needed to execute M0 bytecode.  A pointer to the current
context will be passed to each op as the implicit first argument, though this
pointer (or equivalent) will not be stored in bytecode.

A Context will contain:

=over 4

=item * INSP registers (fixed number of each) TODO: How many? Spillage?

=item * PC    - currently executing instruction (bytecode segment and offset)

=item * EH    - exception handler address (bytecode segment and offset)

=item * EX    - exception payload

=item * caller - calling context

=back

=head2 Registers

An M0 register may have one of 256 values.  This means that registers can point
at one of 256 different places in the variables table, which will support up to
65536 slots.   Registers can be pointed at different slots with the C<get_var>
instruction, which will interpret its second and third arguments as the index
into the variables table.

In this documentation, as in C, C<$0> refers to the value in register 0, where
C<*$0> refers to the value that register 0 points at.

=head2 List of Ops

M0 ops are very low-level and provide the simplest possible way of interacting
with the VM.  Apart from print/gripe/say (which are intended only for the early
stages of an M0 VM's development), M0 ops should painfully minimal.  It's
expected that common operations will be painful.  That's what compilers are
for.

The names and number of the ops below may change at any time, possibly without
any rational reason, until the spec is more stable.  As a way to verify that
the op set is complete, we will look at how a representative selection of PIR's
existing core ops and the dynops used by HLLs could be reimplemented in terms
of M0 ops.

In descriptions, C<$0> refers to the value of the first op, C<$1> to the second
and C<$2> to the third.

=head3 Math/numeric ops (12 ops)

=over

=item * add_i - integer addition

=item * add_n - add two numeric registers

Treat C<*$1> and C<*$2> as integer or floating-point values, add them and store
the result in C<*$0>.

=item * sub_i - subtract two integer registers

=item * sub_n - subtract two numeric registers

Treat C<*$1> and C<*$2> as integer or floating-point values, subtract C<*$2>
from C<*$1> and store the result in C<*$0>.

=item * mult_i - multiply two integer registers

=item * mult_n - multiply two numeric registers

Treat C<*$1> and C<*$2> as integer or floating-point values, multiply C<*$1> by
C<*$2> and store the result in C<*$0>.

=item * div_i - divide two integer registers

=item * div_n - divide two numeric registers

Treat C<*$1> and C<$*2> as integer or floating-point values, divide C<$*1> by
C<$*2> and store the result in C<$*0>.

=item * mod_i - remainder of of $2/$1 (integer)

=item * mod_n - remainder of of $2/$1 (numeric)

Treat C<*$1> and C<*$2> as integer or floating-point values, divide C<*$1> by
C<*$2> and store the remainder in C<*$0>.  Division by zero will make the the
M0 interpreter sad.

=item * iton - convert integer to numeric

Assume that C<*$1> is an integer value, convert it to a floating-point value
and store the result in C<*$0>.  C<$2> is ignored.

=item * ntoi - convert numeric to integer

Assume that C<*$1> is a floating-point value, convert it to an integer value
and store the result in C<*$0>.  C<$2> is ignored.

=back

=over

=head3 Bitwise ops (6 ops)

=item * ashr - right bitshift with sign extension

Shift the value in C<*$1> right by the number of bits in C<*$2>, with sign
extension, and store the result in C<*$0>.

=item * lshr - right bitshift without sign extension

Shift the value in C<*$1> right by the number of bits in C<$*2>, without sign
extension, and store the result in C<$*0>.

=item * shl - left bitshift

Shift the value in C<*$1> left by the number of bits in C<*$2> and store the
result in C<*$0>.

=item * and - bitwise AND

Store C<*$1> & C<*$2> into C<*$0>.

=item * or - bitwise OR

Store C<*$1> | C<*$2> into C<*$0>.

=item * xor - bitwise exclusive OR

Store C<*$1> ^ C<*$2> into C<*$0>.

=back

=head3 Control Flow (3 ops)

=item * goto - go to an offset in the current bytecode segment

Unconditionally transfer control flow to the bytecode offset in C<*$0> within
the current bytecode segment.  C<$1> and C<$2> are ignored.

=item * goto_if_eq - go to an offset in the current bytecode segment if the last two arguments are equal

Transfer control flow to the bytecode offset in C<*$0> within the current
bytecode segment iff the values of C<*$1> and C<*$2> are the same.

=item * goto_cs - go to an offset in another bytecode segment

Unconditionally transfer control flow to the bytecode offset in C<*$0> within
the current bytecode segment specified in C<*$1>.  If C<*$2> is 0, C<*$1> is
treated as the number of a chunk.  If C<*$2> is non-zero, C<*$1> is treated as
a string which contains the name of the chunk.

=back

=head3 Memory ops (4 ops)

=over

=item * set - sets a register to a value

Set C<*$0> to whatever is in C<*$1>.  C<*$2> is ignored.

=item * set_mem - set a region of memory

Write C<*$2> byte-sized values from C<*$1> to the memory location starting at
C<*$0>.  Segfaults may result.  Be careful.

=item * get_mem - get a region from memory

Write C<*$2> byte-sized values from the memory location starting at C<*$1> to
C<*$0>.  Segfaults may result.  Be careful.

=item * get_var - point a register at a variables table slot

Point C<*$0> at a slot on the variables table.  C<$1> contains the low byte,
C<$2> contains the high byte.  Both C<$1> and C<$2> are treated as 1-byte
immediate values.

Examples:

  #point register 0 at variable 123 (123 * 1 + 256 * 0)
  get_var 0, 123, 0

  #point register 3 at variable 257 (2   * 1 + 256 * 1)
  get_var 3, 1, 1

=back

=head3 FFI ops (4 ops)

=over

=item * csym - look up a function by name

Look up the function pointer for using the name in C<*$1> in the C function
namespace and put the pointer into C<*$0>.  C<$2> is ignored.  C<*$1> is assumed
to point at a C string.

Note that this function wraps the C<csym> C function.  Use it to access
C<Parrot_dlopen> and C<Parrot_dlsym> to deal wih dynamic libraries.

=item * ccall_arg - set an argument for a ccall

Take two arguments: an argument type in C<$0> and an argument source in C<$1>.
C<$0> is an immediate constant indicating the type of the argument.  The
possible values of C<$0> will be similar to those used by libffi
(https://github.com/atgreen/libffi/blob/master/doc/libffi.info ).  C<$1>
indicates which M0 register should be used to populate the value of the current
argument.  C<$2> is ignored.

=item * ccall_ret - get a return value from a ccall

C<ccall_ret> is similar to C<ccall_arg>, except that it copies the return value
of the previously-called function into C<*$1>.  C<$2> is ignored.

=item * ccall - invoke a function 

C<ccall> uses the function pointer in C<*$0> to call a C function, assuming that
its arguments have been set up correctly.  C<$1> and C<$2> are ignored.

=back

=head3 Temporary ops (6 ops)

=over

=item * print_s  - prints a string

Print the string at C<*$1> to the filehandle C<*$0>.

=item * print_i  - prints an int

Print the integer at C<*$1> to the filehandle C<*$0>.

=item * print_n  - prints a number

Print the floating-point number at C<*$1> to the filehandle C<*$0>.

=item * alloc - allocate memory (go through ffi)

Allocate C<*$1> bytes, store them in C<*$0>.  C<$2> is ignored.

=item * free - free memory (go through ffi)

Free the region of memory at C<*$0>.  C<$1> and C<$2> are ignored.

=item * exit - exit with the given status (go through ffi)

Call C's C<exit> function with C<*$0>.  C<$1> and C<$2> are ignored.

=back

These are too high-level and can be written in terms of simpler ops:

=over

=item * new  - create a new PMC
       * allocate memory
       * set default values
=item * store - store a register in a PMC, or vice versa

=item * get_cc - Get the current Lorito context

=item * invoke_cc - Invoke the current Lorito context
       * set return PC in context
       * switch code segment, if necessary
       * get (new) current PC from context

=item * new_ctx - Create a new Lorito context
       * allocate memory
       * set default values

=item * load_bytecode - load bytecode into the current Lorito context
       * allocate memory
       * make a couple of system calls (hand-waving here)

=item * mark_unused - tell the GC that this previously allocated memory is now unused

=back

=head2 Textual Representation

M0's textual format will mirror its binary representation.  It will consist of
a series of named chunks with the following format.  Any line beginning with an
octothorpe (#) is a comment and will be ignored.

=head3 Chunk Format

A chunk consists of a chunk identifier, a variables chunk, a metadata chunk and
a bytecode chunk.

=head3 Chunk Identifier

A chunk identifier consists of a single line beginning with '.chunk', followed
by a chunk name.  The name consists of a quote-delimited utf-8 string.
  
  .chunk "chunk_name"

=head3 Variables Table

The initial variables table is a numbered list of chunks of data.  Data can be
either an integer, a floating point number, a quote-delimited utf-8 string or
arbitrary data in hex notation.  For simplicity's sake, strings will only
support escaping double-quotes.  Any other data should be stored as a hex
string.  This space is used to initialize the variables table.  Any variables
used by the metadata table and the bytecode segment will be stored here.

  .variables
  0 1234
  1 1.12345e-12
  2 "asdfasdfs"
  3 "hello, \"world\""
  4 0x00ffbeef
  5 "line"
  6 23

=head3 Metadata

The metadata segment consists of triplets of integers mapping a name and a
bytecode offset to a value.  The first number is an offset into the bytecode
segment.  This is the instruction at which the metadata first takes effect.
The second number is the offset into the variables table that contains the name
of the metadata entry.  The third is the offset into the variables table that
contains the value.

  .metadata
  #at pc 1234, "line" is 3
  1243 5 6

=head3 Ops

The ops segment consists of a list of mnemonics for instructions and their
arguments.  All instructions take three int arguments between 0 and 255, even
if they aren't all used.

  .code
    set   1, 3, 9
    add_i 3, 2, 3
    cmp_i 2, 3, 3
    goto  0, 0, 0
  
=head2 Binary Representation

M0's binary representation will be composed of a fixed header, a single
directory segment and a bunch of segment triplets describing a chunk of
bytecode:

=over 4

=item * a variables table segment containing the objects that the segment needs

=item * a metadata segment that carries any extra data like HLL line numbers, function names, annotations and custom data.

=item * a code segment containing the ops

=back

We should design the binary format of M0 in a way that allows it to be mmapped
by an interpreter.

The header will look like:

  'asdfasdf' : 8-byte magic number (copy from pbc)
  0x?        : 1 byte number of bytes in an I registers
  0x?        : 1 byte number of bytes in an N register
  0x?        : 1 byte number of bytes in a opcode_t
  0x?        : 1 byte number of bytes in a pointer
  0x?        : 1 byte for endianness
  xxxxx      : padding

The directory segment will be a list of offsets to the starts of chunks within
the file.  It will have the following structure:

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : M0_DIR_SEG
  [
    opcode_t : offset of a chunk header
    opcode_t : size of chunk name
    [
      opcode_t : chunk name
    ]
  ]

A chunk will consist of a chunk directory segment, a bytecode segment, a
variables segment, a metadata segment, a chunk name and a unique identifier.

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : M0_CHUNKDIR_SEG
  opcode_t : offset of bytecode segment
  opcode_t : offset of variables segment
  opcode_t : offset of metadata segment
  opcode_t : size of chunk name
  [ 
    opcode_t : chunk name
  ]

The variables segment will contain any data needed to execute the bytecode.
Data will be explictly loaded into registers as needed.

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : M0_VARS_SEG
  [
    opcode_t : number of bytes in variable data
    ...      : variable data
  ]

The metadata segment contains any data about the bytecode that might come in
handy.  The actual data will live in the variables segment; this table just
provides a way to map values to names and bytecode offsets.

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : M0_META_SEG
  [
    opcode_t : bytecode offset relative to the start of the current bc seg where this data becomes effective
    opcode_t : offset into vartable for the name of this piece of metadata
    opcode_t : offset into vartable for the value of this piece of metadata
  ]

The bytecode segment contains a series of executable ops.  A pointer (or its
equivalent for a non-C language) to the current context will be passed as the
first argument to any op, but this pointer will not be stored in bytecode.

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : M0_BC_SEG
  [
    char : opcode
    char : arg1
    char : arg2
    char : arg3
  ]

=head2 Binary instruction format

Initially, M0 ops will be packed without any padding.  Once we have a
representative sample of running M0 code, we will benchmark various padding
strategies to find which have the best performance characteristics for a
typical expected workload.  A viable M0 interpreter implemented in a low-level
langauge like C will be needed to properly test this. 

=head2 M0 Runloop

The runloop is the part of the interpreter that executes ops directly.  It
doesn't much matter how those ops are executed, but the runloop does need to
accomplish the following:

=over

=item * fetch the instruction at the current PC

=item * execute the instruction

=item * increment the pc, if needed

=back

=head2 Objects

In Lorito, we'll still have INSP registers like PIR, but the S registers will
be PMCs that happen to be strings.  Additionally, PMCs and objects are being
unified. M0's idea of an object/PMC is a blob of memory which obeys a primitive
vtable interface, which is really just looking up an integer index in memory.

=head2 Memory Model

Memory can be allocated with alloc() and freed with free(). One can retrieve
values from memory with memget() and changed with memset().

Will some memory be protected in M0?

=head2 structs

Structs (as implemented in C) will be an abstraction on top of M0.  M0 will not
be concerned with them directly.

=head2 Types

There are four register types, Integer, Numeric, PMC and String. The string
type will merely be syntax sugar for accessing a PMC.

M0 registers will not have innate types; they'll be nothing more than a
collection of bits which are interpreted by M0's ops as having a certain type.
The types that ops attribute to register values will be based on the position
of the register in an M0 context's register set.  For example if an M0 context
has 25 registers (which it won't), their types might be as follows:

    number  type
    0       current context
    1       PC
    2       EH
    3       EX
    4       calling context
    5-9     I
    10-14   N
    15-19   S
    20-24   P

This means that an op which is passed the wrong value could pretty easily cause
chaos by clobbering the PC or changing the pointer to the current context.

=head2 Immediate Values

M0 supports loading values from the variables table into registers via the
C<get_var> instruction.

=head2 MOP interaction

A MOP will be implemented at the C<M1> level, so C<M0> must merely make it this
possible. The C<M0> does not and should not understand any structures at higher
levels. This will loosely couple C<M0> and C<M1> and allow them to evolve
independently.

=head2 FFI

=head3 FFI considerations

M0's FFI should be amenable to interpretation both by interpreters implemented
in C and high-level languages such as Python or Perl, to direct compilation to
machine code, to jitting and to compilation to static C.  Where possible, M0's
design should not impose any constraints that preclude efficient implementation
of any of type of interpreter.

=head3 Implementation

M0's FFI will implement similar functionality to dlfunc and dlvar in the form
of a minimal set of atoms which are sufficient to emulate that functionality.

M0 will know enough about FFI to build a static call frame and call a C
function pointer according to C calling conventions.  M0 will have four ops to
support this: C<csym>, C<ccall_arg>, C<ccall_ret> and C<ccall>.  These are
documented below.

=over 4

=item * csym sym, "function_name"

C<csym> looks up the function pointer for C<function_name> in the C function
namespace and puts the pointer into the register C<sym>.

=item * ccall_arg arg_type, arg_src

C<ccall_arg> takes two arguments: an argument type and an argument source.
C<arg_type> is a constant indicating the type of the argument.  The possible
values of C<arg_type> will be similar to those used by libffi
(https://github.com/atgreen/libffi/blob/master/doc/libffi.info ).  C<arg_src>
indicates which M0 register should be used to populate the value of the
current argument.

=item * ccall_ret arg_type, arg_dest

C<ccall_ret> is similar to C<ccall_arg>, except that it copies the return value
of the previously-called function into the register indicated by C<arg_dest>.

=item * ccall fp

C<ccall> uses an existing function pointer to call a C function.  It assumes
that arguments have been set up correctly.  Hilarity and segfaults are likely
to result from breaking this assumption.

=back

=head3 Examples

The following example code calls a function called C<hello_func>, which takes
no arguments and has no return value, in the library C<libhello.so>.  The use
of strings as direct arguments is a simplification for explanatory purposes.
In actual M0 bytecode, the string would be an index into the variables table. 

    dlopen_fp = csym "Parrot_dlopen"
    dlsym_fp  = csym "Parrot_dlsym"
    ccall_arg FFI_POINTER, "libhello.so" #hand-waving
    ccall     dlopen_fp
    ccall_ret FFI_POINTER, libhello

    ccall_arg FFI_POINTER, "hello_func" #more hand-waving
    ccall     dlsym_fp
    ccall_ret FFI_POINTER, hello_func

    ccall hello_func

This example shows how to call a function "multiply_int32" which take two
32-bit int arguments and returns an value of the same type and lives in
"libmath.so".  It assumes that dlsym_fp and dlopen_fp have been initialized as
in the first example.

    #dlsym_fp is a pointer to Parrot_dlsym
    #dlopen_fp is a pointeer to Parrot_dlopen

    ccall_arg FFI_POINTER, "libmath.so"
    ccall     dlopen_fp
    ccall_ret FFI_POINTER, libmath

    ccall_arg FFI_POINTER, libmath
    ccall_arg FFI_POINTER, "multiply_int32"
    ccall     dlsym_fp
    ccall_ret FFI_POINTER, multiply_fp

    set       arg0, 12
    set       arg1, 10

    ccall_arg FFI_UINT32, arg0
    ccall_arg FFI_UINT32, arg1
    ccall     multiply_fp
    ccall_ret FFI_UINT32, ret

    say ret  # will print "120"

This example shows how to call an internal function (i.e. one that does not
live in an external shared library) with the same signature as above.

    set       arg0, 12
    set       arg1, 10
    csym      func, "Parrot_multiply_ints"

    ccall_arg FFI_UINT32, arg0
    ccall_arg FFI_UINT32, arg1
    ccall     func
    ccall_ret FFI_UINT32, ret

    say ret  # will print "120"

=head2 Concurrency

This section will describe primitives that will be needed to allow data sharing and
synchronization between contexts.

The Actor model of concurrency currently looks promising http://en.wikipedia.org/wiki/Actor_model .
One implementation of the Actor model on the JVM is Akka : http://akka.io/

=head1 Lorito

=head2 Description

This section covers the parts of Lorito that are not directly relevant to
someone implementing an M0-compatible VM.  These topics are important to a
complete implementation of Lorito but do not need to be directly addressed by
M0 VM implementations.

Shouldn't this be a different spec document? Perhaps PDD33 for M1 ?

<this space intentionally left blank, for now>

=head2 Op Composition

<this space for rent>

=head2 Implementation

<this space intentionally left blank, for now>

=head2 References

<this space intentionally left blank, for now>

=cut

__END__
Local Variables:
  fill-column:78
End:
