# Copyright (C) 2011, Parrot Foundation.

=head1 PDD 32: M0 Design Spec

=head2 Abstract

This document specifies M0, the set of microcode-like ops on which Parrot will
be based, and their requisite runtime environment.

=head2 Version

$Revision$

=head2 Status

This document is a draft under active development.  Nothing is set in stone
yet.  If you would like to suggest improvements, please talk with cotto,
bacek, atrodo, chromatic or dukeleto.

=head2 M0 Milestones

This is a list of things that we expect the M0 VM to be able to do as this
spec progresses.  They're pretty basic, but that's the idea behind M0.

=over

=item * print 42 (hard-coded instructions are fine at this point)

=item * assemble an M0 assembly listing into M0 bytecode

=item * disassemble binary M0 bytecode into an M0 assembly listing

=item * print "hello, world\n"

=item * add two integer registers, store the result

=item * calculate the sum of a 10-element array of ints

=item * calculate the hash of a hard-coded string (any non-trivial algorithm)

=item * call a function with an argument, return a value

=back

=head2 Definitions

=over

=item * M0

C<M0> refers to the specification for a minimal virtual machine capable of
executing the ops described in this document.

=item * M0 ops

This is the lowest-level set of ops supported by an M0-compliant VM.  These
ops are a subset of the C<M0> specification.

=item * Lorito

Lorito refers to the combination of C<M0>, a meta-object model and the way
that they're used as a foundation for Parrot.

=item * Lorito Context

This refers to a Lorito Context PMC, which is the most important datastructure
at the M0 level. You could say that it is the "secret sauce" of M0. The exact
details of the Lorito Context PMC are still in flux.

A Context will contain:
INSP registers (fixed number of each)
PC    - currently executing instruction (bytecode segment and offset)
EH    - exception handler address (bytecode segment and offset)
EX    - exception payload
caller - calling context

=back

=head2 Design Goals

There are three goals that M0 needs to meet:

=over

=item 1

Have executable code with equivalent power to C.

=item 2

Have a form of code that can be easily analyzed.

=item 3

Have a single form of code used to implement the majority of Parrot, rather
than having a mix of C and PIR.

=back

We are also designing M0 to be as simple as possible.  As much as possible,
all the complexity of Parrot will be built on top of M0.  This is to
facilitate multiple implementations, e.g. a quick and dirty prototype
implementation in JavaScript, a space-optimized implemention targeted for
mobile devices, a tracing jit targeted for server use, etc.  M0's simplicity
should be extreme; the moment M0 gets ops for the sake of efficiency or ease
of use, it has failed its design goals.

There will be no stacks in M0, not even for argument passing. Everything must
be in Continuation-Passing-Style.

=head2 Scope

This document only covers M0 and the minimum VM necessary to support it.
Anything beyond that, e.g. the meta-object model or layout of contexts, is
beyond its scope.

=head2 List of Ops

M0 ops are very low-level and provide the simplest possible way of interacting
with the VM.  Apart from print/gripe/say (which are intended only for the early
stages of an M0 VM's development), M0 ops should painfully minimal.  It's
expected that common operations will be painful.  That's what compilers are
for.

The names and number of the ops below may change at any time, possibly without
any rational reason, until the spec is more stable.

=over

=item * print  - prints a string to a file handle

=item * add - add two registers

=item * multiply - multiply two registers

=item * set  - sets a register to a value

=item * get  - gets the value of a register

=item * cmp - numeric comparison

=back

These are too magical and can be written in terms of simpler ops:

=over

=item * new  - create a new PMC

=item * store - store a register in a PMC, or vice versa

=item * get_cc - Get the current Lorito context

=item * invoke_cc - Invoke the current Lorito context

=item * new_ctx - Create a new Lorito context

=item * load_bytecode - load bytecode into the current Lorito context

=back

=head2 Textual Representation

Describe what the textual form of M0 will look like.  The emphasis should be
on ease of consumption.  We won't be writing a large amount of M0 code by
hand; it's just fine if it's painful to do so for non-trivial use cases.

=head2 Binary Representation

proposal: M0's binary representation will be composed of a fixed header, a
single directory segment and a bunch of sets of 3 segments describing a chunk
of bytecode: a bytecode segment containing the ops, a variables table segment
containing the objects that the segment needs, and a metadata segment that
carries any extra data like HLL line numbers, function names, annotations,
custom data).  We should design the binary format of M0 in a way that allows
it to be mmapped by an interpreter. 

The header will look like:

  'asdfasdf' : 8-byte magic number (copy from pbc)
  0x?        : 1 byte number of bytes in an I registers
  0x?        : 1 byte number of bytes in an N register
  0x?        : 1 byte number of bytes in a opcode_t
  0x?        : 1 byte number of bytes in a pointer
  0x?        : 1 byte for endianness
  xxxxx      : padding

directory:

  opcode_t, number of opcode_t-sized units in this segment
  opcode_t, type of m0 directory segment
  [
    opcode_t : offset of bytecode segment
    opcode_t : offset of vartable segment
    opcode_t : offset of metadata segment
  ]

m0-bytecode - ops (many per file)

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : type of m0 bytecode segment
  [
    opcode_t : ops
  ]

m0-vartable - constants table, but they're not necessarily constants: first
context has these, other contexts get COW'd copies (one per bytecode segment)

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : type of m0 variables table segment
  [
    opcode_t: offset within segment to name
    opcode_t: pointer to object data
  ]

m0-metadata - anything else (line numbers, function names, annotations, etc)
(one per bytecode segment)

  opcode_t : number of opcode_t-sized units in this segment
  opcode_t : type of m0 metadata segment
  [
    opcode_t : data (idk)
  ]

=head2 Binary instruction format

describe the binary encoding of a single M0 instruction and how it should be
interpreteted.

=head2 M0 Runloop

The runloop is the part of the interpreter that executes ops directly.  It
doesn't much matter how those ops are executed, but the runloop does need to
accomplish the following:

=over

=item * fetch the instruction at the current PC

=item * execute the instruction

=item * increment the pc, if needed

=back

=head2 metadata

describe metadata here, e.g. debugging information, aggregate op tracking
info, whatever

=head2 Op Composition

If M0 needs to support op composition, describe it here.

=head2 Objects

In Lorito, we'll still have INSP registers like PIR, but the S registers will
be PMCs that happen to be strings.  Additionally, PMCs and objects are being
unified.  For the most part this is above the level of what M0 needs to care
about, but it will be important for M0 to print out strings and have some
intelligent way of interacting with PMCs.  Figure this out.

=head2 memory model

describe what kind of memory m0 ops will have access to and how they'll get at
it

=head2 structs

describe structs here, as far as they're relevant to m0

=head2 Types

There are four register types, Integer, Numeric, PMC and String. It remains to
be seen whether S and P will merely be syntax sugar for the same
datastructure.

question: how will ops deal with types?
options:
1 - ops are hard-coded per-type, registers contain no type info
2 - ops deal with whatever type they get, registers have type flags built-in (or built in to the op)
    e.g. op looks like this:
    byte : op
    byte : ctx
    byte : arg0
    byte : arg1
    byte : arg2
    3b   : arg0 flags (001 -> I, 010 -> N, ...)
    3b   : arg1 flags
    3b   : arg2 flags
3 - ops don't know about types, registers numbers are typed by convention
    0-19 -> I, 20 -> 39 -> N, ...
4 - register numbers mean different things depending on the op
    add 2, 3, 5 -> add $I2, $I3, $I5
    say 2, 3, 5 -> say $P2, $S3, $S5
5 - ???

=head2 MOP interaction

describe this here - the mop is mostly a higher-level concern than M0 cares
about, but M0 will need to describe how PMCs and strings behave.  To make that
happen, M0 needs to have some minimal concept of a pmc (and an object, since
they'll be the same thing under Lorito).

=head2 FFI

describe FFI here.  This will become especially important when we start
integrating Lorito with the rest of Parrot and want to be able to call into C
code from M0 and vice versa.

=head2 Concurrency

describe what primitives will be needed to allow data sharing and
synchronization between contexts.

=head1 Lorito

=head2 Description

This section covers the parts of Lorito that are not directly relevant to
someone implementing an M0-compatible VM.  These topics are important to a
complete implementation of Lorito but do not need to be directly addressed by
M0 VM implementations.

<this space intentionally left blank, for now>

=head2 Implementation

<this space intentionally left blank, for now>

=head2 References

<this space intentionally left blank, for now>

=cut

__END__
Local Variables:
  fill-column:78
End:
