# Copyright (C) 2011, Parrot Foundation.

=head1 PDD 32: M0 Design Spec

=head2 Abstract

This document specifies M0, the set of microcode-like opcodes (ops) on which
a future implementation of Parrot internals will be based. This document
also specifies how these ops will interact with other subsystems and their
requisite runtime environment.

=head2 Status

This document is a draft under active development.  Nothing is set in stone
yet.  If you would like to suggest improvements, please talk with cotto,
bacek, atrodo or dukeleto.

=head2 M0 Milestones

This is a list of things that we expect the M0 VM to be able to do as this
spec progresses.  They're pretty basic, but that's the idea behind M0.

=over

=item * print 42 (hard-coded instructions are fine at this point)

=item * assemble an M0 assembly listing into M0 bytecode

=item * disassemble binary M0 bytecode into an M0 assembly listing

=item * print "hello, world\n"

=item * add two integer registers, store the result

=item * calculate the sum of a 10-element array of ints

=item * calculate the hash of a hard-coded string (any non-trivial algorithm)

=item * call a function with an argument, return a value

=back

=head2 Definitions

=over

=item * M0

C<M0> refers to the specification for a minimal virtual machine capable of
executing the ops described in this document.  The M0 VM should have the same
expressive power as C and will live at the same level that C currently does.
This means that M0 explicitly does not need to know about higher-level concepts
such as garbage collection and Parrot's calling conventions.

=item * M0 ops

This is the lowest-level set of ops supported by an M0-compliant VM.  These
ops are a subset of the C<M0> specification.

=item * chunk

A chunk is a self-contained unit of code.  Chunks correspond roughly to
functions and have a variables table, a metadata segment and a bytecode
segment.  The variables table is used to store any persistent data.  The
metadata segment stores information about the code, for example annotations or
variable names.  The bytecode segment contains the executable ops.

=item * MOP

Meta object protocol.

=item * Lorito

Lorito refers to C<M0> and the levels above it, such as C<M1> which is written
in C<M0> ops, and possibily an C<M2> level which is written in C<M1> ops. More
specifically it refers to a new implementation of Parrot internals. A new MOP
is planned for Lorito and it will most probably live at the C<M1> op level.

=item * Lorito Context

This refers to a Lorito Context PMC, which is the most important datastructure
at the M0 level. You could say that it is the "secret sauce" of M0. The exact
details of the Lorito Context PMC are still in flux.

=back

=head2 Design Goals

There are three goals that M0 needs to meet:

=over

=item 1

Have executable code with equivalent power to C.

=item 2

Have a form of code that can be easily analyzed.

=item 3

Have a single form of code used to implement the majority of Parrot, rather
than having a mix of C and PIR.

=back

We are also designing M0 to be as simple as possible.  M0 should contain as few
ops as are needed to retain the ability to generate efficient bytecode.  The
complexity of Parrot will be built on top of M0, in PIR (a.k.a. M1) and above.
This simplicity exists to facilitate multiple implementations, e.g. a quick and
dirty prototype implementation in JavaScript, a space-optimized implementation
targeted for mobile devices, an adaptively-optimizing jit targeted for server
use, etc.  M0's simplicity should be extreme; the moment M0 gets ops for the
sake of developer efficiency or ease of use, it has failed its design goals.

There will be no stacks in M0, not even for argument passing. All internal
control flow apart from basic gotos with code segments must be in
continuation-passing style.  This will give M0-based code several benefits.  It
will ensure immunity from stack-smashing attacks and related programming
errors.  It will also eliminate the nested (inferior) runloop problem and opens
up interesting possibilities for an Erlang-like concurrency implementation.

CPS will also allow Parrot to use many pre-existing JIT algorithms, such
as those described in the paper "Trace Based Compilation in Interpreter-less
Execution Environments" [TBC].

=head2 Scope of This Document

This document only covers M0 and the minimum VM necessary to support it.
Anything beyond that, e.g. the meta-object model or layout of contexts, is
beyond its scope.

=head2 Contexts

This is the central datastructure at the M0 level.  It will contain most of
the state that is needed to execute M0 bytecode.  A pointer to the current
context will be passed to each op as the implicit first argument, though this
pointer (or equivalent) will not be stored in bytecode.  It layout is described
in detail in the C<Register Types and Context Structure> section.

=head2 Registers

An M0 register may have one of 256 values.  This means that registers can point
at one of 256 different places in the variables table, which will support up to
65536 slots.   Registers can be pointed at different slots with the C<set_var>
instruction, which will interpret its second and third arguments as the index
into the variables table.  The variables table serves both as a runtime
scratchpad and as a location for data which is extracted from bytecode to live.

=head2 List of Ops

M0 ops are very low-level and provide the simplest possible way of interacting
with the VM.  Apart from print/gripe/say (which are intended only for the early
stages of an M0 VM's development), M0 ops should painfully minimal.  It's
expected that common operations will be painful.  That's what compilers are
for.

The names and number of the ops below may change at any time, possibly without
any rational reason, until the spec is more stable.  As a way to verify that
the op set is complete, we will look at how a representative selection of PIR's
existing core ops and the dynops used by HLLs could be reimplemented in terms
of M0 ops.

In descriptions, C<$1> refers to the value of the first argument to an op,
C<$2> to the second and C<$3> to the third.  Any op can operate on any
register; types are only by convention.  As far as an M0 VM is conerned, the
256 ops are nothing more than an array of 256 opcode_t-sized chunks of data.

In this documentation, as in C, C<$1> refers to the value of a certain
register, where C<*$1> refers to what that register points at.

=head3 Control Flow (4 ops)

=over

=item * noop - do nothing

Explicitly do nothing.  C<$1>, C<$2> and C<$3> are ignored.

=item * goto - go to an offset in the current bytecode segment

Unconditionally transfer control flow to the bytecode offset in C<*$1> within
the current bytecode segment.  C<$2> and C<$3> are ignored.

=item * goto_if_eq - go to an offset in the current bytecode segment if the last two arguments are equal

Transfer control flow to the bytecode offset in C<*$1> within the current
bytecode segment iff the values of C<*$2> and C<*$3> are the same.

=item * goto_chunk - go to an offset in another chunk

Unconditionally transfer control flow to the bytecode offset C<*$1> within the
chunk named by the string C<*$2>. C<$3> is ignored.

=back

=head3 Math/numeric ops (12 ops)

=over

=item * add_i - integer addition

=item * add_n - add two numeric registers

Treat C<*$2> and C<*$3> as integer or floating-point values, add them and store
the result in C<*$1>.

=item * sub_i - subtract two integer registers

=item * sub_n - subtract two numeric registers

Treat C<*$2> and C<*$3> as integer or floating-point values, subtract C<*$3>
from C<*$2> and store the result in C<*$1>.

=item * mult_i - multiply two integer registers

=item * mult_n - multiply two numeric registers

Treat C<*$2> and C<*$3> as integer or floating-point values, multiply C<*$1> by
C<*$3> and store the result in C<*$1>.

=item * div_i - divide two integer registers

=item * div_n - divide two numeric registers

Treat C<*$2> and C<$*2> as integer or floating-point values, divide C<$*1> by
C<$*2> and store the result in C<$*0>.

=item * mod_i - remainder of of $3/$2 (integer)

=item * mod_n - remainder of of $3/$2 (numeric)

Treat C<*$2> and C<*$3> as integer or floating-point values, divide C<*$1> by
C<*$3> and store the remainder in C<*$1>.  Division by zero will make the the
M0 interpreter sad.

=item * iton - convert integer to numeric

Assume that C<*$2> is an integer value, convert it to a floating-point value
and store the result in C<*$1>.  C<$3> is ignored.

=item * ntoi - convert numeric to integer

Assume that C<*$2> is a floating-point value, convert it to an integer value
and store the result in C<*$1>.  C<$3> is ignored.

=back

=head3 Bitwise ops (6 ops)

=over

=item * ashr - right bitshift with sign extension

Shift the value in C<*$2> right by the number of bits in C<*$3>, with sign
extension, and store the result in C<*$1>.

=item * lshr - right bitshift without sign extension

Shift the value in C<*$2> right by the number of bits in C<$*2>, without sign
extension, and store the result in C<$*0>.

=item * shl - left bitshift

Shift the value in C<*$2> left by the number of bits in C<*$3> and store the
result in C<*$1>.

=item * and - bitwise AND

Store C<*$2> & C<*$3> into C<*$1>.

=item * or - bitwise OR

Store C<*$2> | C<*$3> into C<*$1>.

=item * xor - bitwise exclusive OR

Store C<*$2> ^ C<*$3> into C<*$1>.

=back

=head3 Memory ops (4 ops)

=over

=item * set - sets a register to a value

Set C<*$1> to whatever is in C<*$2>.  C<$3> is ignored.

=item * copy_byte - write a byte to memory

Write the byte in C<$2> to the memory location starting at C<*$1>.  Segfaults
may result.  Be careful.

=item * copy_mem - copy data to/from memory

Write C<*$3> bytes from the memory location starting at C<*$2> to C<*$1>.
Segfaults may result.  Be careful.

=item * set_var - point a register at a variables table slot

Point C<*$1> at a slot in the variables table. C<$2> contains the high byte of
the index, C<$3> contains the low byte.  Both C<$2> and C<$2> are treated as
1-byte immediate values.

The variables table is intended to serve both as a location where data from
bytecode can be accessed and as a reasonably large (256^2 slots) runtime
scratchpad.

Examples:

  # point register 0 at variable 123 (0 * 256 + 123 * 1)
  set_var 0, 0, 123

  # point register 3 at variable 1026 (4 * 256 + 2 * 1)
  set_var 3, 4, 2

=back

=head3 FFI ops (4 ops)

=over

=item * csym - look up a function by name

Look up the function pointer for using the name in C<*$2> in the C function
namespace and put the pointer into C<*$1>.  C<$3> is ignored.  C<*$2> is assumed
to point at a C string.

Note that this function wraps the C<csym> C function.  Use it to access
C<Parrot_dlopen> and C<Parrot_dlsym> to deal wih dynamic libraries.

=item * ccall_arg - set an argument for a ccall

Take two arguments: an argument type in C<*$1> and an argument source in C<$2>.
C<*$1> is an immediate constant indicating the type of the argument.  The
possible values of C<*$1> will be similar to those used by libffi
(https://github.com/atgreen/libffi/blob/master/doc/libffi.info ).  C<$2>
indicates which M0 register should be used to populate the value of the current
argument.  C<$3> is ignored.

=item * ccall_ret - get a return value from a ccall

C<ccall_ret> is similar to C<ccall_arg>, except that it copies the return value
of the previously-called function into C<*$2>.  C<$3> is ignored.

=item * ccall - invoke a function

C<ccall> uses the function pointer in C<*$1> to call a C function, assuming that
its arguments have been set up correctly.  C<$2> and C<$3> are ignored.

=back

=head3 Temporary ops (6 ops)

=over

=item * print_s  - prints a string

Print the string at C<*$2> to the filehandle C<*$1>.

=item * print_i  - prints an int

Print the integer at C<*$2> to the filehandle C<*$1>.

=item * print_n  - prints a number

Print the floating-point number at C<*$2> to the filehandle C<*$1>.

=item * alloc - allocate memory (go through ffi)

Allocate C<*$2> bytes, store them in C<*$1>.  C<$3> is ignored.

=item * free - free memory (go through ffi)

Free the region of memory at C<*$1>.  C<$2> and C<$3> are ignored.

=item * exit - exit with the given status (go through ffi)

Call C's C<exit> function with C<*$1>.  C<$2> and C<$3> are ignored.

=back

These are too high-level and can be written in terms of simpler ops:

=over

=item * new  - create a new PMC
       * allocate memory
       * set default values
=item * store - store a register in a PMC, or vice versa

=item * get_cc - Get the current Lorito context

=item * invoke_cc - Invoke the current Lorito context
       * set return PC in context
       * switch code segment, if necessary
       * get (new) current PC from context

=item * new_ctx - Create a new Lorito context
       * allocate memory
       * set default values

=item * load_bytecode - load bytecode into the current Lorito context
       * allocate memory
       * make a couple of system calls (hand-waving here)

=item * mark_unused - tell the GC that this previously allocated memory is now unused

=back

=head2 Textual Representation

M0's textual format will mirror its binary representation.  It will consist of
a series of named chunks with the following format.  Any line beginning with an
octothorpe (#) is a comment and will be ignored.

The first line that is not a comment or empty defines the version of M0 that
is being used. This is so that if ops are added in the future, we can differentiate
between different versions of M0 source code and bytecode.

The current version is 0.

=head3 Chunk Format

A chunk consists of a chunk identifier, a variables chunk, a metadata chunk and
a bytecode chunk.  A chunk represents self-contained computational units,
approximately analogous to a function.

=head3 Chunk Identifier

A chunk identifier consists of a single line beginning with '.chunk', followed
by a chunk name.  The name consists of a double quote-delimited utf-8 string
which must be unique. The empty string is allowed as a chunk name.

  .chunk "chunk_name"

This name is the primary way that code will refer to a chunk.  It is roughly
analogous to a function's name in an HLL.

=head3 Variables Segment

The variables segment contains a numbered list of chunks of data.  Data can be
either an integer, a floating point number, a quote-delimited utf-8 string or
arbitrary data in hex notation.  For simplicity's sake, strings will only
support escaping double-quotes.  Any other data should be stored as a hex
string.  This space is used to initialize the variables table.  Any data 
used by the metadata segment and the bytecode segment will be stored here.

The deserialized version of the variables segment is referred to as the
variables table.

  .variables
  0 1234
  1 1.12345e-12
  2 "asdfasdfs"
  3 "hello, \"world\""
  4 0x00ffbeef
  5 "line"
  6 23

=head3 Metadata Segment

The metadata segment consists of triplets of integers mapping a name and a
bytecode offset to a value.  The first number is an offset into the bytecode
segment.  This is the instruction at which the metadata first takes effect.
The second number is the offset into the variables table that contains the
name of the metadata entry.  The third is the offset into the variables table 
that contains the value.

  .metadata
  #at pc 1234, "line" is 23
  1243 5 6

=head3 Bytecode

The bytecode segment consists of a list of mnemonics for instructions and their
arguments.  All instructions take three int arguments between 0 and 255, even
if they aren't all used.

  .bytecode
    set   1, 3, 9
    add_i 3, 2, 3
    cmp_i 2, 3, 3
    goto  0, 0, 0

Instruction arguments may also use the register names specified in the C<Types>
section in place of numeric arguments.  This is nothing more than syntactic
sugar.  The two ops below will assemble to identical bytecode.  When
disassembling M0 bytecode, it is up to the disassembler to determine which form
will be output.

  div_i I0, I3, I4
  div_i 8,  11, 12

As a way to filter out visual noise from M0 bytecode assembly listings, the
value C<x> may be used as an instruction argument to indicate that the
argument's value is ignored.  C<x> is an alias for 0.

  goto 12, x, x

=head3 Full Example

The following should be a working "hello world" program in M0.

    .version 0
    .chunk "hello"
    .variables
    0 1
    1 "hello, world"
    2 0x0A00
    3 0
    .metadata
    .bytecode
    #I0 is 0
    set_var I0, 0, 0
    #I1 is "hello"
    set_var I1, 0, 1
    #I2 is "\n"
    set_var I2, 0, 2
    #I3 is 0
    set_var I3, 0, 3
    #print "hello" to stdout
    # x is arbitrary
    print_s I0, I1, x
    #print "\n" to stdout
    print_s I0, I2, x
    #exit with status 0
    exit I3, x, x


=head2 Binary Representation

M0's binary representation will be composed of a fixed header, a single
directory segment and a number of chunks.  Chunks correspond roughly to
functions and have the following segments:

=over 4

=item * a variables segment containing the data that the segment needs

=item * a metadata segment that carries any extra data like HLL line numbers, function names, annotations and custom data

=item * a code segment containing the ops

=back

{{{
NOTE: We should design the binary format of M0 in a way that allows it to be mmapped
by an interpreter. Which considerations does this imply?
}}}

The header has the following structure:

  "\376M0B\r\n\032\n" : 8-byte magic number (copied/modified from pbc)
  0x00       : 1 byte version number (currently 0)
  0x?        : 1 byte number of bytes in an I registers
  0x?        : 1 byte number of bytes in an N register
  0x?        : 1 byte number of bytes in a opcode_t
  0x?        : 1 byte number of bytes in a pointer
  0x?        : 1 byte for endianness
  xxxxx      : padding

The directory segment will be a list of offsets to the starts of chunks within
the file.  It will have the following structure:

  opcode_t : M0_DIR_SEG
  opcode_t : number of chunks in this segment
  opcode_t : number of opcode_t-sized units in this segment
  [
    opcode_t : offset of a variables segment
    opcode_t : size of chunk name
    [
      opcode_t : chunk name
    ]
  ]

The variables segment will contain any data needed to execute the bytecode.
Data will used to poplate the variables table and explictly loaded into
registers as needed.

  opcode_t : M0_VARS_SEG
  opcode_t : number of variables in this segment
  opcode_t : number of opcode_t-sized units in this segment
  [
    opcode_t : number of bytes in variable data
    ...      : variable data
  ]

The metadata segment contains any data about the bytecode that might come in
handy.  The actual data will live in the variables table; this segment just
provides a way to map values to names and bytecode offsets.

{{{
Should entries in the variables table referenced by the metadata segment
somehow be marked as constant?  It's almost certainly incorrect to change them
at runtime.

Adding flags to values in the variables table means adding a little complexity
and inviting more in the form of more flags.  What about either ignoring the
problem and saying "Don't do that," or adding an op to get the original value
of a variables table slot?
}}}

  opcode_t : M0_META_SEG
  opcode_t : number of entries in this segment
  opcode_t : number of opcode_t-sized units in this segment
  [
    opcode_t : bytecode offset relative to the start of the current bc seg where this data becomes effective
    opcode_t : offset into variables table for the name of this piece of metadata
    opcode_t : offset into variables table for the value of this piece of metadata
  ]

The bytecode segment contains a series of executable ops.  A pointer (or its
equivalent for a non-C language) to the current context will be passed as the
first argument to every op, but this pointer will not be stored in bytecode.

  opcode_t : M0_BC_SEG
  opcode_t : number of ops in this segment
  opcode_t : number of opcode_t-sized units in this segment
  [
    char : opcode
    char : arg1
    char : arg2
    char : arg3
  ]

=head3 Segment Numbers

    M0_DIR_SEG       0x01
    M0_VARS_SEG      0x02
    M0_META_SEG      0x03
    M0_BC_SEG        0x04

=head3 Opcode Numbers

In the interest of compatibility between implementations, the following is a
canonical list of the ops an M0 implementation must implement and the numbers
they must correspond to.  Other opcode numbers are implementation-specific and
are not require to have any defined semantics.

NOTE: This section is not current.  Updating it is not likely to be useful
until we're reasonably confident that we have a final set of ops.

    0x00 noop
    0x01 goto
    0x02 goto_if_eq
    0x03 goto_chunk
    0x04 add_i
    0x05 add_n
    0x06 sub_i
    0x07 sub_n
    0x08 mult_i
    0x09 mult_n
    0x0A div_i
    0x0B div_n
    0x0C mod_i
    0x0D mod_n
    0x0E iton
    0x0F ntoi
    0x10 ashr
    0x11 lshr
    0x12 shl
    0x13 and
    0x14 or
    0x15 xor
    0x16 set
    0x17 set_mem
    0x18 get_mem
    0x19 set_var
    0x1A csym
    0x1B ccall_arg
    0x1C ccall_ret
    0x1D ccall
    0x1E print_s
    0x1F print_i
    0x20 print_n
    0x21 alloc
    0x22 free
    0x23 exit

=head2 Execution

Execution of an binary M0 file beings with the first op in the bytecode segment
of the first chunk.  Each op consists of a 1-byte op number and 3 byte-sized
arguments.  The op number is used as an offset into a table of function
pointers (or something equivalent).  The current context is passed as the first
argument to all op functions.  The remaining three bytes of the op are passed
to the op function directly.  It is up to the op function how to interpret
these values.

=head3 M0 Runloop

The runloop is the part of the interpreter that executes ops directly.  The
runloop does need to accomplish the following:

=over

=item * fetch the instruction at the current PC

=item * execute the instruction

=item * increment the pc, if needed

=back

Execution of an M0 bytecode file starts with the first op of the first bytecode
segment in a file and ends when the interpreter exits.

=head2 Interaction Between Bytecode Segments

This section will specify the following:
 * how to reliably transfer control flow between chunks
 * how to reliably map between sub names and chunks
 * how values from one sub are accessed by another (arguments/returns)

=head2 Exceptions and Exception Handling

TODO: describe this here

=head2 Objects

In Lorito, we'll still have INSP registers like PIR, but the S registers will
be PMCs that happen to be strings.  Additionally, PMCs and objects are being
unified. M0's idea of an object/PMC is a blob of memory which obeys a primitive
vtable interface, which is really just looking up an integer index in memory.

=head2 Memory Model

Memory can be allocated with alloc() and freed with free(). One can retrieve
values from memory with memget() and changed with memset().

Will some memory be protected in M0?

=head2 Structs

Structs (as implemented in C) will be an abstraction on top of M0.  M0 will not
be concerned with them directly.

=head2 Register Types and Context Structure

There are four register types, Integer, Numeric, PMC and String. The string
type will merely be syntactic sugar for accessing a PMC.  From an M0
perpsective, S and P registers will be treated as opaque pointers

M0 registers will not have innate types; they'll be nothing more than a
collection of bits which are assumed to have a certain type by M0's ops.  The
types that ops attribute to register values will be based on the position of
the register in an M0 context's register set.  The proposed structure uses the
first 8 registers for context-specific information and has 62 of each primitive
type:

    number  type
    0       INTERP - global interpreter data (see below)
    1       PC  - current instruction within the current bytecode segment
    2       EH  - current exception handler
    3       EX  - exception being thrown, if any
    4       PCX - calling (parent) context
    5       CHUNK - the name of the currently-executing chunk
    6       VAR - pointer to variables table
    7       MDS - pointer to metadata segment
    8       BCS - pointer to bytecode segment
    9       reserved
    10      reserved 
    11      reserved
    12-72   I0 - I60
    73-133  N0 - N60
    134-194 S0 - S60
    195-255 P0 - P60

This means that an op which is passed the wrong value could pretty easily cause
chaos by clobbering the PC or changing the pointer to the current context.

=head2 Interpreter Data

While most of the interesting parts of runtime data will live in a context, it
still make sense to store some data in a global interpreter data structure.
This will include the following items, stored in the same way as context data.

    number  name       description
    0       OP_FUNCS   array of functions that implement ops
    1       CHUNKS     array of all loaded chunks
    2       CHUNK_INFO array of chunk metadata (currently just names)
    3       CONTEXTS   array of all known contexts
    4       CONFIG     static global config data

=head2 MOP interaction

A MOP will be implemented at the C<M1> level, so C<M0> must merely make it this
possible. The C<M0> does not and should not understand any structures at higher
levels. This will loosely couple C<M0> and C<M1> and allow them to evolve
independently.

=head2 FFI

=head3 FFI considerations

M0's FFI should be amenable to interpretation both by interpreters implemented
in C and high-level languages such as Python or Perl, to direct compilation to
machine code, to jitting and to compilation to static C.  Where possible, M0's
design should not impose any constraints that preclude efficient implementation
of any of type of interpreter.

=head3 Implementation

M0's FFI will implement similar functionality to dlfunc and dlvar in the form
of a minimal set of atoms which are sufficient to emulate that functionality.

M0 will know enough about FFI to build a static call frame and call a C
function pointer according to C calling conventions.  M0 will have four ops to
support this: C<csym>, C<ccall_arg>, C<ccall_ret> and C<ccall>.  These are
documented below.

=over 4

=item * csym sym, "function_name"

C<csym> looks up the function pointer for C<function_name> in the C function
namespace and puts the pointer into the register C<sym>.

=item * ccall_arg arg_type, arg_src

C<ccall_arg> takes two arguments: an argument type and an argument source.
C<arg_type> is a constant indicating the type of the argument.  The possible
values of C<arg_type> will be similar to those used by libffi
(https://github.com/atgreen/libffi/blob/master/doc/libffi.info ).  C<arg_src>
indicates which M0 register should be used to populate the value of the
current argument.

=item * ccall_ret arg_type, arg_dest

C<ccall_ret> is similar to C<ccall_arg>, except that it copies the return value
of the previously-called function into the register indicated by C<arg_dest>.

=item * ccall fp

C<ccall> uses an existing function pointer to call a C function.  It assumes
that arguments have been set up correctly.  Hilarity and segfaults are likely
to result from breaking this assumption.

=back

=head3 Examples

The following example code calls a function called C<hello_func>, which takes
no arguments and has no return value, in the library C<libhello.so>.  The use
of strings as direct arguments is a simplification for explanatory purposes.
In actual M0 bytecode, the string would be an index into the variables table.

    dlopen_fp = csym "Parrot_dlopen"
    dlsym_fp  = csym "Parrot_dlsym"
    ccall_arg FFI_POINTER, "libhello.so" #hand-waving
    ccall     dlopen_fp
    ccall_ret FFI_POINTER, libhello

    ccall_arg FFI_POINTER, "hello_func" #more hand-waving
    ccall     dlsym_fp
    ccall_ret FFI_POINTER, hello_func

    ccall hello_func

This example shows how to call a function "multiply_int32" which take two
32-bit int arguments and returns an value of the same type and lives in
"libmath.so".  It assumes that dlsym_fp and dlopen_fp have been initialized as
in the first example.

    #dlsym_fp is a pointer to Parrot_dlsym
    #dlopen_fp is a pointeer to Parrot_dlopen

    ccall_arg FFI_POINTER, "libmath.so"
    ccall     dlopen_fp
    ccall_ret FFI_POINTER, libmath

    ccall_arg FFI_POINTER, libmath
    ccall_arg FFI_POINTER, "multiply_int32"
    ccall     dlsym_fp
    ccall_ret FFI_POINTER, multiply_fp

    set       arg0, 12
    set       arg1, 10

    ccall_arg FFI_UINT32, arg0
    ccall_arg FFI_UINT32, arg1
    ccall     multiply_fp
    ccall_ret FFI_UINT32, ret

    say ret  # will print "120"

This example shows how to call an internal function (i.e. one that does not
live in an external shared library) with the same signature as above.

    set       arg0, 12
    set       arg1, 10
    csym      func, "Parrot_multiply_ints"

    ccall_arg FFI_UINT32, arg0
    ccall_arg FFI_UINT32, arg1
    ccall     func
    ccall_ret FFI_UINT32, ret

    say ret  # will print "120"

=head3 Constants

These are the constants which an M0-compliant FFI implementation should deal
with.  They are based on the types used by libffi.

    FFI_VOID
    FFI_UINT
    FFI_SINT
    FFI_UINT16
    FFI_SINT16
    FFI_UINT32
    FFI_SINT32
    FFI_UINT64
    FFI_SINT64
    FFI_FLOAT
    FFI_DOUBLE
    FFI_UCHAR
    FFI_SCHAR
    FFI_USHORT
    FFI_SSHORT
    FFI_UINT
    FFI_SINT
    FFI_ULONG
    FFI_SLONG
    FFI_LONGDOUBLE
    FFI_POINTER

=head2 Concurrency

This section will describe primitives that will be needed to allow data sharing and
synchronization between contexts.

The Actor model of concurrency currently looks promising http://en.wikipedia.org/wiki/Actor_model .
One implementation of the Actor model on the JVM is Akka : http://akka.io/

=head1 Lorito

=head2 Description

This section covers the parts of Lorito that are not directly relevant to
someone implementing an M0-compatible VM.  These topics are important to a
complete implementation of Lorito but do not need to be directly addressed by
M0 VM implementations.

Shouldn't this be a different spec document? Perhaps PDD33 for M1 ?

=head2 Op Composition

Op composition is considered magic-like and will not be part of M0.

=head2 Implementation

The newest prototype of this spec is being worked on in the 'm0-prototype'
branch:

    https://github.com/parrot/parrot/tree/m0-prototype


=head2 References

[TBC] - http://www.ics.uci.edu/~franz/Site/pubs-pdf/ICS-TR-10-01.pdf

=cut

__END__
Local Variables:
  fill-column:78
End:
