package TAP::Harness::Archive::MultipleHarnesses;
use strict;
use base 'TAP::Harness::Archive';
use File::Path;
use File::Spec;
use lib qw( ./lib );
use TAP::Harness::ReportByDescription;
our $VERSION = '0.01';

sub runtests {
    my ($self, $targetsref, @files) = @_;

    # tell TAP::Harness to put the raw tap someplace we can find it later
    my $dir = $self->{__archive_tempdir};
    $ENV{PERL_TEST_HARNESS_DUMP_TAP} = $dir;

    # get some meta information about this run
    my @test_labels = ();
    foreach my $subharness (@{$targetsref}) {
        my %har = %$subharness;
        my @tests = @{$har{tests}};
        foreach my $test (@tests) {
            push @test_labels, $test->[1];
        }
    }
    my %meta = (
        file_order => \@test_labels,
        start_time => time(),
    );

    my $aggregator = TAP::Parser::Aggregator->new;

    $aggregator->start();
    foreach my $set (@{$targetsref}) {
        # rewrite environment
        &{$set->{rule}} if defined $set->{rule};
        my $harness = TAP::Harness::ReportByDescription->new();
        $harness->aggregate_tests($aggregator, @{$set->{tests}});
    }
    $aggregator->stop();

    $meta{stop_time} = time();

    my @parsers = $aggregator->parsers;
    for ( my $i = 0; $i < @parsers; $i++ ) {
        $parsers[ $i ] = {
            start_time  => $parsers[ $i ]->start_time,
            end_time    => $parsers[ $i ]->end_time,
            description => $test_labels[ $i ],
        };
    }
    $meta{file_attributes} = \@parsers;

    my $cwd         = Cwd::getcwd();
    my $is_dir      = $self->{__archive_is_directory};
    my ($archive, $output_file);
    if( $is_dir ) {
        $output_file = $self->{__archive_tempdir};
    }
    else {
        $output_file = $self->{__archive_file};

        # go into the dir so that we can reference files
        # relatively and put them in the archive that way
        chdir($dir) or $self->_croak("Could not change to directory $dir: $!");

        unless (File::Spec->file_name_is_absolute($output_file)) {
            $output_file = File::Spec->catfile($cwd, $output_file);
        }

        # create the archive
        $archive = Archive::Tar->new();
        $archive->add_files($self->_get_all_tap_files);
        chdir($cwd) or $self->_croak("Could not return to directory $cwd: $!");
    }

    # add in any extra files
    if(my $x_files = $self->{__archive_extra_files}) {
        my @rel_x_files;
        foreach my $x_file (@$x_files) {
            # handle both relative and absolute file names
            my $rel_file;
            if( File::Spec->file_name_is_absolute($x_file) ) {
                $rel_file = File::Spec->abs2rel($x_file, $cwd);
            }
            else {
                $rel_file = $x_file;
            }
            push(@rel_x_files, $rel_file);
        }
        $archive->add_files(@rel_x_files) unless $is_dir;
        $meta{extra_files} = \@rel_x_files;
    }

    # add any extra_properties to the meta
    if(my $extra_props = $self->{__archive_extra_props}) {
        $meta{extra_properties} = $extra_props;
    }

    # create the YAML meta file
    my $yaml = YAML::Tiny->new();
    $yaml->[0] = \%meta;
    if( $is_dir ) {
        my $meta_file = File::Spec->catfile($output_file, 'meta.yml');
        open(my $out, '>', $meta_file) or die "Could not create meta.yml: $!";
        print $out $yaml->write_string;
        close($out);
    }
    else {
        $archive->add_data('meta.yml', $yaml->write_string);
        $archive->write($output_file, $self->{__archive_format} eq 'tar.gz') or die $archive->errstr;
        # be nice and clean up
        File::Path::rmtree($dir);
    }

    print "\nTAP Archive created at $output_file\n" unless $self->verbosity < -1;

    return $aggregator;
}

1;

__END__

=head1 NAME

TAP::Harness::Archive::MultipleHarnesses - Create an archive of multiple
harnesses of TAP test results

=cut

=head1 SYNOPSIS

    use TAP::Harness::Archive::MultipleHarnesses;
    my $archive = TAP::Harness::Archive::MultipleHarnesses->new(\%args);
    $archive->runtests(\@targets);

=head1 DESCRIPTION

This package subclasses Michael Peters' TAP::Harness::Archive package from
CPAN.  It provides its own C<runtests()> method for the case where you need to
create an archive of test results generated by running multiple harnesses
sequentially.

=head2 The Simplest Case

Under normal circumstances, you supply a list of tests to a single test harness and
run them all in the same environment.  This code is typical:

    $harness->runtests(@files);

=head2 Several Harnesses in Sequence

Now suppose that you need to run B<several> test harnesses in sequence.  If
all you want to do is to print their results and summaries to the console
without any attempt to report an B<overall> summary, you can simply wrap these
multiples harnesses in a Perl program and then -- to simplify things even
farther -- slap a F<make> target on it.

For example, in the Parrot project we call a series of harnesses with C<make
fulltest>, which is defined as:

    fulltest :
        -make testb \
        testf \
        testr \
        src_tests \
        run_tests \
        buildtools_tests \
        perl_tests \
        library_tests \
        codetest \
        benchmark_tests \
        manifest_tests \
        examples_tests \
        distro_tests \
        headerizer_tests

Each of these individual F<make> targets is a Perl program like:

    manifest_tests :
       	$(PERL) t/harness $(MANIFEST_TEST_FILES)

These individual targets do not necessarily run in the same environment.  For
example, C<testb>, C<testf> and C<testr> run exactly the same set of tests as
each other, but they run them in B<different> environments -- specifically,
with different Parrot runcores.

Each of these targets prints out its own summary.  No overall summary is kept.

=head2 Single Harness with Multiple Subharnesses

Now suppose that you wanted to run multiple harnesses but, for summary
purposes, have them aggregated into a single overall harness.  It is possible
to do this with a judicious mixture of methods from the Perl 5 core packages
TAP::Harness::Formatter and TAP::Harness::Aggregator in conjunction with
the non-core TAP::Harness::Archive.

    my @targets = (
        {
            label   => 'headerizer',
            rule    => sub { # subroutine to set environmental variables },
            tests   => ( # list of headerizer tests ),
        },
        {
            label   => 'testb',
            rule    => sub { # subroutine to set different environmental variables },
            tests   => ( # list of tests to be run with 'b' runcore ),
        },
    );
    # ...

    my ($formatter, $aggregator);
    $formatter   = TAP::Formatter::Console->new( {
        verbosity  => $ENV{HARNESS_VERBOSE},
        jobs       => $ENV{TEST_JOBS} || 1,
        directives => 1,
        timer      => $ENV{HARNESS_TIMER} || 0,
    } );
    $aggregator = TAP::Parser::Aggregator->new;

    $aggregator->start();
    foreach my $set (@targets) {
        # rewrite environment
        &{$set->{rule}} if defined $set->{rule};
        print STDERR "$set->{label}: running with: $ENV{TEST_PROG_ARGS}\n";
        my $harness = TAP::Harness->new( { formatter => $formatter } );
        $harness->aggregate_tests($aggregator, @{$set->{tests}});
    }
    $aggregator->stop();
    $formatter->summary($aggregator);
    # We'll treat both FAIL and NOTESTS as failures.
    my $exit_value = ($aggregator->get_status() eq 'PASS') ? 0 : 1;
    exit($exit_value);

This code enables us to write rules for different environmental variables for
different individual harnesses, but keep track of overall results and print a
single, overall summary.

=head2 Archive of Single Harness with Multiple Subharnesses

Now suppose that we want to make an archive of the above and send it off to a
smoke server.  Here things get tricky, so here's where we have to overwrite
C<TAP::Harness::Archive::runtests()>.

=head1 METHODS

=head2 C<runtests()>

Does B<not> take the same arguments as C<TAP::Harness::runtests()> or
C<TAP::Harness::Archive::runtests()>.  Instead, it takes a reference to an
array of hash references, where each hash has, at minimum, a C<tests> element
that holds a list of tests to be run and a C<rule> element which is a
reference to a subroutine that is executed before the corresponding list of
tests is run.

=cut

sub _get_all_tap_files {
    my ($self, $dir, $meta) = @_;
    $dir ||= $self->{__archive_tempdir};
    my @files;
    my %x_files;
    if($meta && $meta->{extra_files}) {
        %x_files = map { $_ => 1 } @{$meta->{extra_files}};
    }

    File::Find::find(
        {
            no_chdir => 1,
            wanted   => sub {
                return if /^\./;
                return if -d;
                my $rel_name = File::Spec->abs2rel($_, $dir);
                return if $rel_name eq 'meta.yml';
                push(@files, $rel_name) unless $x_files{$rel_name};
            },
        },
        $dir
    );
    return @files;
}


1;    # End of TAP::Harness::Archive::MultipleHarnesses
